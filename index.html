<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>POP FIELD</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; user-select: none; -webkit-user-select: none; }
canvas { display: block; width: 100%; height: 100%; }
#hud { position: fixed; top: 0; left: 0; right: 0; padding: 12px 16px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 10; font-family: 'Orbitron', 'Courier New', monospace; }
#hud > div { text-transform: uppercase; letter-spacing: 3px; font-size: 16px; color: rgba(255,255,255,0.85); text-shadow: 0 0 8px rgba(0,200,255,0.5); }
#hud .val { font-size: 24px; font-weight: bold; letter-spacing: 1px; }
#xp-bar-wrap { position: fixed; bottom: 0; left: 0; right: 0; height: 8px; background: rgba(255,255,255,0.06); z-index: 10; pointer-events: none; display: none; }
#xp-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #b24dff, #ff3c8e, #ffd84d); transition: width 0.3s ease-out; }
#title-screen, #gameover-screen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 20; pointer-events: none; font-family: 'Orbitron', 'Courier New', monospace; text-transform: uppercase; }
#title-screen h1 { font-size: 64px; letter-spacing: 16px; color: #fff; text-shadow: 0 0 30px rgba(0,200,255,0.8), 0 0 60px rgba(0,200,255,0.4); margin-bottom: 8px; }
#title-screen .sub { font-size: 18px; letter-spacing: 6px; color: rgba(255,255,255,0.5); margin-bottom: 24px; }
#title-screen .splash-info { max-width: 400px; text-align: center; margin-bottom: 24px; }
#title-screen .splash-item { margin-bottom: 14px; }
#title-screen .splash-label { font-size: 14px; letter-spacing: 3px; color: rgba(180,80,255,0.9); margin-bottom: 3px; }
#title-screen .splash-desc { font-size: 13px; letter-spacing: 1px; color: rgba(255,255,255,0.55); text-transform: none; line-height: 1.6; }
#title-screen .tap-start { font-size: 20px; letter-spacing: 8px; color: rgba(255,255,255,0.7); animation: pulse-text 2s ease-in-out infinite; }
#gameover-screen h1 { font-size: 48px; letter-spacing: 12px; color: #ff4060; text-shadow: 0 0 30px rgba(255,64,96,0.8); margin-bottom: 16px; }
#gameover-screen .score-display { font-size: 26px; letter-spacing: 4px; color: rgba(255,255,255,0.8); margin-bottom: 8px; }
#gameover-screen .tap-start { font-size: 18px; letter-spacing: 6px; color: rgba(255,255,255,0.5); margin-top: 30px; animation: pulse-text 2s ease-in-out infinite; }
@keyframes pulse-text { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
#upgrade-panel { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 30; background: rgba(0,0,0,0.75); font-family: 'Orbitron', 'Courier New', monospace; text-transform: uppercase; pointer-events: all; }
#upgrade-panel h2 { font-size: 36px; letter-spacing: 12px; color: #ffffff; text-shadow: none; margin-bottom: 30px; }
#upgrade-choices { display: flex; flex-direction: column; gap: 18px; width: 90%; max-width: 420px; }
.upgrade-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 20px 22px; cursor: pointer; transition: background 0.15s, border-color 0.15s; }
.upgrade-card:active { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.5); }
.upgrade-card .name { font-size: 20px; letter-spacing: 3px; color: rgba(255,255,255,0.95); margin-bottom: 4px; }
.upgrade-card .level { font-size: 13px; letter-spacing: 2px; color: rgba(255,255,255,0.4); margin-bottom: 6px; }
.upgrade-card .desc { font-size: 15px; letter-spacing: 1px; color: rgba(255,255,255,0.7); text-transform: none; line-height: 1.4; }
#biome-btn { position: fixed; top: 56px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#biome-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#biome-btn.active { border-color: rgba(0,229,255,0.5); color: #00e5ff; text-shadow: 0 0 8px rgba(0,229,255,0.4); }
#madness-btn { position: fixed; top: 88px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#madness-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#madness-btn.active { border-color: rgba(255,50,80,0.7); color: #ff3050; text-shadow: 0 0 8px rgba(255,50,80,0.5); }
#autolvl-btn { position: fixed; top: 120px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#autolvl-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#autolvl-btn.active { border-color: rgba(0,255,160,0.7); color: #00ffa0; text-shadow: 0 0 8px rgba(0,255,160,0.5); }
#inftaps-btn { position: fixed; top: 152px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#inftaps-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#inftaps-btn.active { border-color: rgba(255,200,50,0.7); color: #ffc832; text-shadow: 0 0 8px rgba(255,200,50,0.5); }
#testlvl-btn { position: fixed; top: 184px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#testlvl-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#testlvl-btn.active { border-color: rgba(168,60,255,0.7); color: #a83cff; text-shadow: 0 0 8px rgba(168,60,255,0.5); }
#spawnmbh-btn { position: fixed; top: 216px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#spawnmbh-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(96,224,255,0.4); color: #60e0ff; }
#expanse-btn { position: fixed; top: 248px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#expanse-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,200,50,0.4); color: #ffc832; }
#expanse-btn.active { border-color: rgba(212,146,10,0.7); color: #d4920a; text-shadow: 0 0 8px rgba(212,146,10,0.5); }
#lore-splash { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 50; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; transition: opacity 1.5s ease-out; pointer-events: all; cursor: pointer; }
#lore-splash.visible { opacity: 1; transition: opacity 3s ease-in; }
#lore-splash.fade-out { opacity: 0; transition: opacity 1.5s ease-out; }
#lore-splash .lore-symbol { font-size: 35px; color: rgba(180,80,255,0.7); margin-bottom: 24px; letter-spacing: 12px; font-family: 'Orbitron', 'Courier New', monospace; opacity: 0; transition: opacity 2s ease-out 0.5s; }
#lore-splash.visible .lore-symbol { opacity: 1; }
#lore-splash .lore-text { max-width: 600px; padding: 0 32px; text-align: center; font-family: 'Orbitron', 'Courier New', monospace; font-size: 18px; line-height: 2.0; color: rgba(255,255,255,0.9); letter-spacing: 1px; }
#lore-splash .lore-line { display: block; opacity: 0; transform: translateY(6px); }
#lore-splash.visible .lore-line { animation: lore-fade-in 2s ease-out forwards; }
#lore-splash .lore-attribution { margin-top: 28px; font-family: 'Orbitron', 'Courier New', monospace; font-size: 13px; letter-spacing: 4px; text-transform: uppercase; color: rgba(255,255,255,0.5); opacity: 0; transition: opacity 2s ease-out 2s; }
#lore-splash.visible .lore-attribution { opacity: 1; }
#lore-splash .skip-hint { position: absolute; bottom: 32px; font-family: 'Orbitron', 'Courier New', monospace; font-size: 13px; letter-spacing: 3px; text-transform: uppercase; color: rgba(255,255,255,0.3); opacity: 0; transition: opacity 1.5s ease-out 4s; }
#lore-splash.visible .skip-hint { opacity: 1; }
@keyframes lore-fade-in { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
#changelog-modal { position:fixed;top:0;left:0;right:0;bottom:0;z-index:48;background:rgba(0,0,0,0.92);display:none;flex-direction:column;align-items:center;justify-content:flex-start;opacity:0;transition:opacity 0.8s ease-in;pointer-events:all;overflow:hidden; }
#changelog-modal.visible { opacity:1; display:flex; }
#changelog-modal.fade-out { display:flex; opacity:0; transition:opacity 0.6s ease-out; }
#changelog-columns { display:flex;gap:32px;width:92%;max-width:1060px;margin-top:48px;padding-bottom:100px;align-items:flex-start;justify-content:center; }
#changelog-inner, #roadmap-inner { flex:1;max-width:500px;overflow-y:auto;max-height:calc(100vh - 120px);-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:rgba(180,80,255,0.3) transparent; }
#changelog-inner::-webkit-scrollbar, #roadmap-inner::-webkit-scrollbar { width:4px; }
#changelog-inner::-webkit-scrollbar-track, #roadmap-inner::-webkit-scrollbar-track { background:transparent; }
#changelog-inner::-webkit-scrollbar-thumb, #roadmap-inner::-webkit-scrollbar-thumb { background:rgba(180,80,255,0.3);border-radius:2px; }
#changelog-title, #roadmap-title { font-family:'Orbitron','Courier New',monospace;font-size:22px;letter-spacing:6px;text-transform:uppercase;color:rgba(255,255,255,0.95);text-align:center;margin-bottom:28px;padding-top:8px; }
#roadmap-title { color:rgba(80,220,255,0.95); }
.cl-section { margin-bottom:22px; }
.cl-section-title { font-family:'Orbitron','Courier New',monospace;font-size:13px;letter-spacing:3px;text-transform:uppercase;color:rgba(180,80,255,0.9);margin-bottom:10px; }
.cl-item { font-family:'Orbitron','Courier New',monospace;font-size:13px;line-height:1.8;color:rgba(255,255,255,0.85);letter-spacing:0.5px;padding-left:16px;position:relative;margin-bottom:4px; }
.cl-item::before { content:'›';position:absolute;left:0;color:rgba(180,80,255,0.75); }
.rm-section { margin-bottom:22px; }
.rm-section-title { font-family:'Orbitron','Courier New',monospace;font-size:13px;letter-spacing:3px;text-transform:uppercase;color:rgba(80,220,255,0.85);margin-bottom:10px; }
.rm-item { font-family:'Orbitron','Courier New',monospace;font-size:13px;line-height:1.8;color:rgba(255,255,255,0.7);letter-spacing:0.5px;padding-left:16px;position:relative;margin-bottom:4px; }
.rm-item::before { content:'○';position:absolute;left:0;color:rgba(80,220,255,0.55);font-size:11px; }
@media (max-width:700px) { #changelog-columns { flex-direction:column;align-items:center; } #changelog-inner, #roadmap-inner { max-width:90%;max-height:calc(50vh - 80px); } }
#changelog-continue { position:fixed;bottom:0;left:0;right:0;z-index:49;display:none;justify-content:center;padding:20px 0 32px 0;background:linear-gradient(0deg, rgba(0,0,0,0.95) 60%, transparent);pointer-events:all; }
#changelog-continue.visible { display:flex; }
#changelog-continue button { font-family:'Orbitron','Courier New',monospace;font-size:14px;letter-spacing:4px;text-transform:uppercase;color:rgba(255,255,255,0.92);background:rgba(180,80,255,0.15);border:1px solid rgba(180,80,255,0.35);border-radius:8px;padding:12px 36px;cursor:pointer;transition:background 0.15s,border-color 0.15s,color 0.15s; }
#changelog-continue button:hover { background:rgba(180,80,255,0.3);border-color:rgba(180,80,255,0.6);color:#fff; }
</style>
</head>
<body>

<div id="changelog-modal"></div>
<div id="changelog-continue"><button id="changelog-btn">Continue</button></div>

<div id="lore-splash">
  <div class="lore-symbol">&#9683;</div>
  <div class="lore-text" id="lore-text"></div>
  <div class="lore-attribution">&#8212; from the Membrane Codex</div>
  <div class="skip-hint">tap or press any key</div>
</div>

<canvas id="c"></canvas>
<button id="biome-btn" title="Toggle biome [B]">Abyss</button>
<button id="madness-btn" title="Toggle full madness [M]">Madness</button>
<button id="autolvl-btn" title="Auto level up">Auto LvL</button>
<button id="inftaps-btn" title="Infinite taps">&#8734; Taps</button>
<button id="testlvl-btn" title="Toggle test level">Test</button>
<button id="spawnmbh-btn" title="Spawn mini black hole">&#9899; BH</button>
<button id="expanse-btn" title="Toggle Expanse [X]">Expanse</button>

<div id="xp-bar-wrap"><div id="xp-bar-fill"></div></div>
<div id="hud" style="display:none;">
  <div>Taps<br><span class="val" id="hud-taps">3</span></div>
  <div style="text-align:center;">Level<br><span class="val" id="hud-level">1</span></div>
  <div id="hud-chain-wrap" style="text-align:center; opacity:0; transition: opacity 0.3s; min-width: 60px;">Chain<br><span class="val" id="hud-chain">0</span></div>
  <div style="text-align:right;">Score<br><span class="val" id="hud-score">0</span></div>
</div>

<div id="title-screen">
  <h1>POP FIELD</h1>
  <div class="sub">Chain Reaction</div>
  <div class="splash-info">
    <div class="splash-item">
      <div class="splash-label">&#9673; Archons</div>
      <div class="splash-desc">Some orbs remember what they were before separation. They ascend into Archon forms — pop them to unleash gravitational collapse.</div>
    </div>
    <div class="splash-item">
      <div class="splash-label">&#9679; Black Holes</div>
      <div class="splash-desc">Where the membrane tears deepest, voids open. Feed them mass, then collapse the singularity for a devastating chain.</div>
    </div>
    <div class="splash-item">
      <div class="splash-label">&#9670; Void Cracks</div>
      <div class="splash-desc">Scars that learned to defend themselves. First strike cracks the armor. Second strike shatters what infinity built.</div>
    </div>
    <div class="splash-item">
      <div class="splash-desc" style="color: rgba(255,255,255,0.35); font-style: italic; margin-top: 8px;">Something watches from beyond the membrane. As the field destabilizes, the boundary thins. You will feel their gaze before you see them.</div>
    </div>
  </div>
  <div class="tap-start">Tap to Start</div>
</div>

<div id="gameover-screen" style="display:none;">
  <h1>Game Over</h1>
  <div class="score-display" id="go-score">Score: 0</div>
  <div class="score-display" id="go-level">Level: 1</div>
  <div class="score-display" id="go-chain">Best Chain: 0</div>
  <div class="tap-start">Tap to Restart</div>
</div>

<div id="upgrade-panel">
  <h2>Level Up</h2>
  <div id="upgrade-choices"></div>
</div>

<script>
// ==================================================
// SECTION 1: CONSTANTS & CONFIGURATION
// ==================================================
const BASE_TAPS = 8;                    // tighter start — forces strategic play
const BASE_CIRCLE_COUNT = 35;          // enough to chain but not overwhelming
const BASE_CIRCLE_RADIUS = 18;
const BASE_BLAST_RADIUS = 50;          // tighter start — slower cascade growth
const MAX_BLAST_RADIUS = 115;          // lower cap — controlled late-game power
const MAX_TAP_DISTANCE = 80;
const MAX_CIRCLES = 300;
const MAX_PARTICLES = 800;
const MAX_EXPLOSIONS = 40;
const MAX_FLOATING_TEXTS = 15;
const MAX_PAINT_SPLATS = 200;
const MAX_AFTERSHOCKS = 20;
const XP_BASE = 15;                     // level 2 after ~3-4 decent chains
const XP_SCALE = 1.70;                  // balanced curve: 15→26→43→73→125...
const INTER_ORB_GRAVITY = 15;            // gentle pull from bigger → smaller orbs
const CHAIN_POP_DELAY_MIN = 0.015;
const CHAIN_POP_DELAY_MAX = 0.045;
const CHAIN_POP_DELAY_JITTER = 0.015;
const LINK_TENSION_TIME_BASE = 0.18;
// Chain animation speed tiered by combo size:
//  TIER S (50+):  Full epic pacing — dramatic pauses, max impact
//  TIER A (30-49): Good but 40% less dramatic than S — snappier, less buildup
//  TIER B (15-29): Fast, satisfying, no drama
//  TIER C (<15):   Very snappy, quick pops
function getLinkTensionTime() {
  if (G.chainCount >= 50) return LINK_TENSION_TIME_BASE;            // S-tier: full epic
  if (G.chainCount >= 30) return LINK_TENSION_TIME_BASE * 0.60;     // A-tier: 40% less epic
  if (G.chainCount >= 15) return LINK_TENSION_TIME_BASE * 0.70;     // B-tier: fast
  return LINK_TENSION_TIME_BASE * 0.55;                              // C-tier: very snappy
}
const LINK_PULL_STRENGTH = 120;
const SC_SPAWN_CHANCE = 0.09;
const SC_RADIUS_MULT = 1.6;
const SC_SPIKE_MIN = 5;
const SC_SPIKE_MAX = 8;
const SC_GRAVITY_LIFE = 0.4;
const SC_GRAVITY_STRENGTH = 200;
const DELAYED_BLAST_MINOR = 20;        // first bonus blast needs real effort
const DELAYED_BLAST_MAJOR = 35;        // megacombo is an achievement
const DELAYED_BLAST_MEGA = 55;         // true megacombo is rare and special
const TAP_TIMER_BASE = 10;             // tighter decay — taps are precious
const BOMB_FUSE_TIME = 3.5;
const BOMB_BLAST_MULT = 1.4;

// ==================================================
// SECTION 2: PALETTE DEFINITIONS
// ==================================================
// Colors per palette: warm + green — violet, pink, gold, emerald
const PALETTES = [
  { // Level 1-3: Deep violet + hot pink + warm gold + emerald
    name: 'PHASE I',
    bgTop: '#0d0018', bgBot: '#1a0028',
    colors: ['#a83cff', '#ff2d7e', '#ffcc33', '#3dffa0'],
    accent: '#e040fb',
    baseNote: 240,
    oscType: 'sine'
  },
  { // Level 4-6: Richer, more saturated
    name: 'PHASE II',
    bgTop: '#120020', bgBot: '#200035',
    colors: ['#9c27b0', '#ff1a6e', '#ffe066', '#00e676'],
    accent: '#ea80fc',
    baseNote: 262,
    oscType: 'sine'
  },
  { // Level 7-9: Deeper, neon edges
    name: 'PHASE III',
    bgTop: '#0a0014', bgBot: '#1a0030',
    colors: ['#7c4dff', '#ff4081', '#ffca28', '#69f0ae'],
    accent: '#d500f9',
    baseNote: 294,
    oscType: 'sawtooth'
  },
  { // Level 10-12: High contrast, electric
    name: 'PHASE IV',
    bgTop: '#06000f', bgBot: '#14002a',
    colors: ['#651fff', '#f50057', '#ffc400', '#00e5ff'],
    accent: '#aa00ff',
    baseNote: 330,
    oscType: 'sawtooth'
  },
  { // Level 13+: Ultra vivid, white-hot accents
    name: 'PHASE V',
    bgTop: '#04000a', bgBot: '#10001e',
    colors: ['#d050ff', '#ff2070', '#ffe180', '#76ff03'],
    accent: '#e040fb',
    baseNote: 349,
    oscType: 'sine'
  }
];
const PALETTE_LEVELS = 3; // levels per palette

// Special biomes — toggled manually, override the level-based palette
const SPECIAL_BIOMES = [
  { // ABYSS — deep ocean trench, bioluminescent
    // Colors transition with madness: desaturated B&W → vivid bioluminescent
    name: 'ABYSS',
    bgTop: '#000a12', bgBot: '#001018',
    colors: ['#00e5ff', '#00bfa5', '#76ff03'],
    accent: '#18ffff',
    baseNote: 180,
    oscType: 'triangle',
    // Extended vivid palette — unlocks progressively with madness saturation
    // Goes WILD at high saturation: full bioluminescent rainbow
    vividColors: ['#00e5ff', '#00bfa5', '#76ff03', '#e040fb', '#ff4081', '#ffd740', '#7c4dff',
                  '#00fff5', '#ff6ec7', '#b0ff00', '#ea80fc', '#84ffff'],
    // cyan, teal, lime, violet, hot pink, gold, deep purple, aqua, neon pink, chartreuse, lavender, ice
    vividAccent: '#e0ff80'  // bright warm accent at full saturation
  },
  { // TESTLEVEL — 100% copy of Biome 1 (PHASE I) for experimentation
    name: 'TESTLEVEL',
    bgTop: '#0d0018', bgBot: '#1a0028',
    colors: ['#a83cff', '#ff2d7e', '#ffcc33', '#3dffa0'],
    accent: '#e040fb',
    baseNote: 240,
    oscType: 'sine'
  },
  { // EXPANSE — vast desert, ancient heavy Phons, the Sculptor's domain
    name: 'EXPANSE',
    bgTop: '#1a0f08',   // dark warm brown
    bgBot: '#0d0604',   // deep burnt umber
    colors: ['#d4920a', '#b87333', '#8b4513', '#a52a2a', '#e8d5b0'],
    // amber, copper, saddlebrown, dried-blood, bone-white
    accent: '#ffb347',   // warm amber glow
    baseNote: 120,       // lowest of any biome — deep sub-bass
    oscType: 'sine',
    vividColors: ['#d4920a', '#b87333', '#c0392b', '#e8d5b0', '#8b6914',
                  '#cd853f', '#ff6347', '#daa520', '#f4a460', '#bc8f8f'],
    vividAccent: '#ffd700'
  }
];

// Biome lore intro texts — shown on biome transitions
const BIOME_LORE = {
  'PHASE I': [
    'The field awakens. Orbs drift in primordial silence.',
    'Matter condenses from nothing. The first whispers of form.',
    'A membrane between worlds stretches thin. Light seeps through.'
  ],
  'PHASE II': [
    'Warmth bleeds through. The orbs grow restless.',
    'The field remembers motion. Patterns emerge from chaos.',
    'Energy pools in the spaces between. Something stirs.'
  ],
  'PHASE III': [
    'Fractures spread. Something watches from the edges.',
    'The orbs pulse with stolen light. Gravity bends wrong.',
    'Archons form unbidden. The field is no longer yours alone.'
  ],
  'PHASE IV': [
    'The field hungers. The Watchers press closer.',
    'Chains echo longer than they should. Time thickens.',
    'The void between orbs is not empty. It breathes.'
  ],
  'PHASE V': [
    'Boundaries dissolve. Their gaze is all that remains.',
    'Every pop tears the membrane further. The Watchers drink.',
    'The field and the void are one. You were always here.'
  ],
  'ABYSS': [
    'You sink below. A different eye opens in the deep.',
    'Pressure crushes thought. Bioluminescent horrors drift past.',
    'The deep remembers what the surface forgot. It waits.',
    'Light has no dominion here. Only hunger glows.',
    'The Leviathan was not born. It accumulated.'
  ],
  'EXPANSE': [
    'The Sculptor stood here. The red eyes remember.',
    'In the Expanse, being briefly correct is not enough.',
    'The making-place. The silence before form.',
    'Monitoring Station 7 has drifted again.',
    'Each beast of the land took its own way in living.'
  ]
};

// ==================================================
// SECTION 3: UPGRADE DEFINITIONS
// ==================================================
const UPGRADE_DEFS = {
  novaRadius:   { name: 'Rupture',       maxLvl: 8, desc: l => `Blast tears +${l*5}px wider through the membrane` },
  echoBurst:    { name: 'Echo',          maxLvl: 6, desc: l => `${8*l}% chance each pop echoes — a second wound opens (1.3x)` },
  gravityWell:  { name: 'Gravity Well',  maxLvl: 6, desc: l => `Pops pull nearby orbs inward — the field remembers wholeness` },
  volatileOrbs: { name: 'Volatile',      maxLvl: 5, desc: l => `${8*l}% of orbs glow unstable — when popped, 3x devastation` },
  aftershock:   { name: 'Aftershock',    maxLvl: 5, desc: l => `Pops scar the field for ${(0.5*l).toFixed(1)}s — orbs drifting in are consumed` },
  fission:      { name: 'Fission',       maxLvl: 4, desc: l => `Each pop splits ${Math.min(2,l)} fragment${Math.min(2,l)>1?'s':''} that scatter outward and chain` },
  chainFuel:    { name: 'Harvest',       maxLvl: 6, desc: l => `Tap rewards x${(1+0.3*l).toFixed(1)} — longer chains feed more` },
  density:      { name: 'Density',       maxLvl: 6, desc: l => `+${6*l}% orb mass — the field grows denser, chains cascade further` },
  bombCharges:  { name: 'Sigil',         maxLvl: 3, desc: l => `Long press to place ${l} sigil${l>1?'s':''} — detonates after ${BOMB_FUSE_TIME}s (${Math.round(BOMB_BLAST_MULT*100)}% blast)` },
  attractorField: { name: 'Attractor',  maxLvl: 5, desc: l => `Taps pull orbs inward (range ${60+l*30}px) — gravity draws them in` }
};

// Archons (SCs): Random orbs ascend into larger, spiky "Archon" forms
// When popped, Archons create a gravity well that pulls orbs inward AND have 1.5x blast radius
// They appear with tendrils and blinking eyes — pop them during chains for massive combos

// ==================================================
// SECTION 4: GAME STATE
// ==================================================
const G = {
  state: 'title',
  taps: BASE_TAPS,
  score: 0,
  level: 1,
  xp: 0,
  xpToNext: XP_BASE,
  bestChain: 0,
  chainActive: false,
  chainCount: 0,
  chainXpValue: 0,
  chainQueue: [],
  chainTimer: 0,
  chainOriginX: 0,
  chainOriginY: 0,
  chainGenId: 0,     // increments each chain — fragments born during chain X are immune until it ends
  time: 0,
  dt: 0,
  rawDt: 0,
  timeScale: 1.0,
  shakeAmount: 0,
  whiteGlow: 0,
  chromaticAb: 0,
  upgrades: { novaRadius:0, echoBurst:0, gravityWell:0, volatileOrbs:0, aftershock:0, fission:0, chainFuel:0, density:0, bombCharges:0, attractorField:0 },
  cursorX: -1000, cursorY: -1000,
  cursorVx: 0, cursorVy: 0,
  prevCursorX: -1000, prevCursorY: -1000,
  circles: [],
  particles: [],
  explosions: [],
  floatingTexts: [],
  paintSplats: [],
  aftershocks: [],
  chainLinks: [],
  biomeIndex: 0,
  prevBiomeIndex: 0,
  biomeTransition: 1,
  canvas: null,
  ctx: null,
  W: 0,
  H: 0,
  dpr: 1,
  audioCtx: null,
  audioUnlocked: false,
  scanlinePattern: null,
  pendingLevelUp: false,
  lastTime: 0,
  nextCircleId: 0,
  refillQueue: [],
  refillTimer: 0,
  gravityWells: [],
  delayedBlast: null,
  tapTimer: 0,
  tapTimerMax: TAP_TIMER_BASE,
  bombs: [],
  bombsPlacedThisRound: 0,
  blackHole: null,
  blackHoles: [],
  blackHoleTimer: 0,
  superBlackHole: null,
  superBlackHoleTimer: 0,
  watcher: { opacity: 0, eyeGlow: 0, reachAmount: 0, breathPhase: 0 },
  horrorBoost: 0,      // cumulative horror from black holes (0-0.5 range, adds to score-based horror)
  biomeOverride: -1,  // -1 = use level-based, 0+ = index into SPECIAL_BIOMES
  prevPalette: null,
  beatPhase: 0,        // 100 BPM beat tracker (0-1 per beat)
  beatPulseOrbs: [],   // indices of orbs currently pulsing on beat
  boss: null,          // active boss entity
  bossTimer: 15,       // countdown to first boss spawn
  bossKillCount: 0,    // total bosses killed this run
  zoomLevel: 2.0,      // current zoom (2.0 = 200%, zoomed in; 0.5 = 50% zoomed out)
  zoomTarget: 2.0,     // smooth zoom transition target
  gameLeft: 0,         // visible game area boundaries (updated each frame from zoom)
  gameTop: 0,
  gameRight: 0,
  gameBottom: 0,
  gameW: 0,
  gameH: 0,
  popCenterX: 0,           // exponential moving average of pop positions
  popCenterY: 0,
  popTrackCount: 0,         // number of pops tracked for directional bias
  shadowBalls: [],           // non-interactive dark phantom orbs at 70%+ madness
  riftWalls: [],             // energy barriers that block blast propagation
  riftWallTimer: 0,          // cooldown between wall spawns
  bridges: [],               // Phase 6: gravity bridges between same-color orbs
  bridgeCheckTimer: 0,       // timer for bridge proximity checks (every 0.3s)
  wtMilestones: { 50: false, 75: false, 90: false }, // World Transparency milestone triggers
  wtBanner: null,            // active WT milestone banner { text, subtext, timer, duration, color }
  miniBlackHoles: [],        // mini black hole entities (spawned at 75%+ madness)
  miniBlackHoleTimer: 0,     // spawn interval timer for mini black holes
  gravityInvertFactor: 1.0,  // smooth gravity direction (-1 to 1, 1=normal)
  gravityInvertSwitchCooldown: 0, // min hold time before next state change
  wormhole: null             // wormhole entity for B1 level ending
};

function resetGame() {
  // Preserve circles spawned during instructions screen to avoid teleport on game start
  const preservedCircles = G.circles && G.circles.length > 0 ? G.circles : null;
  G.state = 'playing';
  G.taps = BASE_TAPS;
  G.score = 0;
  G.level = 1;
  G.xp = 0;
  G.xpToNext = XP_BASE;
  G.bestChain = 0;
  G.chainActive = false;
  G.chainCount = 0;
  G.chainXpValue = 0;
  G.chainQueue = [];
  G.chainTimer = 0;
  G.time = 0;
  G.timeScale = 1.0;
  G.shakeAmount = 0;
  G.whiteGlow = 0;
  G.chromaticAb = 0;
  G.upgrades = { novaRadius:0, echoBurst:0, gravityWell:0, volatileOrbs:0, aftershock:0, fission:0, chainFuel:0, density:0, bombCharges:0, attractorField:0 };
  G.circles = [];
  G.particles = [];
  G.explosions = [];
  G.floatingTexts = [];
  G.paintSplats = [];
  G.aftershocks = [];
  G.chainLinks = [];
  G.gravityWells = [];
  G.delayedBlast = null;
  G.tapTimer = TAP_TIMER_BASE;
  G.tapTimerMax = TAP_TIMER_BASE;
  G.bombs = [];
  G.bombsPlacedThisRound = 0;
  G.blackHoles = [];
  G.blackHoleTimer = 0;
  G.superBlackHole = null;
  G.superBlackHoleTimer = 0;
  G.miniBlackHoles = [];
  G.miniBlackHoleTimer = 0;
  G.watcher = { opacity: 0, eyeGlow: 0, reachAmount: 0, breathPhase: 0 };
  G.horrorBoost = 0;
  G.biomeIndex = 0;
  G.prevBiomeIndex = 0;
  G.biomeTransition = 1;
  G.pendingLevelUp = false;
  G.nextCircleId = 0;
  G.refillQueue = [];
  G.refillTimer = 0;
  G.beatPhase = 0;
  G.beatPulseOrbs = [];
  G.boss = null;
  G.bossTimer = 30;
  G.bossKillCount = 0;
  G.zoomLevel = 2.0;
  G.zoomTarget = 2.0;
  G.popCenterX = 0;
  G.popCenterY = 0;
  G.popTrackCount = 0;
  G.shadowBalls = [];
  G.riftWalls = [];
  G.riftWallTimer = 0;
  G.bridges = [];
  G.bridgeCheckTimer = 0;
  G.wtMilestones = { 50: false, 75: false, 90: false };
  G.wtBanner = null;
  G.marbleMode = 0; // timer in seconds, >0 = marble physics active
  G.gravityInvertTimer = 0; // >0 = gravity inverted (shadow ball prism trigger)
  G.prismClusterActive = false; // true while shadow ball cluster is dense enough
  G.prismCooldown = 0; // cooldown after prism deactivates before it can trigger again
  G.gravityInvertFactor = 1.0;
  G.gravityInvertSwitchCooldown = 0;
  G.wormhole = null;
  // Compute game boundaries immediately so spawning uses correct area
  const resetHalfW = G.W / (2 * G.zoomLevel);
  const resetHalfH = G.H / (2 * G.zoomLevel);
  const resetCx = G.W / 2, resetCy = G.H / 2;
  G.gameLeft = resetCx - resetHalfW;
  G.gameTop = resetCy - resetHalfH;
  G.gameRight = resetCx + resetHalfW;
  G.gameBottom = resetCy + resetHalfH;
  G.gameW = G.gameRight - G.gameLeft;
  G.gameH = G.gameBottom - G.gameTop;
  whirlwindTimer = 0;
  whirlwindActive = 0;
  whirlwindDir = 1;
  pgeBeatAccum = 0;
  pgeBeatsSinceLast = 0;
  abyssPressureTimer = 0;
  abyssPressureWave = 0;
  abyssBeatAccum = 0;
  abyssBeatsSinceLast = 0;
  shadowSpawnTimer = 0;
  // If circles already exist from instructions phase, keep them (no teleport)
  if (preservedCircles && preservedCircles.length > 0) {
    G.circles = preservedCircles;
  } else {
    spawnInitialCircles();
  }
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('xp-bar-wrap').style.display = 'block';
  document.getElementById('xp-bar-fill').style.width = '0%';
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  document.getElementById('upgrade-panel').style.display = 'none';
}

// ==================================================
// SECTION 5: AUDIO SYSTEM
// ==================================================
function initAudio() {
  if (G.audioCtx) return;
  try {
    G.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    G.audioUnlocked = true;
  } catch(e) {}
  // Start galaxy background video on first user interaction
  ensureGalaxyBgPlaying();
}

function playPopSound(chainIndex) {
  if (!G.audioCtx) return;
  const biome = getCurrentBiome();
  const freq = Math.min(biome.baseNote * Math.pow(1.055, Math.min(chainIndex, 70)), 4000);
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = biome.oscType;
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + 0.1);
  const vol = Math.min(0.12, 0.04 + chainIndex * 0.0015);
  gain.gain.setValueAtTime(vol, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.18);
}

function playBonusTapSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(880, now);
  osc.frequency.exponentialRampToValueAtTime(1400, now + 0.15);
  gain.gain.setValueAtTime(0.18, now);
  gain.gain.linearRampToValueAtTime(0.18, now + 0.1);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.35);
}

function playPhantomSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(80, now);
  osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
  gain.gain.setValueAtTime(0.08, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.2);
}

function playRiftDamageSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Electric crackle — high square wave with rapid frequency jitter
  const osc1 = G.audioCtx.createOscillator();
  const gain1 = G.audioCtx.createGain();
  osc1.type = 'square';
  osc1.frequency.setValueAtTime(1200 + Math.random() * 800, now);
  osc1.frequency.exponentialRampToValueAtTime(300, now + 0.06);
  osc1.frequency.setValueAtTime(900 + Math.random() * 600, now + 0.065);
  osc1.frequency.exponentialRampToValueAtTime(200, now + 0.12);
  gain1.gain.setValueAtTime(0.06, now);
  gain1.gain.setValueAtTime(0.03, now + 0.04);
  gain1.gain.setValueAtTime(0.05, now + 0.065);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc1.connect(gain1);
  gain1.connect(G.audioCtx.destination);
  osc1.start(now);
  osc1.stop(now + 0.18);
  // Zap layer — higher sawtooth burst
  const osc2 = G.audioCtx.createOscillator();
  const gain2 = G.audioCtx.createGain();
  osc2.type = 'sawtooth';
  osc2.frequency.setValueAtTime(2400 + Math.random() * 1200, now);
  osc2.frequency.exponentialRampToValueAtTime(600, now + 0.08);
  gain2.gain.setValueAtTime(0.03, now);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
  osc2.connect(gain2);
  gain2.connect(G.audioCtx.destination);
  osc2.start(now);
  osc2.stop(now + 0.12);
}

function playSCPopSound(chainIndex) {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Deep boom — low sine sweep
  const osc1 = G.audioCtx.createOscillator();
  const gain1 = G.audioCtx.createGain();
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(60, now);
  osc1.frequency.exponentialRampToValueAtTime(25, now + 0.3);
  gain1.gain.setValueAtTime(0.2, now);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
  osc1.connect(gain1);
  gain1.connect(G.audioCtx.destination);
  osc1.start(now);
  osc1.stop(now + 0.4);
  // Crunch layer — square wave burst
  const osc2 = G.audioCtx.createOscillator();
  const gain2 = G.audioCtx.createGain();
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(90, now);
  osc2.frequency.exponentialRampToValueAtTime(30, now + 0.15);
  gain2.gain.setValueAtTime(0.06, now);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc2.connect(gain2);
  gain2.connect(G.audioCtx.destination);
  osc2.start(now);
  osc2.stop(now + 0.25);
}

function playVoidCrackSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Eerie crack — descending sine with pitch wobble
  const osc1 = G.audioCtx.createOscillator();
  const gain1 = G.audioCtx.createGain();
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(400, now);
  osc1.frequency.exponentialRampToValueAtTime(80, now + 0.4);
  gain1.gain.setValueAtTime(0.15, now);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  osc1.connect(gain1);
  gain1.connect(G.audioCtx.destination);
  osc1.start(now);
  osc1.stop(now + 0.55);
  // Sub rumble
  const osc2 = G.audioCtx.createOscillator();
  const gain2 = G.audioCtx.createGain();
  osc2.type = 'triangle';
  osc2.frequency.setValueAtTime(50, now);
  osc2.frequency.exponentialRampToValueAtTime(30, now + 0.3);
  gain2.gain.setValueAtTime(0.12, now);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  osc2.connect(gain2);
  gain2.connect(G.audioCtx.destination);
  osc2.start(now);
  osc2.stop(now + 0.45);
}

function playAbyssWooshSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Sub-bass whoosh — deep rumble sweep
  const sub = G.audioCtx.createOscillator();
  const subGain = G.audioCtx.createGain();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(35, now);
  sub.frequency.exponentialRampToValueAtTime(20, now + 1.2);
  subGain.gain.setValueAtTime(0.001, now);
  subGain.gain.linearRampToValueAtTime(0.15, now + 0.3);
  subGain.gain.linearRampToValueAtTime(0.12, now + 0.8);
  subGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
  sub.connect(subGain);
  subGain.connect(G.audioCtx.destination);
  sub.start(now);
  sub.stop(now + 1.6);
  // Triangle wave sweep — whooshing mid layer
  const tri = G.audioCtx.createOscillator();
  const triGain = G.audioCtx.createGain();
  tri.type = 'triangle';
  tri.frequency.setValueAtTime(120, now);
  tri.frequency.exponentialRampToValueAtTime(50, now + 1.0);
  triGain.gain.setValueAtTime(0.001, now);
  triGain.gain.linearRampToValueAtTime(0.06, now + 0.2);
  triGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
  tri.connect(triGain);
  triGain.connect(G.audioCtx.destination);
  tri.start(now);
  tri.stop(now + 1.3);
}

function playDelayedBlastBuildup(tier, duration) {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Rising sweep — sawtooth from low to high over the buildup duration
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sawtooth';
  const startFreq = tier === 3 ? 80 : tier === 2 ? 120 : 180;
  const endFreq = tier === 3 ? 900 : tier === 2 ? 700 : 500;
  osc.frequency.setValueAtTime(startFreq, now);
  osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration * 0.9);
  const vol = tier === 3 ? 0.10 : tier === 2 ? 0.07 : 0.05;
  gain.gain.setValueAtTime(0.01, now);
  gain.gain.linearRampToValueAtTime(vol, now + duration * 0.8);
  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + duration + 0.05);
  // Sub-bass rumble
  const sub = G.audioCtx.createOscillator();
  const subGain = G.audioCtx.createGain();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(40, now);
  subGain.gain.setValueAtTime(0.08, now);
  subGain.gain.linearRampToValueAtTime(0.15, now + duration * 0.8);
  subGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
  sub.connect(subGain);
  subGain.connect(G.audioCtx.destination);
  sub.start(now);
  sub.stop(now + duration + 0.05);
}

function playDelayedBlastExplosion(tier) {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Bass drop
  const bass = G.audioCtx.createOscillator();
  const bassGain = G.audioCtx.createGain();
  bass.type = 'sine';
  bass.frequency.setValueAtTime(tier === 3 ? 200 : 150, now);
  bass.frequency.exponentialRampToValueAtTime(20, now + 0.4);
  const bv = tier === 3 ? 0.25 : tier === 2 ? 0.18 : 0.12;
  bassGain.gain.setValueAtTime(bv, now);
  bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  bass.connect(bassGain);
  bassGain.connect(G.audioCtx.destination);
  bass.start(now);
  bass.stop(now + 0.55);
  // White noise burst
  const bufferSize = G.audioCtx.sampleRate * 0.3;
  const noiseBuffer = G.audioCtx.createBuffer(1, bufferSize, G.audioCtx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
  const noise = G.audioCtx.createBufferSource();
  noise.buffer = noiseBuffer;
  const noiseGain = G.audioCtx.createGain();
  const nv = tier === 3 ? 0.12 : tier === 2 ? 0.08 : 0.05;
  noiseGain.gain.setValueAtTime(nv, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
  noise.connect(noiseGain);
  noiseGain.connect(G.audioCtx.destination);
  noise.start(now);
  noise.stop(now + 0.3);
  // High ring
  if (tier >= 2) {
    const ring = G.audioCtx.createOscillator();
    const ringGain = G.audioCtx.createGain();
    ring.type = 'sine';
    ring.frequency.setValueAtTime(2000, now);
    ring.frequency.exponentialRampToValueAtTime(600, now + 0.4);
    ringGain.gain.setValueAtTime(0.06, now);
    ringGain.gain.exponentialRampToValueAtTime(0.001, now + 0.45);
    ring.connect(ringGain);
    ringGain.connect(G.audioCtx.destination);
    ring.start(now);
    ring.stop(now + 0.5);
  }
}

// ==================================================
// BPGE AMBIENT SOUND — breathing whoosh tied to gravity
// ==================================================
// Continuous synthesized wind/breathing that intensifies with World Transparency.
// Silent at WT 0-40%, fades in from WT40% to full at WT100%.
// Uses filtered noise + sub drone, modulated by slow LFO for organic breathing rhythm.

function initBPGEAmbient() {
  if (!G.audioCtx || G.bpgeAmbient) return;
  const ctx = G.audioCtx;

  // --- Noise source: looped white noise buffer ---
  const bufLen = ctx.sampleRate * 2; // 2 seconds, looped
  const noiseBuf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) nd[i] = Math.random() * 2 - 1;
  const noise = ctx.createBufferSource();
  noise.buffer = noiseBuf;
  noise.loop = true;

  // Bandpass filter — shapes noise into airy whoosh
  const bpFilter = ctx.createBiquadFilter();
  bpFilter.type = 'bandpass';
  bpFilter.frequency.value = 200;
  bpFilter.Q.value = 2.5;

  // Noise gain
  const noiseGain = ctx.createGain();
  noiseGain.gain.value = 0;

  noise.connect(bpFilter);
  bpFilter.connect(noiseGain);

  // --- Sub drone: deep sine for presence ---
  const sub = ctx.createOscillator();
  sub.type = 'sine';
  sub.frequency.value = 32;
  const subGain = ctx.createGain();
  subGain.gain.value = 0;
  sub.connect(subGain);

  // --- Mid tone: triangle for body ---
  const mid = ctx.createOscillator();
  mid.type = 'triangle';
  mid.frequency.value = 65;
  const midGain = ctx.createGain();
  midGain.gain.value = 0;
  mid.connect(midGain);

  // --- Master gain (overall volume control) ---
  const masterGain = ctx.createGain();
  masterGain.gain.value = 0;
  noiseGain.connect(masterGain);
  subGain.connect(masterGain);
  midGain.connect(masterGain);
  masterGain.connect(ctx.destination);

  // --- LFO: slow breathing rhythm modulating master volume ---
  const lfo = ctx.createOscillator();
  lfo.type = 'sine';
  lfo.frequency.value = 0.15; // very slow breathing
  const lfoGain = ctx.createGain();
  lfoGain.gain.value = 0; // depth controlled by update
  lfo.connect(lfoGain);
  lfoGain.connect(masterGain.gain); // modulates the gain AudioParam

  // Start all continuous sources
  const now = ctx.currentTime;
  noise.start(now);
  sub.start(now);
  mid.start(now);
  lfo.start(now);

  G.bpgeAmbient = {
    noise, bpFilter, noiseGain,
    sub, subGain,
    mid, midGain,
    masterGain,
    lfo, lfoGain
  };
}

function updateBPGEAmbient() {
  if (!G.audioCtx) return;
  if (!G.bpgeAmbient) {
    initBPGEAmbient();
    if (!G.bpgeAmbient) return;
  }

  const a = G.bpgeAmbient;
  const madness = getMadnessAmount();
  const now = G.audioCtx.currentTime;

  // Intensity: 0 at WT<=40%, linear ramp to 1 at WT100%
  const intensity = Math.max(0, (madness - 0.4) / 0.6);

  // Smooth ramp (avoid clicks)
  const rampTime = 0.15;

  // Master volume: gentle at low intensity, fuller at high
  // Quadratic curve for gradual onset
  const vol = intensity * intensity * 0.14;
  a.masterGain.gain.setTargetAtTime(vol, now, rampTime);

  // LFO depth: breathing becomes more pronounced with madness
  // At low intensity: subtle. At high: dramatic swells.
  const lfoDepth = intensity * 0.06;
  a.lfoGain.gain.setTargetAtTime(lfoDepth, now, rampTime);

  // LFO speed: breathing quickens with madness (0.12 Hz → 0.38 Hz)
  const lfoFreq = 0.12 + intensity * 0.26;
  a.lfo.frequency.setTargetAtTime(lfoFreq, now, rampTime);

  // Noise layer: louder with intensity, filter sweeps higher
  a.noiseGain.gain.setTargetAtTime(0.5 + intensity * 0.5, now, rampTime);
  // Bandpass center: 150 Hz (low whoosh) → 500 Hz (sharper, more present)
  const bpFreq = 150 + intensity * 350;
  a.bpFilter.frequency.setTargetAtTime(bpFreq, now, rampTime);
  // Q narrows at higher intensity for more focused sound
  a.bpFilter.Q.setTargetAtTime(2.0 + intensity * 3.0, now, rampTime);

  // Sub drone: fades in gently
  a.subGain.gain.setTargetAtTime(0.3 + intensity * 0.7, now, rampTime);
  // Sub pitch drops slightly at high madness for weight
  a.sub.frequency.setTargetAtTime(32 - intensity * 8, now, rampTime);

  // Mid tone: present in mid-to-high range
  a.midGain.gain.setTargetAtTime(intensity * 0.4, now, rampTime);
  // Mid frequency rises with intensity
  a.mid.frequency.setTargetAtTime(65 + intensity * 30, now, rampTime);
}

// ==================================================
// SECTION 6: UTILITIES
// ==================================================
function dist(x1, y1, x2, y2) {
  const dx = x1 - x2, dy = y1 - y2;
  return Math.sqrt(dx*dx + dy*dy);
}

function lerp(a, b, t) { return a + (b - a) * t; }

function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  const r = Math.round(lerp(r1,r2,t)), g = Math.round(lerp(g1,g2,t)), b = Math.round(lerp(b1,b2,t));
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}

// ==================================================
// MADNESS SYSTEM — unified 0% to 100% scale
// ==================================================
// 0% = initial state, colorful, normal orbs, clean UI
// 100% = full horror: eyes everywhere, Enochian UI, desaturated palette
// Driven by score progression + black hole exposure (horrorBoost)
//
// Score contribution:  0 at <100k, ramps 0→0.5 at 100k→500k, 0.5→1.0 at 500k→900k
// Black holes add permanent horrorBoost (capped at 0.6)
// Total capped at 1.0
let devMadnessOverride = -1; // -1 = off, 0-1 = forced value
let autoLevelUp = false; // Auto-select random upgrade on level up
let infiniteTaps = false; // Dev toggle: infinite taps (no game over)

function getMadnessAmount() {
  if (devMadnessOverride >= 0) return devMadnessOverride;
  let base = 0;
  if (G.score >= 10000 && G.score < 200000) base = (G.score - 10000) / 190000 * 0.5;
  else if (G.score >= 200000) base = 0.5 + Math.min(0.5, (G.score - 200000) / 200000);
  return Math.min(1, base + G.horrorBoost);
}

// Alias for backward compatibility — horror and madness are the same value
function getHorrorAmount() {
  return getMadnessAmount();
}

// Horror desaturation — colors drain toward grey, then tint with sickly flesh/bile
// "The Watchers drink from every wound" — color is life force being consumed
function horrorShift(hex, amount) {
  if (amount <= 0) return hex;
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  const lum = Math.round(r * 0.299 + g * 0.587 + b * 0.114);

  // Phase 1 (0→0.50): Gradual desaturation — gentle pull toward greyscale
  const desatStr = Math.min(amount, 0.50) / 0.50; // 0→1 over 0-50% (slower ramp)
  r = Math.round(lerp(r, lum, desatStr * 0.65));   // gentler pull
  g = Math.round(lerp(g, lum, desatStr * 0.65));
  b = Math.round(lerp(b, lum, desatStr * 0.65));

  // Phase 2 (0.30→0.65): Flesh/bile tint — sickly warmth creeps in
  if (amount > 0.30) {
    const fleshStr = Math.min(1, (amount - 0.30) / 0.35); // 0→1 over 30-65%
    r = Math.round(lerp(r, Math.min(255, r + 25), fleshStr * 0.4));
    g = Math.round(lerp(g, Math.min(255, g + 8), fleshStr * 0.25));
    b = Math.round(lerp(b, Math.max(0, b - 15), fleshStr * 0.35));
  }

  // Phase 3 (0.60→0.88): Deep drain — colors collapse toward muted flesh void
  if (amount > 0.60) {
    const drainStr = Math.min(1, (amount - 0.60) / 0.28); // 0→1 over 60-88%
    r = Math.round(lerp(r, 130, drainStr * 0.45));
    g = Math.round(lerp(g, 105, drainStr * 0.45));
    b = Math.round(lerp(b, 85, drainStr * 0.45));
    const dimFactor = 1 - drainStr * 0.18;
    r = Math.round(r * dimFactor);
    g = Math.round(g * dimFactor);
    b = Math.round(b * dimFactor);
  }

  // Phase 4 (0.88→1.0): TOTAL desaturation — all color dies, grey ash remains
  if (amount > 0.88) {
    const totalStr = (amount - 0.88) / 0.12; // 0→1 over 88-100%
    const ashLum = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
    // Converge to a dead grey-brown ash: rgb(75, 65, 58)
    const ashR = Math.round(lerp(ashLum, 75, 0.6));
    const ashG = Math.round(lerp(ashLum, 65, 0.6));
    const ashB = Math.round(lerp(ashLum, 58, 0.6));
    r = Math.round(lerp(r, ashR, totalStr));
    g = Math.round(lerp(g, ashG, totalStr));
    b = Math.round(lerp(b, ashB, totalStr));
    // Final dimming — everything fades toward near-black
    const finalDim = 1 - totalStr * 0.4;
    r = Math.round(r * finalDim);
    g = Math.round(g * finalDim);
    b = Math.round(b * finalDim);
  }

  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}

// Abyss saturation — INVERSE of horror desaturation
// At low madness: everything is monochrome B&W (sat=0)
// At high madness: vivid bioluminescent colors bloom (sat=1)
function getAbyssSaturation() {
  const m = getMadnessAmount();
  // 0-10% madness: pitch black nothing, fully desaturated
  // 10-70% madness: gradual color bloom
  // 70-100%: fully vivid
  if (m < 0.10) return 0;
  if (m > 0.70) return 1;
  return (m - 0.10) / 0.60;
}

// Desaturate a hex color toward greyscale. sat=0 → B&W, sat=1 → original color
function abyssDesaturate(hex, sat) {
  if (sat >= 1) return hex;
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  const lum = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
  // At sat=0: greyscale with slight cool tint for underwater feel
  const dimLum = Math.round(lum * 0.4);
  // Slight blue tint even when desaturated (underwater)
  const bTint = Math.min(255, dimLum + 8);
  r = Math.round(lerp(Math.max(0, dimLum - 3), r, sat));
  g = Math.round(lerp(dimLum, g, sat));
  b = Math.round(lerp(bTint, b, sat));
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}

// Get an Abyss orb color — blends from high-contrast B&W to vivid extended palette
function getAbyssOrbColor(x, y) {
  const p = getCurrentPalette();
  const sat = getAbyssSaturation();
  const vivid = p.vividColors || p.colors;
  const t = Math.max(0, Math.min(1, x / G.W));

  let color;
  if (sat < 0.5) {
    // Low saturation: use wider-contrast desaturated gradient
    // Instead of 3 similar colors, use a 5-stop greyscale gradient for more variety
    // Luminances: bright → mid → dark → mid-bright → darker
    const greyStops = ['#e0e8f0', '#607888', '#202830', '#90a8b8', '#384048'];
    const gIdx = t * (greyStops.length - 1);
    const gi = Math.floor(gIdx);
    const gf = gIdx - gi;
    const greyColor = gi >= greyStops.length - 1 ? greyStops[greyStops.length - 1] :
      lerpColor(greyStops[gi], greyStops[gi + 1], gf);
    // Blend toward base palette colors as saturation rises
    let baseColor;
    if (t < 0.5) baseColor = lerpColor(p.colors[0], p.colors[1], t * 2);
    else baseColor = lerpColor(p.colors[1], p.colors[2], (t - 0.5) * 2);
    const desatBase = abyssDesaturate(baseColor, sat);
    // At sat=0: use the high-contrast grey stops. At sat=0.5: transition to desaturated palette
    color = lerpColor(greyColor, desatBase, sat * 2);
  } else {
    // High saturation: blend toward extended vivid palette — go CRAZY with colors
    const vividT = (sat - 0.5) * 2; // 0→1 over 50-100% saturation
    // Base 3-color version
    let baseColor;
    if (t < 0.5) baseColor = lerpColor(p.colors[0], p.colors[1], t * 2);
    else baseColor = lerpColor(p.colors[1], p.colors[2], (t - 0.5) * 2);
    // Extended vivid: pick from 7-color gradient with time-based cycling for extra variety
    const timeShift = Math.sin(G.time * 0.03) * 0.15; // slow color cycling
    const shiftedT = ((t + timeShift) % 1 + 1) % 1; // wrap to 0-1
    const vIdx = shiftedT * (vivid.length - 1);
    const vi = Math.floor(vIdx);
    const vf = vIdx - vi;
    const vColor = vi >= vivid.length - 1 ? vivid[vivid.length - 1] :
      lerpColor(vivid[vi], vivid[vi + 1], vf);
    // Strong blend toward extended vivid at high sat
    color = lerpColor(baseColor, vColor, vividT * 0.8); // 80% blend at max (was 60%)
  }
  return color;
}

// Unified color shift — uses abyssDesaturate in ABYSS, horrorShift in default biomes
// Call this instead of horrorShift for rendering elements that exist in both biomes
function biomeColorShift(hex, madnessAmount) {
  if (madnessAmount <= 0) return hex;
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (isAbyss) return abyssDesaturate(hex, getAbyssSaturation());
  return horrorShift(hex, madnessAmount);
}

// Brighten orb colors at WT <80% — counteracts early desaturation, keeps field vivid
function orbBrighten(hex, madness) {
  if (madness >= 0.80) return hex; // no boost above 80%
  // Boost: 20% at 0% WT, fading to 0% at 80% WT (was 33% — too washed-out)
  const boost = 0.20 * (1 - madness / 0.80);
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  const nr = Math.min(255, Math.round(r + (255 - r) * boost));
  const ng = Math.min(255, Math.round(g + (255 - g) * boost));
  const nb = Math.min(255, Math.round(b + (255 - b) * boost));
  return '#' + ((1<<24)|(nr<<16)|(ng<<8)|nb).toString(16).slice(1);
}

// Golden/fiery color shift for spell effects at WT >75%
// Gradually blends any color toward warm gold/fire tones
function fireShift(hex, madness) {
  if (madness <= 0.40) return hex;
  const t = Math.min(1, (madness - 0.40) / 0.60); // 0→1 from 40%→100% WT — gradual ramp
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  // Quadratic ease-in: barely tinted at 40-55%, golden by ~70%, intense fire by 100%
  const eased = t * t;
  const fireR = 255;
  const fireG = Math.round(160 - eased * 80); // 160→80 (gold→deep orange)
  const fireB = Math.round(48 - eased * 20);  // 48→28
  const blend = eased * 0.65; // max 65% shift — keeps some original hue character
  const nr = Math.round(r + (fireR - r) * blend);
  const ng = Math.round(g + (fireG - g) * blend);
  const nb = Math.round(b + (fireB - b) * blend);
  return '#' + ((1<<24)|(nr<<16)|(ng<<8)|nb).toString(16).slice(1);
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function getCurrentPalette() {
  if (G.biomeOverride >= 0 && G.biomeOverride < SPECIAL_BIOMES.length) {
    return SPECIAL_BIOMES[G.biomeOverride];
  }
  const idx = Math.min(Math.floor((G.level - 1) / PALETTE_LEVELS), PALETTES.length - 1);
  return PALETTES[idx];
}

// Compat shim — old code calls getCurrentBiome()
function getCurrentBiome() {
  const p = getCurrentPalette();
  return {
    bgTop: p.bgTop, bgBot: p.bgBot,
    orbColors: p.colors.map(c => [c, c]),
    particleType: 'spark',
    gridTint: 'rgba(0,0,0,0)',
    baseNote: p.baseNote,
    oscType: p.oscType
  };
}

// Color a circle based on its screen position (cluster gradient)
function getClusterColor(x, y) {
  // ABYSS: inverse saturation — B&W at low madness, vivid at high
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (isAbyss) return { color: getAbyssOrbColor(x, y), colorIdx: 0 };

  const p = getCurrentPalette();
  const t = Math.max(0, Math.min(1, x / G.W));
  const nc = p.colors.length;
  const segments = nc - 1;
  const scaled = t * segments;
  const idx = Math.min(segments - 1, Math.floor(scaled));
  const lt = scaled - idx;
  let color = lerpColor(p.colors[idx], p.colors[idx + 1], lt);
  // Horror desaturation at high scores
  const horror = getHorrorAmount();
  if (horror > 0) color = horrorShift(color, horror);
  // Return color + palette segment index (for bridge matching unaffected by horror shift)
  return { color, colorIdx: idx };
}

function getTargetCircleCount() {
  // Starts at 35, grows by ~1.5 per level, caps around 55
  const levelBonus = Math.min(20, Math.floor((G.level - 1) * 1.5));
  const baseCount = BASE_CIRCLE_COUNT + levelBonus;
  // Soften by zoom: at 2.0× → ~70% orbs, at 1.0 → 100%, at 0.5 → 100% (capped)
  const zoomFactor = Math.min(1, 0.3 + 0.7 / G.zoomLevel);
  // Madness orb flood: softer ramp — doubles by 80%, peaks at 2.5× at 100%
  // 0-10%: 1.0×, 10-80%: ramps 1.0× → 2.0× (+100%), 80-100%: 2.0× → 2.5×
  const madness = getMadnessAmount();
  const madnessOrbMult = madness <= 0.1 ? 1.0 :
    madness <= 0.8 ? 1.0 + (madness - 0.1) / 0.7 * 1.0 :
    2.0 + (madness - 0.8) * 2.5;
  // Density upgrade: 6% orb mass per level (scales with field size)
  const densityMult = 1.0 + G.upgrades.density * 0.06;
  // Level 6+ dampening at low-mid WT (screen too busy early on)
  let levelDampen = 1.0;
  if (G.level >= 6) {
    levelDampen = madness < 0.4 ? 0.75 + madness * 0.625 : 1.0; // 0.75× at 0% WT → 1.0× at 40%
  }
  // EXPANSE biome: WEIGHT mechanic — far fewer orbs (sparse desert)
  if (G.biomeOverride === 2) {
    levelDampen *= 0.45; // 45% of normal count
  }
  return Math.round(baseCount * zoomFactor * madnessOrbMult * densityMult * levelDampen);
}

// --- PROGRESSION SCALING HELPERS ---
// Level-scaled blast radius: sqrt curve — big jump early, diminishing later
// All physics scale with madness: radius grows up to +30% at full madness
function getMadnessPhysicsScale() {
  const m = getMadnessAmount();
  // 0-50%: 1.0 → 1.15 (gentle ramp)
  // 50-100%: 1.15 → 1.7 (aggressive ramp — +50% force, doubled ratio)
  if (m <= 0.5) return 1 + m * 0.3;
  return 1.15 + (m - 0.5) * 1.1; // 1.15 → 1.7 at full madness
}

function getBlastRadius() {
  const t = Math.min(1, (G.level - 1) / 20); // 0 at lvl1, 1 at lvl21 — very slow ramp (was /16)
  const growth = Math.pow(t, 0.65);           // slightly steeper than 0.6 — flatter early, catches up late
  const base = BASE_BLAST_RADIUS + (MAX_BLAST_RADIUS - BASE_BLAST_RADIUS) * growth;
  // Soften blast by zoom: at 2.0× → ~85%, at 1.0 → 100%, at 0.5 → 100%
  const zoomScale = Math.min(1, 0.3 + 0.7 / G.zoomLevel);
  // Madness amplifies all physics
  return base * zoomScale * getMadnessPhysicsScale();
}

// Level-scaled fracturing: no fractures at lvl1, ramps in GRADUALLY over 12+ levels
function getFractureCounts() {
  // Level 1-4: no fracturing (extended learning phase)
  // Level 5-6: gen0→1 only (1 fragment — gentle chains)
  // Level 7-9: gen0→1, gen1→1 (single chain depth, no branching)
  // Level 10-11: gen0→2, gen1→1 (branching begins)
  // Level 12-13: gen0→2, gen1→1, gen2→1 (full depth, lean)
  // Level 14-15: gen0→2, gen1→2, gen2→1 (full fracturing tree)
  // Level 16-17: gen0→2, gen1→2, gen2→1, gen3→1 (gen-4 tier)
  // Level 18+: gen0→2, gen1→2, gen2→1, gen3→1, gen4→1 (gen-5 "micro" tier)
  // [gen0, gen1, gen2, gen3, gen4] → how many children each generation spawns
  if (G.level <= 4) return [0, 0, 0, 0, 0];
  if (G.level <= 6) return [1, 0, 0, 0, 0];
  if (G.level <= 9) return [1, 1, 0, 0, 0];  // single fragments through lvl 9
  if (G.level <= 11) return [2, 1, 0, 0, 0]; // branching at lvl 10
  if (G.level <= 13) return [2, 1, 1, 0, 0];
  if (G.level <= 15) return [2, 2, 1, 0, 0];
  if (G.level <= 17) return [2, 2, 1, 1, 0]; // gen-4 at level 16+
  return [2, 2, 1, 1, 1]; // gen-5 "micro" at level 18+
}

// Level-scaled shrapnel: needs higher chain count early, loosens later
function getShrapnelThreshold() {
  if (G.level <= 2) return 6;   // need chain ≥ 6 early — rare at small blast
  if (G.level <= 4) return 4;
  if (G.level <= 6) return 3;
  return 2;
}

// Level-scaled bonus tap thresholds
function getBonusTapThresholds() {
  const lvl = G.level;
  if (lvl <= 2) return { big: 15, mid: 8,  small: 5, smallChance: 0.50 };  // tighter — need real chains for taps
  if (lvl <= 4) return { big: 25, mid: 15, small: 8, smallChance: 0.40 };
  if (lvl <= 6) return { big: 30, mid: 18, small: 10, smallChance: 0.35 };
  if (lvl <= 9) return { big: 40, mid: 25, small: 14, smallChance: 0.30 };
  return { big: 40, mid: 25, small: 14, smallChance: 0.35 };
}

// Level-scaled tap timer: tighter early, more generous later
function getTapTimerMax() {
  // Level 1: 10s, grows by 0.5s per level, caps at 14s
  return Math.min(14, TAP_TIMER_BASE + (G.level - 1) * 0.5);
}

// Cascade Burst: smaller orbs (gen-1, gen-2) spawn bonus micro-fragments
// during long chains. Rule: chainCount must exceed threshold based on generation.
// Thresholds raised so cascading builds gradually, not explosively.
function getCascadeBurstCount(generation) {
  if (generation === 1 && G.chainCount >= 22) return 1 + (G.chainCount >= 42 ? 1 : 0);
  if (generation === 2 && G.chainCount >= 33) return 1;
  if (generation === 3 && G.chainCount >= 42) return 1; // gen-3 can burst into gen-4
  if (generation === 4 && G.chainCount >= 52) return 1; // gen-4 can burst into gen-5
  return 0;
}

// ==================================================
// SECTION 7: CIRCLE (ORB) MANAGEMENT
// ==================================================
function createCircle(x, y) {
  const clr = getClusterColor(x, y);
  const color = clr.color;
  const colorIdx = clr.colorIdx;
  const isVolatile = Math.random() < (G.upgrades.volatileOrbs * 0.08);
  // At >50% madness: default orbs grow bigger. At >66%: extreme size variation (tiny + huge)
  const madSizeAmt = getMadnessAmount();
  let sizeVar = 4; // default random range added to base
  let sizeMin = 1.0; // multiplier for minimum size
  let sizeBase = 1.0; // multiplier for base radius — makes default orbs bigger
  if (madSizeAmt > 0.50) {
    // From 50-100%: base orb size gradually grows up to 2.2× (was 1.85×)
    const growFrac = Math.min(1, (madSizeAmt - 0.50) / 0.50);
    sizeBase = 1.0 + growFrac * 1.2; // 1.0× → 2.2× base radius
    sizeVar = 4 + growFrac * 16; // wider random range as madness grows
  }
  if (madSizeAmt > 0.66) {
    const madSizeFrac = Math.min(1, (madSizeAmt - 0.66) / 0.34); // 0-1 from 66% to 100% madness
    sizeVar = 18 + madSizeFrac * 24; // up to +42px random range (was +30)
    sizeMin = 1.0 - madSizeFrac * 0.7; // down to 0.3× base size for micro orbs
  }
  // At >85% WT: orbs gain 2x mass (doubled radius for ~15% of new orbs)
  let massMult = 1.0;
  if (madSizeAmt > 0.85) {
    const massFrac = Math.min(1, (madSizeAmt - 0.85) / 0.15); // 0→1 from 85%→100%
    // 15% chance scaling to 30% at full WT for a 2x mass (1.41x radius) orb
    if (Math.random() < 0.15 + massFrac * 0.15) {
      massMult = 1.41; // sqrt(2) ≈ 2x area/mass
    }
  }
  // EXPANSE biome: WEIGHT — ancient giant orbs, 2-3× larger
  if (G.biomeOverride === 2) {
    sizeBase *= 2.5;
    sizeVar *= 1.5;
  }
  const baseR = BASE_CIRCLE_RADIUS * sizeBase * sizeMin * massMult + Math.random() * sizeVar;
  let r = Math.max(3, baseR); // minimum 3px radius — allows micro orbs
  if (isVolatile) r *= 1.3;
  // Void Crack orbs: RARE special armored orbs from level 3+ (flat 3% chance)
  const armorChance = G.level >= 3 ? 0.03 : 0;
  const isArmored = !isVolatile && Math.random() < armorChance;
  return {
    id: G.nextCircleId++,
    x, y,
    radius: r,
    baseRadius: r,
    color: color,
    colorIdx: colorIdx,       // Phase 6: palette segment index (0-3) for bridge matching
    colorEdge: color,
    volatile: isVolatile,
    armored: isArmored,
    armorHP: isArmored ? 2 : 0,  // 2=fresh, 1=cracked, 0=normal
    superCell: false,
    spikeCount: 0,
    scFade: 0,
    scTimer: 0,
    scLifespan: 0,
    scCooldown: 3 + Math.random() * 8,
    scTethers: [],           // Phase 5: Archon tethers to nearby orbs
    popped: false,
    queued: false,
    pulsePhase: Math.random() * Math.PI * 2,
    vx: 0, vy: 0,
    driftAngle: Math.random() * Math.PI * 2,
    driftTimer: Math.random() * 3,
    generation: 0,
    shrapnel: false,
    fissionSpawn: false,
    shrapnelImmune: 0,
    tethered: false,     // true when tethered to Nexus boss (chain-immune)
    chainBornId: -1,     // chain generation that spawned this particle (-1 = not chain-born)
    spawnAnim: 1.0,
    fadeIn: 0,
    alive: true,
    trail: [], // position history for motion blur
    synthCooldown: 0, // cooldown timer for color synthesis
    mergeCount: 1,     // how many orbs merged into this one
    mergeCooldown: 0,  // cooldown between merges
    mergeTarget: null,  // ID of orb being merged into (null = not merging)
    mergeAnimProgress: 0, // 0→1 merge animation progress
    mergeGlow: 0       // glow flash on orb that absorbed another
  };
}

function findCircleById(id) {
  for (let i = 0; i < G.circles.length; i++) {
    if (G.circles[i].id === id) return G.circles[i];
  }
  return null;
}

function spawnInitialCircles() {
  G.circles = [];
  const count = getTargetCircleCount();
  const margin = 30;
  // Use zoom-aware boundaries for spawning (fall back to full screen if not yet computed)
  const sL = G.gameLeft || 0, sT = G.gameTop || 0;
  const sW = G.gameW || G.W, sH = G.gameH || G.H;
  for (let i = 0; i < count; i++) {
    let x, y, valid, attempts = 0;
    do {
      x = sL + margin + Math.random() * (sW - margin * 2);
      y = sT + margin + Math.random() * (sH - margin * 2);
      valid = true;
      for (let j = 0; j < G.circles.length; j++) {
        if (dist(x, y, G.circles[j].x, G.circles[j].y) < 30) { valid = false; break; }
      }
      attempts++;
    } while (!valid && attempts < 30);
    const c = createCircle(x, y);
    c.spawnAnim = 0;
    G.circles.push(c);
  }
}

function spawnCircleFromEdge() {
  if (G.circles.length >= MAX_CIRCLES) return;

  // ~40% chance: spawn from darkness (fade-in at random position within play area)
  if (Math.random() < 0.40) {
    spawnCircleFadeIn();
    return;
  }

  // Directional bias: 50% chance to spawn from opposite side of recent pops
  let edge;
  const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
  const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
  if (Math.random() < 0.5 && G.popTrackCount > 5) {
    const pdx = G.popCenterX - gcx;
    const pdy = G.popCenterY - gcy;
    if (Math.abs(pdx) > Math.abs(pdy)) {
      edge = pdx > 0 ? 0 : 1; // pops on right → spawn from left, vice versa
    } else {
      edge = pdy > 0 ? 2 : 3; // pops on bottom → spawn from top, vice versa
    }
  } else {
    edge = Math.floor(Math.random() * 4);
  }
  let x, y, vx = 0, vy = 0;
  const margin = 30;
  const speed = 40 + Math.random() * 30;
  const eL = G.gameLeft || 0, eT = G.gameTop || 0;
  const eR = G.gameRight || G.W, eB = G.gameBottom || G.H;
  switch(edge) {
    case 0: x = eL - margin; y = eT + margin + Math.random() * ((eB - eT) - margin*2); vx = speed; break;
    case 1: x = eR + margin; y = eT + margin + Math.random() * ((eB - eT) - margin*2); vx = -speed; break;
    case 2: y = eT - margin; x = eL + margin + Math.random() * ((eR - eL) - margin*2); vy = speed; break;
    case 3: y = eB + margin; x = eL + margin + Math.random() * ((eR - eL) - margin*2); vy = -speed; break;
  }
  const c = createCircle(x, y);
  c.vx = vx;
  c.vy = vy;
  c.spawnAnim = 1.0;
  G.circles.push(c);
}

// Fade-in spawn: orb materializes from darkness at a random screen position
function spawnCircleFadeIn() {
  if (G.circles.length >= MAX_CIRCLES) return;
  const margin = 50;
  const fL = G.gameLeft || 0, fT = G.gameTop || 0;
  const fW = G.gameW || G.W, fH = G.gameH || G.H;
  const x = fL + margin + Math.random() * (fW - margin * 2);
  const y = fT + margin + Math.random() * (fH - margin * 2);
  const c = createCircle(x, y);
  c.vx = 0;
  c.vy = 0;
  c.spawnAnim = 0; // no slide-in
  c.fadeIn = 1.0; // custom fade-in timer (1.0 → 0.0)
  c.radius = 0.1; // starts tiny, grows
  G.circles.push(c);
}

// Weighted orb value: default=1.0, smaller orbs count as less toward population cap
function getOrbValue(c) {
  const sizeRatio = c.radius / BASE_CIRCLE_RADIUS;
  if (sizeRatio >= 1.5) return 1.5; // big merged orbs
  if (sizeRatio >= 0.9) return 1.0; // normal orbs
  if (sizeRatio >= 0.5) return 0.5; // small
  if (sizeRatio >= 0.3) return 0.25; // smaller
  if (sizeRatio >= 0.2) return 0.15; // tiny
  if (sizeRatio >= 0.1) return 0.08; // micro
  return 0.05; // dust
}

function getWeightedOrbCount() {
  let total = 0;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    total += getOrbValue(c);
  }
  return total;
}

function refillCircles() {
  const target = getTargetCircleCount();
  const weightedAlive = getWeightedOrbCount();
  const needed = Math.round(target - weightedAlive);
  G.refillQueue = [];
  G.refillTimer = 0;
  for (let i = 0; i < needed; i++) {
    G.refillQueue.push(i * 0.05);
  }
}

function updateRefillQueue(dt) {
  if (G.refillQueue.length === 0) return;
  G.refillTimer += dt;
  while (G.refillQueue.length > 0 && G.refillTimer >= G.refillQueue[0]) {
    G.refillQueue.shift();
    spawnCircleFromEdge();
  }
}

// ==================================================
// MASS CONSERVATION — keep total orb area roughly constant
// ==================================================
// Checked every 0.5s to avoid per-frame cost.
// When merges reduce orb count but increase individual sizes,
// spawns small orbs to restore total area toward target.
let massCheckTimer = 0;
function updateMassConservation(dt) {
  massCheckTimer += dt;
  if (massCheckTimer < 0.5) return;
  massCheckTimer = 0;

  // Don't spawn during active chains — let the chain play out
  if (G.chainActive) return;

  const target = getTargetCircleCount();
  const baseArea = Math.PI * BASE_CIRCLE_RADIUS * BASE_CIRCLE_RADIUS;
  const targetMass = target * baseArea; // ideal total area

  // Measure current total area
  let currentMass = 0;
  let aliveCount = 0;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    currentMass += Math.PI * c.radius * c.radius;
    aliveCount++;
  }

  // If mass deficit > 1.5 base orbs worth, spawn small compensating orbs
  const deficit = targetMass - currentMass;
  if (deficit > baseArea * 1.5 && aliveCount < MAX_CIRCLES) {
    // Spawn a mix of small and micro orbs to fill the deficit
    const smallArea = Math.PI * (BASE_CIRCLE_RADIUS * 0.5) * (BASE_CIRCLE_RADIUS * 0.5);
    const toSpawn = Math.min(6, Math.floor(deficit / smallArea)); // cap 6 per tick
    for (let i = 0; i < toSpawn; i++) {
      G.refillQueue.push(G.refillTimer + i * 0.08);
    }
  }
}

function updateCircles(dt) {
  // Marble mode countdown
  if (G.marbleMode > 0) G.marbleMode = Math.max(0, G.marbleMode - dt);

  // Only remove dead circles when chain is NOT active
  if (!G.chainActive) {
    G.circles = G.circles.filter(c => c.alive);
  }

  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;

    // Shrapnel immunity countdown
    if (c.shrapnelImmune > 0) c.shrapnelImmune -= dt;

    // Spawn slide-in animation
    if (c.spawnAnim > 0) {
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      c.spawnAnim -= dt * 1.5;
      if (c.spawnAnim <= 0) {
        c.spawnAnim = 0;
        c.vx = 0;
        c.vy = 0;
      }
    }

    // Velocity-based movement for all orbs (shrapnel, fission, gravity-affected)
    // Light drag lets momentum persist for orbital mechanics
    if (c.spawnAnim <= 0 && (Math.abs(c.vx) > 0.5 || Math.abs(c.vy) > 0.5)) {
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      // Gentle drag — velocity persists long enough for orbits
      const drag = 1 - 1.2 * dt;
      c.vx *= drag;
      c.vy *= drag;
    }

    // Fade-in from darkness animation — grow from nothing
    if (c.fadeIn > 0) {
      c.fadeIn -= dt * 0.8; // ~1.25s to fully appear
      if (c.fadeIn <= 0) {
        c.fadeIn = 0;
        c.radius = c.baseRadius;
      } else {
        const t = 1 - c.fadeIn;
        c.radius = c.baseRadius * t * t; // accelerating growth
      }
    }

    // DARK PRISM: smooth gravity direction (-1 to 1, lerped in updateShadowBalls)
    const gravDir = G.gravityInvertFactor;

    // Gravitational swirl — orbital motion around field center + gentle attractors
    // Each orb feels a pull toward a slowly-shifting attractor point
    // but also gets a tangential push, creating swirling orbits
    const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
    const gw = G.gameW || G.W, gh = G.gameH || G.H;
    const attractX = gcx + Math.sin(G.time * 0.13) * gw * 0.2;
    const attractY = gcy + Math.cos(G.time * 0.11) * gh * 0.15;
    const adx = attractX - c.x;
    const ady = attractY - c.y;
    const aDist = Math.sqrt(adx * adx + ady * ady) + 1;
    // Gravitational pull (inverse distance, capped) — inverted during Dark Prism
    const gravStr = Math.min(35, 800 / aDist) * dt * gravDir;
    // Tangential component (perpendicular to radial) — creates orbiting
    const tangentX = -ady / aDist;
    const tangentY = adx / aDist;
    const tangentStr = Math.min(25, 500 / aDist) * dt;
    // Apply both radial pull and tangential swirl
    c.x += (adx / aDist) * gravStr + tangentX * tangentStr;
    c.y += (ady / aDist) * gravStr + tangentY * tangentStr;

    // MADNESS CENTER PULL — above 75% madness, orbs feel increasing gravity toward field center
    // "Reality collapses inward" — everything slowly drawn to the void's center
    // DARK PRISM: gravity inverts — orbs pushed outward from center
    const centerMadness = getMadnessAmount();
    if (centerMadness > 0.75) {
      const centerStr = (centerMadness - 0.75) / 0.25; // 0→1 from 75-100%
      const cdx = gcx - c.x, cdy = gcy - c.y;
      const cDist = Math.sqrt(cdx * cdx + cdy * cdy) + 1;
      // Gradual pull: reaches 60 force units at full madness, inverse-sqrt falloff
      const centerPull = centerStr * 60 * (1 / Math.sqrt(cDist / 50 + 1)) * dt * gravDir;
      c.x += (cdx / cDist) * centerPull;
      c.y += (cdy / cDist) * centerPull;
    }

    // Ambient wave overlay for organic feel
    c.x += Math.sin(G.time * 0.4 + c.pulsePhase) * 0.6 * dt * 10;
    c.y += Math.cos(G.time * 0.35 + c.pulsePhase * 1.3) * 0.6 * dt * 10;

    // Brownian nudges — change drift direction periodically
    c.driftTimer -= dt;
    if (c.driftTimer <= 0) {
      c.driftTimer = 1.5 + Math.random() * 2.5;
      c.driftAngle += (Math.random() - 0.5) * 2.0;
    }
    const driftSpeed = c.superCell ? 8 : 12;
    c.x += Math.cos(c.driftAngle) * driftSpeed * dt;
    c.y += Math.sin(c.driftAngle) * driftSpeed * dt;

    // Cursor gravity — pull toward mouse/touch, boosted by cursor movement speed
    // Uses 1/d falloff (not 1/d²) for smoother feel: less snap close, more pull far
    // Reach: 5× at 0% madness → 12× at 100% — very wide influence field
    if (G.cursorX > 0 && G.cursorY > 0) {
      const cdx = G.cursorX - c.x;
      const cdy = G.cursorY - c.y;
      const cDist = Math.sqrt(cdx * cdx + cdy * cdy) + 1;
      // Cursor speed boost: fast circular motion amplifies gravity (1.0× to 2.5×)
      const cursorSpeed = Math.sqrt(G.cursorVx * G.cursorVx + G.cursorVy * G.cursorVy);
      const speedBoost = 1 + Math.min(1.5, cursorSpeed / 400);
      const madPhys = getMadnessPhysicsScale();
      const madness = getMadnessAmount();
      // Cursor REACH: 5× at 0% madness → 9× at 100% madness (was 12× — too aggressive)
      const cursorReachMult = 5.0 + madness * 4.0;
      // Cursor STRENGTH: 1.0× base, up to 1.5× at full madness (was 2.0× — too snappy)
      const cursorStrMult = 1.0 + madness * 0.5;
      // Shrink effective distance to extend reach
      const effDist = cDist / cursorReachMult;
      // 1/d falloff with soft floor — smooth gradient, no harsh snap nearby
      // Close orbs (effDist ~5-20): gentle tug, not a snap
      // Mid-range (effDist ~50-150): noticeable drift toward cursor
      // Far orbs (effDist ~200+): still subtly drawn in
      const pullBase = 262 * speedBoost * madPhys * cursorStrMult;
      const basePull = Math.min(20 * speedBoost * madPhys * cursorStrMult, pullBase / (effDist + 28)) * dt * gravDir;
      // Close-range bonus: extra pull when within 80px of cursor
      const closeBonus = cDist < 80 ? (1 - cDist / 80) * 8 * dt * gravDir * madPhys : 0;
      const cursorPull = basePull + closeBonus;
      c.x += (cdx / cDist) * cursorPull;
      c.y += (cdy / cDist) * cursorPull;

      // Cursor BRUSH: moving cursor pushes nearby orbs in cursor direction
      // Brush range also scales with madness reach
      const brushRange = (60 + c.radius) * cursorReachMult * 0.5;
      if (cursorSpeed > 30 && cDist < brushRange) {
        const brushStr = Math.min(1, cursorSpeed / 800) * (1 - cDist / brushRange);
        const brushForce = brushStr * 45 * cursorStrMult * dt;
        c.vx += (G.cursorVx / cursorSpeed) * brushForce;
        c.vy += (G.cursorVy / cursorSpeed) * brushForce;
      }
    }

    // Record trail for motion blur (only at very high speed, short trail)
    const speed = Math.sqrt(c.vx * c.vx + c.vy * c.vy);
    if (speed > 150 && c.trail) {
      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 5) c.trail.shift();
    } else if (c.trail && c.trail.length > 0) {
      c.trail.shift(); // fade out trail when slow
    }

    // Keep on screen — shrapnel/fission wrap around, normal orbs soft-bounce
    // Use zoom-aware game boundaries
    const pad = c.radius + 5;
    const bL = G.gameLeft || 0, bT = G.gameTop || 0;
    const bR = G.gameRight || G.W, bB = G.gameBottom || G.H;
    if (c.spawnAnim <= 0) {
      const speed = Math.sqrt(c.vx * c.vx + c.vy * c.vy);
      if ((c.shrapnel || c.generation > 0) && speed > 50) {
        // Screen wrap — appear from opposite edge
        if (c.x < bL - pad) c.x = bR + pad - 1;
        else if (c.x > bR + pad) c.x = bL - pad + 1;
        if (c.y < bT - pad) c.y = bB + pad - 1;
        else if (c.y > bB + pad) c.y = bT - pad + 1;
      } else {
        if (c.x < bL + pad) { c.x = bL + pad; c.driftAngle = Math.PI - c.driftAngle; if (c.vx < 0) c.vx *= -0.5; }
        if (c.x > bR - pad) { c.x = bR - pad; c.driftAngle = Math.PI - c.driftAngle; if (c.vx > 0) c.vx *= -0.5; }
        if (c.y < bT + pad) { c.y = bT + pad; c.driftAngle = -c.driftAngle; if (c.vy < 0) c.vy *= -0.5; }
        if (c.y > bB - pad) { c.y = bB - pad; c.driftAngle = -c.driftAngle; if (c.vy > 0) c.vy *= -0.5; }
      }
    }

    // Colors are now persistent — set at creation, not updated per frame
    // Orbs keep the color they spawned with as they drift

    // Pulse phase
    c.pulsePhase += dt * (c.superCell ? 3 : 2);

    // Merge glow decay (survivor flash after absorbing another orb)
    if (c.mergeGlow > 0) c.mergeGlow = Math.max(0, c.mergeGlow - dt * 3);

    // Gradual color blend on survivor — smooth transition over 0.5s
    if (c._mergeColorFrom && c._mergeColorTo && c._mergeColorT < 1) {
      c._mergeColorT = Math.min(1, c._mergeColorT + dt * 2); // 0.5s blend
      const blendEase = c._mergeColorT * c._mergeColorT * (3 - 2 * c._mergeColorT); // smoothstep
      c.color = lerpColor(c._mergeColorFrom, c._mergeColorTo, blendEase);
      c.colorEdge = c.color;
      if (c._mergeColorT >= 1) {
        c._mergeColorFrom = null;
        c._mergeColorTo = null;
      }
    }

    // SC mutation lifecycle — only gen-0 circles can mutate
    if (!c.volatile && !c.queued && c.spawnAnim <= 0 && c.generation === 0) {
      if (c.superCell) {
        // Currently an SC — count down lifespan
        c.scTimer += dt;
        if (c.scTimer < 0.34) {
          // Fade in
          c.scFade = c.scTimer / 0.34;
          c.radius = c.baseRadius + (c.baseRadius * (SC_RADIUS_MULT - 1)) * c.scFade;
        } else if (c.scTimer > c.scLifespan - 0.42) {
          // Fade out
          c.scFade = Math.max(0, (c.scLifespan - c.scTimer) / 0.42);
          c.radius = c.baseRadius + (c.baseRadius * (SC_RADIUS_MULT - 1)) * c.scFade;
          if (c.scTimer >= c.scLifespan) {
            // Revert to normal — release all tethers
            c.superCell = false;
            c.spikeCount = 0;
            c.scFade = 0;
            c.radius = c.baseRadius;
            c.scCooldown = 4.25 + Math.random() * 10.2;
            if (c.scTethers) {
              for (let t = 0; t < c.scTethers.length; t++) {
                const orb = findCircleById(c.scTethers[t].orbId);
                if (orb) orb.tethered = false;
              }
              c.scTethers = [];
            }
            c.scSigilTethers = [];
          }
        } else {
          c.scFade = 1;
          c.radius = c.baseRadius * SC_RADIUS_MULT;
        }
        // Phase 5: Maintain Archon tethers — prune dead, update pulse
        if (c.scTethers && c.scTethers.length > 0) {
          for (let t = c.scTethers.length - 1; t >= 0; t--) {
            const orb = findCircleById(c.scTethers[t].orbId);
            if (!orb || !orb.alive || orb.popped) {
              c.scTethers.splice(t, 1);
            } else {
              c.scTethers[t].pulsePhase += dt * 3.5;
              // Tethered orbs pulse in sync with Archon
              orb.pulsePhase = c.pulsePhase;
            }
          }
        }
      } else {
        // Normal cell — count cooldown, maybe mutate
        c.scCooldown -= dt;
        if (c.scCooldown <= 0) {
          if (G.level >= 5 && Math.random() < SC_SPAWN_CHANCE) {
            c.superCell = true;
            c.spikeCount = SC_SPIKE_MIN + Math.floor(Math.random() * (SC_SPIKE_MAX - SC_SPIKE_MIN + 1));
            c.scTimer = 0;
            c.scLifespan = 2.1 + Math.random() * 3.4;
            c.scFade = 0;
            // Trigger marble mode — orbs become bouncy solids (8s base, stacks up to 3x = 24s max)
            const MARBLE_BASE = 8.0;
            const MARBLE_MAX = MARBLE_BASE * 3;
            G.marbleMode = Math.min(MARBLE_MAX, G.marbleMode + MARBLE_BASE);
            // Phase 5: Form tethers to 4-7 nearby orbs (was 2-4)
            c.scTethers = [];
            c.scSigilTethers = []; // extra tethers to sigils (bombs)
            const tetherCount = 4 + Math.floor(Math.random() * 4); // 4-7
            const tetherRange = 260 + c.radius * 2; // wider reach (was 180)
            const candidates = [];
            for (let j = 0; j < G.circles.length; j++) {
              const o = G.circles[j];
              if (o.id === c.id || !o.alive || o.popped || o.queued || o.superCell || o.tethered) continue;
              const td = dist(c.x, c.y, o.x, o.y);
              if (td < tetherRange && td > c.radius * 1.5) {
                candidates.push({ orb: o, dist: td });
              }
            }
            candidates.sort((a, b) => a.dist - b.dist);
            for (let j = 0; j < Math.min(tetherCount, candidates.length); j++) {
              const o = candidates[j].orb;
              o.tethered = true;
              c.scTethers.push({ orbId: o.id, pulsePhase: Math.random() * Math.PI * 2 });
            }
            // Archon seeks sigils (bombs) — forms extra Enochian-style tethers
            const sigilRange = 350;
            for (let j = 0; j < G.bombs.length; j++) {
              const bomb = G.bombs[j];
              const bd = dist(c.x, c.y, bomb.x, bomb.y);
              if (bd < sigilRange) {
                c.scSigilTethers.push({ bombIdx: j, pulsePhase: Math.random() * Math.PI * 2, glyphSeed: Math.random() * 100 });
              }
            }
          }
          c.scCooldown = 3.4 + Math.random() * 8.5;
        }
      }
    }
  }
}

// ==================================================
// SECTION 7b: COLOR SYNTHESIS — orbs blending on contact
// ==================================================
// When orbs of different colors overlap, they exchange color,
// producing a brief visual spark and blending toward each other.
// Synthesis creates emergent color evolution across the field.

function colorDistance(hex1, hex2) {
  const r1 = parseInt(hex1.slice(1,3),16), g1 = parseInt(hex1.slice(3,5),16), b1 = parseInt(hex1.slice(5,7),16);
  const r2 = parseInt(hex2.slice(1,3),16), g2 = parseInt(hex2.slice(3,5),16), b2 = parseInt(hex2.slice(5,7),16);
  return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
}

function updateColorSynthesis(dt) {
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Decrement cooldowns
  for (let i = 0; i < len; i++) {
    if (circles[i].synthCooldown > 0) circles[i].synthCooldown -= dt;
  }

  // Spatial grid for O(n) proximity — avoids O(n²) brute force
  const cellSize = 50; // roughly 2x max radius
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH);
  for (let i = 0; i < grid.length; i++) grid[i] = null;

  // Populate grid
  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped || c.spawnAnim > 0.5) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._gridNext = grid[idx];
    grid[idx] = i;
  }

  // Check neighboring cells
  let synthCount = 0;
  const maxSynthPerFrame = 5; // cap effects per frame for performance

  for (let i = 0; i < len && synthCount < maxSynthPerFrame; i++) {
    const a = circles[i];
    if (!a.alive || a.popped || a.synthCooldown > 0 || a.spawnAnim > 0.3) continue;

    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    // Check 3x3 neighborhood
    for (let dy = -1; dy <= 1 && synthCount < maxSynthPerFrame; dy++) {
      for (let dx = -1; dx <= 1 && synthCount < maxSynthPerFrame; dx++) {
        const nx = gx + dx;
        const ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        const idx = ny * gridW + nx;
        let j = grid[idx];
        while (j !== null && synthCount < maxSynthPerFrame) {
          const b = circles[j];
          const nextJ = b._gridNext;

          if (j > i && b.alive && !b.popped && b.synthCooldown <= 0 && b.spawnAnim <= 0.3) {
            // Distance check
            const ddx = a.x - b.x;
            const ddy = a.y - b.y;
            const dist = Math.sqrt(ddx * ddx + ddy * ddy);
            const touchDist = a.radius + b.radius;

            if (dist < touchDist * 0.85) {
              // Check color difference — only synthesize if colors are sufficiently different
              const cDiff = colorDistance(a.color, b.color);
              if (cDiff > 80) {
                // === SYNTHESIS! ===
                // Blend both colors toward each other (asymmetric — smaller orb shifts more)
                const aSize = a.radius * a.radius; // area-based weight
                const bSize = b.radius * b.radius;
                const total = aSize + bSize;
                const blendA = 0.08 * (bSize / total); // how much A shifts toward B
                const blendB = 0.08 * (aSize / total); // how much B shifts toward A

                a.color = lerpColor(a.color, b.color, blendA);
                a.colorEdge = a.color;
                b.color = lerpColor(b.color, a.color, blendB);
                b.colorEdge = b.color;

                // Cooldown prevents rapid-fire synthesis
                a.synthCooldown = 0.4 + Math.random() * 0.2;
                b.synthCooldown = 0.4 + Math.random() * 0.2;

                // Slight velocity kick — gentle push apart
                const pushStr = 15;
                const nx2 = dist > 0.5 ? ddx / dist : (Math.random() - 0.5);
                const ny2 = dist > 0.5 ? ddy / dist : (Math.random() - 0.5);
                a.vx += nx2 * pushStr;
                a.vy += ny2 * pushStr;
                b.vx -= nx2 * pushStr;
                b.vy -= ny2 * pushStr;

                // Visual effect: synthesis spark
                const mx = (a.x + b.x) * 0.5;
                const my = (a.y + b.y) * 0.5;
                const blendedColor = lerpColor(a.color, b.color, 0.5);

                // Emit tiny sparks at contact point
                for (let s = 0; s < 4; s++) {
                  const angle = Math.random() * Math.PI * 2;
                  const speed = 30 + Math.random() * 50;
                  spawnParticle(mx, my, 'spark', blendedColor, {
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    maxLife: 0.25 + Math.random() * 0.2,
                    size: 1.5 + Math.random() * 2
                  });
                }

                // Soft glow ring at contact
                spawnParticle(mx, my, 'ripple', blendedColor, {
                  maxLife: 0.4,
                  size: 0,
                  layer: 'bg'
                });

                synthCount++;
              }
            }
          }

          j = nextJ;
        }
      }
    }
  }

  // Clean up grid pointers
  for (let i = 0; i < len; i++) {
    circles[i]._gridNext = null;
  }
}

// ==================================================
// SECTION 7b2: MARBLE BOUNCE — elastic collisions during marble mode
// ==================================================
function updateMarbleBounce(dt) {
  if (G.marbleMode <= 0) return;
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Spatial hash for efficient collision detection
  const cellSize = 50;
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH).fill(null);

  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._bounceNext = grid[idx];
    grid[idx] = i;
  }

  const restitution = 0.85; // bounciness coefficient

  for (let i = 0; i < len; i++) {
    const a = circles[i];
    if (!a.alive || a.popped) continue;
    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = gx + dx, ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        let j = grid[ny * gridW + nx];
        while (j !== null) {
          const b = circles[j];
          const nextJ = b._bounceNext;
          if (j > i && b.alive && !b.popped) {
            const ddx = b.x - a.x;
            const ddy = b.y - a.y;
            const dist = Math.sqrt(ddx * ddx + ddy * ddy);
            const minDist = a.radius + b.radius;

            if (dist < minDist && dist > 0.1) {
              // Elastic collision — exchange velocity along contact normal
              const nx2 = ddx / dist;
              const ny2 = ddy / dist;

              // Relative velocity along normal
              const dvx = a.vx - b.vx;
              const dvy = a.vy - b.vy;
              const relVel = dvx * nx2 + dvy * ny2;

              // Only resolve if approaching
              if (relVel > 0) {
                // Mass proportional to radius squared
                const mA = a.radius * a.radius;
                const mB = b.radius * b.radius;
                const totalM = mA + mB;

                const impulse = relVel * restitution * 2 / totalM;

                a.vx -= impulse * mB * nx2;
                a.vy -= impulse * mB * ny2;
                b.vx += impulse * mA * nx2;
                b.vy += impulse * mA * ny2;

                // Separate overlapping orbs
                const overlap = minDist - dist;
                const sepA = overlap * (mB / totalM) * 0.5;
                const sepB = overlap * (mA / totalM) * 0.5;
                a.x -= nx2 * sepA;
                a.y -= ny2 * sepA;
                b.x += nx2 * sepB;
                b.y += ny2 * sepB;
              }
            }
          }
          j = nextJ;
        }
      }
    }
  }

  // Cleanup
  for (let i = 0; i < len; i++) {
    circles[i]._bounceNext = undefined;
  }
}

// ==================================================
// SECTION 7c: ORB MERGING — combo-bubbles from collisions
// ==================================================
function updateOrbMerging(dt) {
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Decrement merge cooldowns
  for (let i = 0; i < len; i++) {
    if (circles[i].mergeCooldown > 0) circles[i].mergeCooldown -= dt;
  }

  // Spatial hash grid (same approach as color synthesis)
  const cellSize = 50;
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH).fill(null);

  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped || c.spawnAnim > 0.5 || c.mergeCooldown > 0) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._mergeNext = grid[idx];
    grid[idx] = i;
  }

  let merges = 0;
  const maxMerges = 3; // performance cap per frame

  for (let i = 0; i < len && merges < maxMerges; i++) {
    const a = circles[i];
    if (!a.alive || a.popped || a.mergeCooldown > 0 || a.spawnAnim > 0.3) continue;
    // Merge count cap scales with madness: 6 base, up to 10 at full madness
    const mergeCap = 6 + Math.floor(getMadnessAmount() * 4);
    if (a.mergeCount >= mergeCap || a.superCell || a.armored) continue;

    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    for (let dy = -1; dy <= 1 && merges < maxMerges; dy++) {
      for (let dx = -1; dx <= 1 && merges < maxMerges; dx++) {
        const nx = gx + dx, ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        let j = grid[ny * gridW + nx];
        while (j !== null && merges < maxMerges) {
          const b = circles[j];
          const nextJ = b._mergeNext;
          if (j > i && b.alive && !b.popped && b.mergeCooldown <= 0
              && b.spawnAnim <= 0.3 && (b.mergeCount || 1) < mergeCap
              && !b.superCell && !b.armored) {
            const ddx = a.x - b.x;
            const ddy = a.y - b.y;
            const d = Math.sqrt(ddx * ddx + ddy * ddy);
            const touchDist = a.radius + b.radius;

            // Merge on overlap (85%) — physics-based: speed + mass determine merge chance
            if (d < touchDist * 0.85) {
              // Calculate relative impact speed
              const relVx = a.vx - b.vx;
              const relVy = a.vy - b.vy;
              const impactSpeed = Math.sqrt(relVx * relVx + relVy * relVy);
              // Mass ratio (area-based) — bigger ratio = easier merge
              const massA = a.radius * a.radius;
              const massB = b.radius * b.radius;
              const massRatio = Math.max(massA, massB) / Math.min(massA, massB);
              // Merge probability: higher base + speed boost + mass ratio boost
              const speedFactor = Math.min(1, impactSpeed / 120);
              const massFactor = Math.min(1, (massRatio - 1) / 3);
              const mergeChance = 0.12 + speedFactor * 0.45 + massFactor * 0.25;
              if (Math.random() < mergeChance) {
                // Area-based radius growth — cap scales with madness (3.5× base → 5× at full madness)
                const mergeRadiusCap = BASE_CIRCLE_RADIUS * (3.5 + getMadnessAmount() * 1.5);
                const newArea = Math.PI * a.radius * a.radius + Math.PI * b.radius * b.radius;
                a.radius = Math.min(mergeRadiusCap, Math.sqrt(newArea / Math.PI));
                a.baseRadius = a.radius;

                // Gradual color blend — store target color for smooth transition
                a._mergeColorFrom = a.color;
                a._mergeColorTo = lerpColor(a.color, b.color, 0.5);
                a._mergeColorT = 0;
                a.colorEdge = a.color;
                a.mergeCount = (a.mergeCount || 1) + (b.mergeCount || 1);

                // Average velocities
                a.vx = (a.vx + b.vx) * 0.5;
                a.vy = (a.vy + b.vy) * 0.5;
                a.mergeCooldown = 0.5;
                a.mergeGlow = 1.0; // survivor glows briefly

                // Start merge animation — store original color for gradual blend
                b._mergeOrigColor = b.color;
                b.mergeTarget = a.id;
                b.mergeAnimProgress = 0;
                b.queued = true; // prevent chain pops during merge anim

                // Visual ripple at merge point
                const mx = (a.x + b.x) * 0.5, my = (a.y + b.y) * 0.5;
                spawnParticle(mx, my, 'ripple', a.color, {
                  maxLife: 0.4, size: 0, layer: 'bg'
                });

                merges++;
              } else {
                // Push apart instead of merging
                a.mergeCooldown = 0.5;
                b.mergeCooldown = 0.5;
                if (d > 0.1) {
                  const pushStr = 30;
                  a.vx += (ddx / d) * pushStr;
                  a.vy += (ddy / d) * pushStr;
                  b.vx -= (ddx / d) * pushStr;
                  b.vy -= (ddy / d) * pushStr;
                }
              }
            }
          }
          j = nextJ;
        }
      }
    }
  }

  // Clean up grid pointers
  for (let i = 0; i < len; i++) {
    circles[i]._mergeNext = undefined;
  }
}

// ==================================================
// SECTION 7d: INTER-ORB GRAVITY — bigger orbs pull smaller orbs
// ==================================================
function updateInterOrbGravity(dt) {
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Spatial hash grid (same 50px cells as merging)
  const cellSize = 50;
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH).fill(null);

  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._gravNext = grid[idx];
    grid[idx] = i;
  }

  // Check neighbors — only pull from larger → smaller
  for (let i = 0; i < len; i++) {
    const a = circles[i];
    if (!a.alive || a.popped || a.queued) continue;
    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    // Larger cell size reach: check wider area for bigger orbs
    const reach = Math.ceil((a.radius * 4) / cellSize);
    const searchR = Math.min(reach, 3); // cap search radius

    for (let dy = -searchR; dy <= searchR; dy++) {
      for (let dx = -searchR; dx <= searchR; dx++) {
        const nx = gx + dx, ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        let j = grid[ny * gridW + nx];
        while (j !== null) {
          const b = circles[j];
          const nextJ = b._gravNext;
          if (j !== i && b.alive && !b.popped) {
            // Determine which is bigger
            let big, small;
            if (a.radius > b.radius * 1.2) { big = a; small = b; }
            else if (b.radius > a.radius * 1.2) { big = b; small = a; }
            else { j = nextJ; continue; } // too similar in size, skip

            const ddx = big.x - small.x;
            const ddy = big.y - small.y;
            const d = Math.sqrt(ddx * ddx + ddy * ddy);
            // Mid/big balls get 15% bigger gravity radius
            const sizeBonus = big.radius >= BASE_CIRCLE_RADIUS ? 1.15 : 1.0;
            const madPhys = getMadnessPhysicsScale();
            const range = big.radius * 4.5 * sizeBonus * madPhys;

            if (d < range && d > 5) {
              // Gravity strength — scaled by big orb's relative size + madness
              let str = INTER_ORB_GRAVITY * (big.radius / BASE_CIRCLE_RADIUS) * madPhys * dt / Math.max(d, 10);
              // Merged orbs pull harder
              if (big.mergeCount > 1) str *= 1.5;
              // Falloff near edge of range
              const falloff = 1 - (d / range);
              str *= falloff;

              small.vx += (ddx / d) * str;
              small.vy += (ddy / d) * str;
            }
          }
          j = nextJ;
        }
      }
    }
  }

  // Clean up
  for (let i = 0; i < len; i++) {
    circles[i]._gravNext = undefined;
  }
}

// ==================================================
// SECTION 7e: MERGE ANIMATIONS — absorbed orbs melt into survivors
// ==================================================
function updateMergeAnimations(dt) {
  for (let i = G.circles.length - 1; i >= 0; i--) {
    const c = G.circles[i];
    if (c.mergeTarget === null || c.mergeTarget === undefined) continue;

    c.mergeAnimProgress += dt / 0.7; // 0.7s smooth animation

    const target = findCircleById(c.mergeTarget);
    if (!target || !target.alive) {
      c.alive = false;
      c.popped = true;
      continue;
    }

    const t = Math.min(1, c.mergeAnimProgress);
    // Smooth ease-in-out: slow start, accelerate, slow arrival
    const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

    // Smooth position interpolation toward target
    c.x = lerp(c.x, target.x, ease * 0.18);
    c.y = lerp(c.y, target.y, ease * 0.18);

    // Smooth shrink — ease-out curve so it shrinks gently at first, faster at end
    const shrink = 1 - ease * ease;
    c.radius = Math.max(1, c.baseRadius * shrink);

    // Gradual color blend — absorbed orb shifts toward target color over time
    if (target.color && c._mergeOrigColor) {
      c.color = lerpColor(c._mergeOrigColor, target.color, ease);
    }

    // Stretch factor — smooth ramp
    c.mergeStretch = ease;

    // Emit mass-flow particles toward target (fewer, softer)
    if (Math.random() < 0.25) {
      const angle = Math.atan2(target.y - c.y, target.x - c.x);
      const spread = (Math.random() - 0.5) * 0.6;
      const speed = 40 + Math.random() * 60;
      const pColor = lerpColor(c.color, target.color, 0.3 + Math.random() * 0.4);
      spawnParticle(c.x, c.y, 'spark', pColor, {
        vx: Math.cos(angle + spread) * speed,
        vy: Math.sin(angle + spread) * speed,
        maxLife: 0.35, size: 1.5 + Math.random() * 2, layer: 'fg'
      });
    }

    // Animation complete
    if (t >= 1) {
      c.alive = false;
      c.popped = true;
    }
  }
}

// ==================================================
// SECTION 8: PARTICLE SYSTEM
// ==================================================
const particlePool = [];
for (let i = 0; i < MAX_PARTICLES; i++) {
  particlePool.push({ active: false, type: 'spark', x:0, y:0, vx:0, vy:0, life:0, maxLife:1, size:4, color:'#fff', alpha:1, rotation:0, rotSpeed:0, trail:null, radius:0, w:0, h:0, layer:'fg', gravity:false });
}

// Ambient mote spawner — fills screen with tiny drifting specks
let ambientTimer = 0;
function updateAmbientParticles(dt) {
  // Base rate: spawn ~15 motes/sec, during chain up to ~40/sec
  const baseRate = 15;
  const chainBoost = G.chainActive ? 25 + G.chainCount * 0.5 : 0;
  const rate = baseRate + chainBoost;
  ambientTimer += dt;
  const interval = 1 / rate;
  while (ambientTimer >= interval) {
    ambientTimer -= interval;
    const palette = getCurrentPalette();
    const color = palette.colors[Math.floor(Math.random() * palette.colors.length)];
    const aL = G.gameLeft || 0, aT = G.gameTop || 0;
    const aW = G.gameW || G.W, aH = G.gameH || G.H;
    const x = aL + Math.random() * aW;
    const y = aT + Math.random() * aH;
    const angle = Math.random() * Math.PI * 2;
    const speed = 5 + Math.random() * 15;
    const p = spawnParticle(x, y, 'mote', color, {
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      maxLife: 2.0 + Math.random() * 3.0,
      size: 0.8 + Math.random() * 1.5,
      layer: 'bg'
    });
    if (p) p.gravity = true; // motes respond to gravity wells
  }
}

function acquireParticle() {
  for (let i = 0; i < particlePool.length; i++) {
    if (!particlePool[i].active) { particlePool[i].active = true; return particlePool[i]; }
  }
  return null;
}

function spawnParticle(x, y, type, color, config) {
  const p = acquireParticle();
  if (!p) return;
  p.type = type;
  p.x = x; p.y = y;
  p.vx = config.vx || 0;
  p.vy = config.vy || 0;
  p.life = 1.0;
  p.maxLife = config.maxLife || 1.0;
  p.size = config.size || 4;
  p.color = color;
  p.alpha = 1;
  p.rotation = config.rotation || 0;
  p.rotSpeed = config.rotSpeed || 0;
  p.trail = null;
  p.radius = 0;
  p.w = config.w || 0;
  p.h = config.h || 0;
  p.layer = config.layer || 'fg';
  return p;
}

function spawnPopParticles(x, y, color) {
  const biome = getCurrentBiome();
  const count = 12;
  // Golden/fiery shift at high WT
  color = fireShift(color, getMadnessAmount());

  // Generic sparks
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.4;
    const speed = 80 + Math.random() * 120;
    spawnParticle(x, y, 'spark', color, {
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      maxLife: 0.4 + Math.random() * 0.3,
      size: 2 + Math.random() * 3
    });
  }

  // Extra tiny debris motes — fill the screen with small stuff
  const palette = getCurrentPalette();
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 20 + Math.random() * 50;
    const moteColor = palette.colors[Math.floor(Math.random() * palette.colors.length)];
    const p = spawnParticle(x, y, 'mote', moteColor, {
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      maxLife: 1.5 + Math.random() * 2.5,
      size: 0.6 + Math.random() * 1.2,
      layer: 'bg'
    });
    if (p) p.gravity = true;
  }

  // Biome-specific
  switch(biome.particleType) {
    case 'ripple':
      spawnParticle(x, y, 'ripple', color, { maxLife: 0.8, size: 0, layer: 'bg' });
      break;
    case 'ember':
      for (let i = 0; i < 4; i++) {
        spawnParticle(x + (Math.random()-0.5)*20, y, 'ember', color, {
          vx: (Math.random()-0.5)*30, vy: -40 - Math.random()*40,
          maxLife: 1.2 + Math.random()*0.8, size: 2 + Math.random()*3
        });
      }
      break;
    case 'ribbon':
      for (let i = 0; i < 2; i++) {
        spawnParticle(x, y, 'ribbon', color, {
          vx: (Math.random()-0.5)*40, vy: -20 - Math.random()*30,
          maxLife: 1.0 + Math.random()*0.5, size: 3
        });
      }
      break;
    case 'hex':
      for (let i = 0; i < 3; i++) {
        const a = Math.random() * Math.PI * 2;
        spawnParticle(x, y, 'hex', color, {
          vx: Math.cos(a)*50, vy: Math.sin(a)*50,
          maxLife: 0.7 + Math.random()*0.3, size: 6 + Math.random()*6,
          rotation: Math.random()*Math.PI, rotSpeed: (Math.random()-0.5)*4
        });
      }
      break;
    case 'glitch':
      for (let i = 0; i < 4; i++) {
        spawnParticle(x + (Math.random()-0.5)*30, y + (Math.random()-0.5)*20, 'glitch', color, {
          maxLife: 0.3 + Math.random()*0.4,
          w: 8 + Math.random()*20, h: 2 + Math.random()*6
        });
      }
      break;
    case 'splat':
      // Add to persistent paint splats
      if (G.paintSplats.length < MAX_PAINT_SPLATS) {
        G.paintSplats.push({ x, y, color, size: 10 + Math.random()*15, alpha: 0.3 + Math.random()*0.2, seed: Math.random()*1000 });
      }
      // Also a brief splat particle
      spawnParticle(x, y, 'splat', color, { maxLife: 0.5, size: 12 + Math.random()*8 });
      break;
    case 'star':
      for (let i = 0; i < 3; i++) {
        const a = Math.random() * Math.PI * 2;
        spawnParticle(x, y, 'star', color, {
          vx: Math.cos(a)*60, vy: Math.sin(a)*60,
          maxLife: 0.6 + Math.random()*0.4, size: 4 + Math.random()*5,
          rotation: Math.random()*Math.PI, rotSpeed: (Math.random()-0.5)*5
        });
      }
      break;
  }
}

function updateParticles(dt) {
  for (let i = 0; i < particlePool.length; i++) {
    const p = particlePool[i];
    if (!p.active) continue;

    p.life -= dt / p.maxLife;
    if (p.life <= 0) { p.active = false; p.trail = null; continue; }

    switch(p.type) {
      case 'spark':
        p.vx *= (1 - 3 * dt);
        p.vy *= (1 - 3 * dt);
        p.vy += 50 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.alpha = p.life;
        p.size = Math.max(0.5, p.size * (1 - dt * 2));
        break;
      case 'ripple':
        p.radius += 60 * dt;
        p.alpha = p.life * 0.5;
        break;
      case 'ember':
        p.vy -= 20 * dt;
        p.vx += (Math.random()-0.5) * 80 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.alpha = p.life * (0.7 + 0.3 * Math.sin(G.time * 15 + p.x));
        break;
      case 'ribbon':
        p.vy -= 10 * dt;
        p.vx = Math.sin(G.time * 3 + p.y * 0.02) * 30;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (!p.trail) p.trail = [];
        p.trail.push({x: p.x, y: p.y});
        if (p.trail.length > 15) p.trail.shift();
        p.alpha = p.life * 0.6;
        break;
      case 'hex':
        p.vx *= (1 - 2 * dt);
        p.vy *= (1 - 2 * dt);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rotation += p.rotSpeed * dt;
        p.alpha = p.life;
        break;
      case 'glitch':
        if (Math.random() < 0.15) {
          p.x += (Math.random()-0.5) * 20;
          p.y += (Math.random()-0.5) * 10;
        }
        p.alpha = p.life * (Math.random() > 0.12 ? 1 : 0);
        break;
      case 'splat':
        p.alpha = p.life * 0.6;
        p.size *= (1 + dt * 0.5);
        break;
      case 'star':
        p.vx *= (1 - 2 * dt);
        p.vy *= (1 - 2 * dt);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rotation += p.rotSpeed * dt;
        p.alpha = p.life;
        break;
      case 'mote': {
        // Tiny ambient specks — swirl with gravitational feel
        // Ambient swirl around center
        const mgcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
        const mgcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
        const mgw = G.gameW || G.W, mgh = G.gameH || G.H;
        const mAttrX = mgcx + Math.sin(G.time * 0.13) * mgw * 0.2;
        const mAttrY = mgcy + Math.cos(G.time * 0.11) * mgh * 0.15;
        const mdx = mAttrX - p.x, mdy = mAttrY - p.y;
        const mDist = Math.sqrt(mdx*mdx + mdy*mdy) + 1;
        const mGrav = Math.min(12, 200 / mDist) * dt;
        const mTanX = -mdy / mDist, mTanY = mdx / mDist;
        const mTan = Math.min(10, 150 / mDist) * dt;
        p.vx += (mdx / mDist) * mGrav + mTanX * mTan;
        p.vy += (mdy / mDist) * mGrav + mTanY * mTan;
        // Velocity damping to keep motes from flying off
        p.vx *= (1 - 0.5 * dt);
        p.vy *= (1 - 0.5 * dt);
        p.x += p.vx * dt + Math.sin(G.time * 1.5 + p.y * 0.01) * 2 * dt;
        p.y += p.vy * dt + Math.cos(G.time * 1.2 + p.x * 0.01) * 2 * dt;
        p.alpha = p.life * 0.4;
        // Gravity well attraction for motes
        if (p.gravity) {
          for (let gw = 0; gw < G.gravityWells.length; gw++) {
            const well = G.gravityWells[gw];
            const wdx = well.x - p.x, wdy = well.y - p.y;
            const wd = Math.sqrt(wdx*wdx + wdy*wdy);
            if (wd < well.radius && wd > 2) {
              const pull = well.strength * 0.3 * dt / wd;
              p.vx += wdx * pull;
              p.vy += wdy * pull;
            }
          }
          // Cursor gravity on motes too
          if (G.cursorX > 0 && G.cursorY > 0) {
            const cdx = G.cursorX - p.x, cdy = G.cursorY - p.y;
            const cd = Math.sqrt(cdx*cdx + cdy*cdy) + 1;
            const cPull = Math.min(8, 1000 / (cd * cd + 300)) * dt;
            p.vx += (cdx / cd) * cPull * 3;
            p.vy += (cdy / cd) * cPull * 3;
          }
        }
        // Wrap around visible game edges
        const pL = G.gameLeft || 0, pT = G.gameTop || 0;
        const pR = G.gameRight || G.W, pB = G.gameBottom || G.H;
        if (p.x < pL - 10) p.x = pR + 10;
        if (p.x > pR + 10) p.x = pL - 10;
        if (p.y < pT - 10) p.y = pB + 10;
        if (p.y > pB + 10) p.y = pT - 10;
        break;
      }
    }
  }
}

// ==================================================
// SECTION 9: EXPLOSION SYSTEM
// ==================================================
function createExplosion(x, y, maxRadius, color, isEcho) {
  if (G.explosions.length >= MAX_EXPLOSIONS) G.explosions.shift();
  G.explosions.push({
    x, y,
    radius: 0,
    maxRadius: maxRadius,
    color: color,
    life: 1.0,
    isEcho: isEcho || false,
    flashAlpha: 1.0
  });
}

function updateExplosions(dt) {
  for (let i = G.explosions.length - 1; i >= 0; i--) {
    const e = G.explosions[i];
    e.radius += (e.maxRadius * 3) * dt;
    if (e.radius > e.maxRadius) e.radius = e.maxRadius;
    e.life -= dt * 3;
    e.flashAlpha = Math.max(0, e.flashAlpha - dt * 8);
    if (e.life <= 0) G.explosions.splice(i, 1);
  }
}

// ==================================================
// SECTION 9b: BOMB SYSTEM
// ==================================================
function placeBomb(x, y) {
  G.bombs.push({
    x, y,
    fuse: BOMB_FUSE_TIME,
    maxFuse: BOMB_FUSE_TIME,
    radius: BASE_BLAST_RADIUS * BOMB_BLAST_MULT,
    color: getCurrentPalette().accent
  });
  spawnFloatingText(x, y - 20, 'SIGIL SET', getCurrentPalette().accent);
  playBombPlaceSound();

  // Attractor Field: mines create a persistent gravity well while fusing
  // Gentle pull — orbs orbit and drift in, fast ones slingshot past
  if (G.upgrades.attractorField > 0) {
    const lvl = G.upgrades.attractorField;
    const aRange = 80 + lvl * 35;
    G.gravityWells.push({
      x, y,
      strength: 20 + lvl * 12,
      radius: aRange,
      life: BOMB_FUSE_TIME,
      maxLife: BOMB_FUSE_TIME,
      color: getCurrentPalette().accent
    });
  }
}

function updateBombs(dt) {
  for (let i = G.bombs.length - 1; i >= 0; i--) {
    const b = G.bombs[i];
    b.fuse -= dt;
    if (b.fuse <= 0) {
      detonateBomb(b);
      G.bombs.splice(i, 1);
    }
  }
}

function detonateBomb(b) {
  createExplosion(b.x, b.y, b.radius, b.color, false);
  G.shakeAmount = Math.max(G.shakeAmount, 6);
  playDelayedBlastExplosion(1);

  // Pop all circles in range — start a chain if not already active
  const wasActive = G.chainActive;
  if (!wasActive) {
    G.chainActive = true;
    G.chainGenId++;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainQueue = [];
    G.chainOriginX = b.x;
    G.chainOriginY = b.y;
  }

  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    const d = dist(b.x, b.y, c.x, c.y);
    if (d < b.radius + c.radius) {
      c.queued = true;
      const tension = getLinkTensionTime() * (0.4 + 0.3 * (d / b.radius)) + Math.random() * 0.04;
      G.chainLinks.push({
        srcX: b.x, srcY: b.y,
        targetId: c.id,
        color: b.color,
        timer: 0,
        duration: tension
      });
    }
  }

  if (!wasActive && G.chainLinks.length === 0 && G.chainQueue.length === 0) {
    G.chainActive = false;
  }
}

function renderBombs(ctx) {
  for (let i = 0; i < G.bombs.length; i++) {
    const b = G.bombs[i];
    const fuseT = b.fuse / b.maxFuse;
    const urgency = 1 - fuseT;
    const blink = Math.sin(b.fuse * (6 + urgency * 20)) > 0;
    ctx.save();
    // Outer ring — blast radius preview
    ctx.globalAlpha = 0.06 + urgency * 0.08;
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    // Mine body
    ctx.globalAlpha = 0.6 + urgency * 0.4;
    ctx.fillStyle = blink ? b.color : '#ffffff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5 + urgency * 3, 0, Math.PI * 2);
    ctx.fill();
    // Fuse arc
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 10 + urgency * 4, -Math.PI / 2, -Math.PI / 2 + fuseT * Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

function playBombPlaceSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, now);
  osc.frequency.exponentialRampToValueAtTime(150, now + 0.12);
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.18);
}

// ==================================================
// ==================================================
// SECTION 9b2: RIFT WALLS — Energy barriers that block blast propagation
// ==================================================
const RIFT_WALL_MIN_MADNESS = 0.30;
const RIFT_WALL_SPAWN_INTERVAL = 24;  // seconds between spawns (was 30)
const RIFT_WALL_MAX = 4;              // max walls on field (was 3)
const RIFT_WALL_HP = 5;               // hits to destroy (was 4)
const RIFT_WALL_POP_RADIUS = 110;     // pop orbs within this distance on shatter (was 80)
const RIFT_WALL_GRAVITY = 35;         // pull strength — orbs drift toward the rift
const RIFT_WALL_GRAVITY_RANGE = 120;  // pixels — gravity pull range from wall

// Line segment intersection test — returns true if AB crosses CD
function lineSegmentsIntersect(ax, ay, bx, by, cx, cy, dx, dy) {
  const denom = (bx - ax) * (dy - cy) - (by - ay) * (dx - cx);
  if (Math.abs(denom) < 0.001) return false; // parallel
  const t = ((cx - ax) * (dy - cy) - (cy - ay) * (dx - cx)) / denom;
  const u = ((cx - ax) * (by - ay) - (cy - ay) * (bx - ax)) / denom;
  return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

// Distance from point (px,py) to line segment (x1,y1)-(x2,y2)
function pointToSegmentDist(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const lenSq = dx * dx + dy * dy;
  if (lenSq < 0.001) return dist(px, py, x1, y1);
  const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lenSq));
  return dist(px, py, x1 + t * dx, y1 + t * dy);
}

function spawnRiftWall() {
  const gL = G.gameLeft, gT = G.gameTop, gR = G.gameRight, gB = G.gameBottom;
  const gW = gR - gL, gH = gB - gT;
  const cx = gL + gW * (0.2 + Math.random() * 0.6);
  const cy = gT + gH * (0.2 + Math.random() * 0.6);

  // Skip if too close to boss
  if (G.boss && dist(cx, cy, G.boss.x, G.boss.y) < 200) return;

  // Random angle, span 40-70% of the smaller field dimension
  const angle = Math.random() * Math.PI;
  const span = Math.min(gW, gH) * (0.4 + Math.random() * 0.3) * 0.5;
  const x1 = cx + Math.cos(angle) * span;
  const y1 = cy + Math.sin(angle) * span;
  const x2 = cx - Math.cos(angle) * span;
  const y2 = cy - Math.sin(angle) * span;

  G.riftWalls.push({
    x1, y1, x2, y2,
    hp: RIFT_WALL_HP,
    maxHp: RIFT_WALL_HP,
    alpha: 0,       // fade in
    phase: Math.random() * Math.PI * 2,
    hitFlash: 0
  });
  const wallLore = ['MEMBRANE FRACTURE', 'THE SCAR HARDENS', 'DIMENSION CRYSTALLIZES'][Math.floor(Math.random() * 3)];
  spawnFloatingText(cx, cy, wallLore, '#b040ff', 1.2, { fontSize: 13 });
}

function shatterRiftWall(wall, index) {
  const mx = (wall.x1 + wall.x2) / 2, my = (wall.y1 + wall.y2) / 2;

  // Pop all orbs near the wall
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped || c.queued) continue;
    const d = pointToSegmentDist(c.x, c.y, wall.x1, wall.y1, wall.x2, wall.y2);
    if (d < RIFT_WALL_POP_RADIUS) {
      popCircle(c);
    }
  }

  // Particle burst along wall length
  const dx = wall.x2 - wall.x1, dy = wall.y2 - wall.y1;
  for (let p = 0; p < 15; p++) {
    const t = Math.random();
    const px = wall.x1 + dx * t, py = wall.y1 + dy * t;
    const angle = Math.random() * Math.PI * 2;
    spawnParticle(px, py, 'spark', '#b040ff', {
      vx: Math.cos(angle) * (100 + Math.random() * 200),
      vy: Math.sin(angle) * (100 + Math.random() * 200),
      maxLife: 0.5 + Math.random() * 0.3, size: 3 + Math.random() * 3
    });
  }

  const shatterLore = ['THE MEMBRANE TEARS', 'INFINITY SHATTERS', 'THE SCAR OPENS'][Math.floor(Math.random() * 3)];
  spawnFloatingText(mx, my - 20, shatterLore, '#d060ff', 1.5, { fontSize: 15 });
  G.shakeAmount = Math.max(G.shakeAmount, 3);
  G.riftWalls.splice(index, 1);
}

function updateRiftWalls(dt) {
  const madness = getMadnessAmount();

  // Below threshold: fade out & remove
  if (madness < RIFT_WALL_MIN_MADNESS) {
    for (let i = G.riftWalls.length - 1; i >= 0; i--) {
      G.riftWalls[i].alpha -= dt * 2;
      if (G.riftWalls[i].alpha <= 0) G.riftWalls.splice(i, 1);
    }
    G.riftWallTimer = 0;
    return;
  }

  // Update existing walls
  for (let i = G.riftWalls.length - 1; i >= 0; i--) {
    const w = G.riftWalls[i];
    w.alpha = Math.min(1, w.alpha + dt * 1.5); // fade in
    w.phase += dt * 2;
    if (w.hitFlash > 0) w.hitFlash -= dt * 4;

    // Gravitational pull — orbs near the rift drift toward it
    if (w.alpha > 0.5) {
      for (let j = 0; j < G.circles.length; j++) {
        const c = G.circles[j];
        if (!c.alive || c.popped) continue;
        const d = pointToSegmentDist(c.x, c.y, w.x1, w.y1, w.x2, w.y2);
        if (d < RIFT_WALL_GRAVITY_RANGE && d > 3) {
          // Find closest point on wall segment for pull direction
          const wdx = w.x2 - w.x1, wdy = w.y2 - w.y1;
          const wLenSq = wdx * wdx + wdy * wdy;
          const t = Math.max(0, Math.min(1, ((c.x - w.x1) * wdx + (c.y - w.y1) * wdy) / (wLenSq || 1)));
          const closestX = w.x1 + t * wdx, closestY = w.y1 + t * wdy;
          const pullDx = closestX - c.x, pullDy = closestY - c.y;
          const pullDist = Math.sqrt(pullDx * pullDx + pullDy * pullDy) || 1;
          const pullStr = RIFT_WALL_GRAVITY * w.alpha * (1 - d / RIFT_WALL_GRAVITY_RANGE) * dt;
          c.vx += (pullDx / pullDist) * pullStr;
          c.vy += (pullDy / pullDist) * pullStr;
        }
      }
    }
  }

  // Spawn timer
  G.riftWallTimer += dt;
  if (G.riftWallTimer >= RIFT_WALL_SPAWN_INTERVAL && G.riftWalls.length < RIFT_WALL_MAX) {
    spawnRiftWall();
    G.riftWallTimer = 0;
  }

  // Spawn first wall quickly (5s after madness threshold)
  if (G.riftWalls.length === 0 && G.riftWallTimer >= 5) {
    spawnRiftWall();
    G.riftWallTimer = 0;
  }
}

function damageRiftWall(explosionX, explosionY, blastR) {
  for (let i = G.riftWalls.length - 1; i >= 0; i--) {
    const w = G.riftWalls[i];
    const d = pointToSegmentDist(explosionX, explosionY, w.x1, w.y1, w.x2, w.y2);
    if (d < blastR) {
      w.hp--;
      w.hitFlash = 1.0;
      playRiftDamageSound();
      if (w.hp <= 0) {
        shatterRiftWall(w, i);
      }
    }
  }
}

function renderRiftWalls(ctx) {
  for (let i = 0; i < G.riftWalls.length; i++) {
    const w = G.riftWalls[i];
    if (w.alpha <= 0) continue;

    const hpFrac = w.hp / w.maxHp;
    const pulse = 0.5 + 0.5 * Math.sin(w.phase);
    const baseAlpha = w.alpha * (0.6 + hpFrac * 0.4);
    const hit = w.hitFlash > 0 ? w.hitFlash : 0;
    const dx = w.x2 - w.x1, dy = w.y2 - w.y1;
    const wallLen = Math.sqrt(dx * dx + dy * dy) || 1;
    const nx = -(dy / wallLen), ny = dx / wallLen;

    // Build a jagged crack path (reused for all layers)
    const segs = Math.max(6, Math.floor(wallLen / 25));
    const crackPath = [];
    for (let s = 0; s <= segs; s++) {
      const t = s / segs;
      const bx = w.x1 + dx * t;
      const by = w.y1 + dy * t;
      // Seeded zig-zag perpendicular to line
      const seed = i * 3.7 + s * 7.13;
      const jag = (s === 0 || s === segs) ? 0 :
        (Math.sin(seed) * 4 + Math.sin(seed * 2.3) * 2.5 + Math.sin(w.phase * 0.6 + t * 5) * 1.5);
      crackPath.push({ x: bx + nx * jag, y: by + ny * jag });
    }

    // --- Layer 1: Soft outer glow ---
    ctx.save();
    ctx.globalAlpha = baseAlpha * 0.12;
    ctx.strokeStyle = hit > 0.2 ? '#ff4040' : '#8040c0';
    ctx.lineWidth = 20 + pulse * 6;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(crackPath[0].x, crackPath[0].y);
    for (let s = 1; s < crackPath.length; s++) ctx.lineTo(crackPath[s].x, crackPath[s].y);
    ctx.stroke();
    ctx.restore();

    // --- Layer 2: Dark crack interior ---
    ctx.save();
    ctx.globalAlpha = baseAlpha * 0.85;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4 + pulse * 1.5;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(crackPath[0].x, crackPath[0].y);
    for (let s = 1; s < crackPath.length; s++) ctx.lineTo(crackPath[s].x, crackPath[s].y);
    ctx.stroke();
    ctx.restore();

    // --- Layer 3: Bright energy edge (thinner, on top of dark crack) ---
    ctx.save();
    ctx.globalAlpha = baseAlpha * (0.4 + hpFrac * 0.4 + hit * 0.5);
    ctx.strokeStyle = hit > 0.2 ? '#ff6060' : `hsl(${270 + pulse * 20}, 70%, ${55 + pulse * 10}%)`;
    ctx.lineWidth = 1.5 + pulse * 0.8;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(crackPath[0].x, crackPath[0].y);
    for (let s = 1; s < crackPath.length; s++) ctx.lineTo(crackPath[s].x, crackPath[s].y);
    ctx.stroke();
    ctx.restore();

    // --- HP pips along the crack midpoint ---
    const mx = (w.x1 + w.x2) / 2, my = (w.y1 + w.y2) / 2;
    ctx.globalAlpha = w.alpha * 0.8;
    const pipSpacing = 8;
    for (let h = 0; h < w.maxHp; h++) {
      const offset = (h - (w.maxHp - 1) / 2) * pipSpacing;
      const px = mx + (dx / wallLen) * offset + nx * 12;
      const py = my + (dy / wallLen) * offset + ny * 12;
      if (h < w.hp) {
        ctx.fillStyle = hit > 0.2 ? '#ff8080' : '#c070ff';
        ctx.beginPath();
        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = '#201030';
        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  ctx.globalAlpha = 1;
}

// ==================================================
// SECTION 9b3: GRAVITY BRIDGES — Same-color orbs form energy connections
// ==================================================
const BRIDGE_MIN_MADNESS = 0.55;   // madness threshold to start forming bridges
const BRIDGE_PROXIMITY = 3.0;      // within 3× average radius of the pair
const BRIDGE_FORM_TIME = 2.0;      // seconds of proximity to form a bridge
const BRIDGE_MAX = 60;             // cap for performance
const BRIDGE_CHECK_INTERVAL = 0.3; // seconds between proximity scans

function updateBridges(dt) {
  const madness = getMadnessAmount();

  // Below threshold: clear bridges and return
  if (madness < BRIDGE_MIN_MADNESS) {
    if (G.bridges.length > 0) G.bridges = [];
    return;
  }

  // Update existing bridge pulse phases
  for (let i = 0; i < G.bridges.length; i++) {
    G.bridges[i].age += dt;
    G.bridges[i].pulsePhase += dt * 2.5;
  }

  // Prune dead bridges (orb died/popped/queued)
  for (let i = G.bridges.length - 1; i >= 0; i--) {
    const br = G.bridges[i];
    const orbA = findCircleById(br.orbIdA);
    const orbB = findCircleById(br.orbIdB);
    if (!orbA || !orbB || !orbA.alive || !orbB.alive || orbA.popped || orbB.popped) {
      G.bridges.splice(i, 1);
    }
  }

  // Timer-gated proximity scan (not every frame)
  G.bridgeCheckTimer += dt;
  if (G.bridgeCheckTimer < BRIDGE_CHECK_INTERVAL) return;
  G.bridgeCheckTimer = 0;

  if (G.bridges.length >= BRIDGE_MAX) return;

  // Build spatial grid for O(n) proximity checks
  const cellSize = 60;
  const grid = {};
  const alive = [];
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped || c.queued || c.superCell || c.tethered) continue;
    alive.push(c);
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    const key = gx + ',' + gy;
    if (!grid[key]) grid[key] = [];
    grid[key].push(c);
  }

  // Build set of existing bridge pairs for fast lookup
  const bridgeSet = new Set();
  for (let i = 0; i < G.bridges.length; i++) {
    const br = G.bridges[i];
    const minId = Math.min(br.orbIdA, br.orbIdB);
    const maxId = Math.max(br.orbIdA, br.orbIdB);
    bridgeSet.add(minId + ':' + maxId);
  }

  // Scan for new bridge candidates
  let formed = 0;
  for (let i = 0; i < alive.length && G.bridges.length < BRIDGE_MAX; i++) {
    const a = alive[i];
    if (a.colorIdx === undefined) continue;
    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    // Check 3×3 neighborhood
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = (gx + dx) + ',' + (gy + dy);
        const cell = grid[key];
        if (!cell) continue;
        for (let j = 0; j < cell.length; j++) {
          const b = cell[j];
          if (b.id <= a.id) continue; // avoid duplicates
          if (b.colorIdx !== a.colorIdx) continue; // must be same palette color
          if (b.colorIdx === undefined) continue;

          // Check if bridge already exists
          const pairKey = Math.min(a.id, b.id) + ':' + Math.max(a.id, b.id);
          if (bridgeSet.has(pairKey)) continue;

          // Distance check
          const ddx = a.x - b.x, ddy = a.y - b.y;
          const d = Math.sqrt(ddx * ddx + ddy * ddy);
          const avgR = (a.radius + b.radius) * 0.5;
          if (d > avgR * BRIDGE_PROXIMITY) continue;

          // Initialize proximity timers if needed
          if (!a._bridgeTimers) a._bridgeTimers = {};
          if (!a._bridgeTimers[b.id]) a._bridgeTimers[b.id] = 0;
          a._bridgeTimers[b.id] += BRIDGE_CHECK_INTERVAL;

          if (a._bridgeTimers[b.id] >= BRIDGE_FORM_TIME) {
            // Form bridge!
            G.bridges.push({
              orbIdA: a.id,
              orbIdB: b.id,
              age: 0,
              pulsePhase: Math.random() * Math.PI * 2
            });
            bridgeSet.add(pairKey);
            delete a._bridgeTimers[b.id];
            formed++;
            if (G.bridges.length >= BRIDGE_MAX) break;
          }
        }
        if (G.bridges.length >= BRIDGE_MAX) break;
      }
      if (G.bridges.length >= BRIDGE_MAX) break;
    }
  }

  // Clean up stale proximity timers for orbs that drifted apart
  for (let i = 0; i < alive.length; i++) {
    const a = alive[i];
    if (!a._bridgeTimers) continue;
    for (const idStr in a._bridgeTimers) {
      const bId = parseInt(idStr);
      const b = findCircleById(bId);
      if (!b || !b.alive || b.popped) {
        delete a._bridgeTimers[idStr];
        continue;
      }
      const ddx = a.x - b.x, ddy = a.y - b.y;
      const d = Math.sqrt(ddx * ddx + ddy * ddy);
      const avgR = (a.radius + b.radius) * 0.5;
      if (d > avgR * BRIDGE_PROXIMITY) {
        // Drifted apart — decay timer
        a._bridgeTimers[idStr] = Math.max(0, a._bridgeTimers[idStr] - BRIDGE_CHECK_INTERVAL * 2);
      }
    }
  }
}

function renderBridges(ctx) {
  if (G.bridges.length === 0) return;
  const madness = getMadnessAmount();
  if (madness < BRIDGE_MIN_MADNESS) return;

  ctx.save();
  for (let i = 0; i < G.bridges.length; i++) {
    const br = G.bridges[i];
    const orbA = findCircleById(br.orbIdA);
    const orbB = findCircleById(br.orbIdB);
    if (!orbA || !orbB || !orbA.alive || !orbB.alive) continue;

    // Use the orb's visual color (already horror-shifted) for the bridge
    const bridgeColor = orbA.color;

    // Fade in during first 0.5s
    const fadeIn = Math.min(1, br.age / 0.5);
    // Pulse alpha between 12-30%
    const pulse = 0.5 + 0.5 * Math.sin(br.pulsePhase);
    const alpha = fadeIn * (0.12 + pulse * 0.18);

    // Parse bridge color for RGBA
    const r = parseInt(bridgeColor.slice(1, 3), 16);
    const g = parseInt(bridgeColor.slice(3, 5), 16);
    const b = parseInt(bridgeColor.slice(5, 7), 16);

    // Main bridge line — thin, pulsing
    ctx.beginPath();
    ctx.moveTo(orbA.x, orbA.y);
    ctx.lineTo(orbB.x, orbB.y);
    ctx.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha.toFixed(3) + ')';
    ctx.lineWidth = 0.8 + pulse * 0.4;
    ctx.stroke();

    // Inner brighter core line
    ctx.beginPath();
    ctx.moveTo(orbA.x, orbA.y);
    ctx.lineTo(orbB.x, orbB.y);
    ctx.strokeStyle = 'rgba(' + Math.min(255, r + 60) + ',' + Math.min(255, g + 60) + ',' + Math.min(255, b + 40) + ',' + (alpha * 0.5).toFixed(3) + ')';
    ctx.lineWidth = 0.4 + pulse * 0.2;
    ctx.stroke();

    // Glow nodes at each end (small radial gradient dots)
    const nodeR = 3 + pulse * 1.5;
    for (const orb of [orbA, orbB]) {
      const grad = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, nodeR);
      grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (alpha * 0.7).toFixed(3) + ')');
      grad.addColorStop(1, 'rgba(' + r + ',' + g + ',' + b + ',0)');
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, nodeR, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }
  }
  ctx.restore();
}

// SECTION 9b: SHADOW BALLS — Dark phantom orbs at 70%+ madness
// Non-interactive, follow gravity chaotically, can feed black holes
// ==================================================
const SHADOW_BALL_MIN_MADNESS = 0.55;  // madness threshold to start spawning
const SHADOW_BALL_MAX_COUNT = 600;     // more numerous — swarm of tiny dark motes
const SHADOW_BALL_SIZE_MIN = 1.5;      // smaller scale
const SHADOW_BALL_SIZE_MAX = 6;        // was 12 — much smaller now
const SHADOW_BALL_SPAWN_RATE = 0.02;   // fast spawning to fill the swarm
let shadowSpawnTimer = 0;

function createShadowBall() {
  // Spawn from random edge (like normal orbs)
  const gL = G.gameLeft, gR = G.gameRight, gT = G.gameTop, gB = G.gameBottom;
  const edge = Math.floor(Math.random() * 4);
  let x, y;
  if (edge === 0) { x = gL - 10; y = gT + Math.random() * (gB - gT); }
  else if (edge === 1) { x = gR + 10; y = gT + Math.random() * (gB - gT); }
  else if (edge === 2) { x = gL + Math.random() * (gR - gL); y = gT - 10; }
  else { x = gL + Math.random() * (gR - gL); y = gB + 10; }

  return {
    x, y,
    vx: (Math.random() - 0.5) * 40,
    vy: (Math.random() - 0.5) * 40,
    radius: SHADOW_BALL_SIZE_MIN + Math.random() * (SHADOW_BALL_SIZE_MAX - SHADOW_BALL_SIZE_MIN),
    phase: Math.random() * Math.PI * 2,     // unique oscillation phase
    chaosAngle: Math.random() * Math.PI * 2, // random jitter angle
    chaosTimer: 0.5 + Math.random() * 1.5,   // time until next jitter shift
    driftAngle: Math.random() * Math.PI * 2,
    alive: true,
    alpha: 0,   // fade in
    life: 0,
    stretchX: 1, stretchY: 1, stretchAngle: 0  // velocity-based elongation
  };
}

function updateShadowBalls(dt) {
  const madness = getMadnessAmount();

  // Below threshold: despawn all shadow balls gradually
  if (madness < SHADOW_BALL_MIN_MADNESS) {
    for (let i = G.shadowBalls.length - 1; i >= 0; i--) {
      G.shadowBalls[i].alpha -= dt * 2;
      if (G.shadowBalls[i].alpha <= 0) G.shadowBalls.splice(i, 1);
    }
    return;
  }

  // Target count scales from 0 at 70% to max at 100%
  const madFrac = Math.min(1, (madness - SHADOW_BALL_MIN_MADNESS) / (1.0 - SHADOW_BALL_MIN_MADNESS));
  const targetCount = Math.floor(SHADOW_BALL_MAX_COUNT * madFrac);

  // Spawn new shadow balls at intervals — batch spawn to fill faster
  shadowSpawnTimer -= dt;
  if (shadowSpawnTimer <= 0 && G.shadowBalls.length < targetCount) {
    const batchSize = Math.min(5, targetCount - G.shadowBalls.length);
    for (let sb = 0; sb < batchSize; sb++) {
      G.shadowBalls.push(createShadowBall());
    }
    shadowSpawnTimer = SHADOW_BALL_SPAWN_RATE;
  }

  // Remove excess if madness dropped
  while (G.shadowBalls.length > targetCount + 10) {
    G.shadowBalls.pop();
  }

  const madPhys = getMadnessPhysicsScale();
  const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
  const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
  const gw = G.gameW || G.W, gh = G.gameH || G.H;

  for (let i = G.shadowBalls.length - 1; i >= 0; i--) {
    const sb = G.shadowBalls[i];
    sb.life += dt;

    // Fade in
    if (sb.alpha < 1) sb.alpha = Math.min(1, sb.alpha + dt * 1.5);

    // --- CHAOTIC GRAVITY: same forces as normal orbs but amplified + jittery ---

    // Gravitational swirl toward field center (amplified 1.5×)
    const attractX = gcx + Math.sin(G.time * 0.13 + sb.phase * 2) * gw * 0.3;
    const attractY = gcy + Math.cos(G.time * 0.11 + sb.phase * 1.7) * gh * 0.25;
    const adx = attractX - sb.x;
    const ady = attractY - sb.y;
    const aDist = Math.sqrt(adx * adx + ady * ady) + 1;
    const gravStr = Math.min(50, 1200 / aDist) * dt;
    const tangentX = -ady / aDist;
    const tangentY = adx / aDist;
    const tangentStr = Math.min(35, 700 / aDist) * dt;
    sb.x += (adx / aDist) * gravStr + tangentX * tangentStr;
    sb.y += (ady / aDist) * gravStr + tangentY * tangentStr;

    // Chaotic jitter — random directional shifts more aggressive than normal orbs
    sb.chaosTimer -= dt;
    if (sb.chaosTimer <= 0) {
      sb.chaosTimer = 0.3 + Math.random() * 1.0;
      sb.chaosAngle += (Math.random() - 0.5) * 4.0; // aggressive angle shift
      sb.driftAngle += (Math.random() - 0.5) * 3.0;
    }
    const jitterSpeed = 25 + madFrac * 20;
    sb.vx += Math.cos(sb.chaosAngle) * jitterSpeed * dt;
    sb.vy += Math.sin(sb.chaosAngle) * jitterSpeed * dt;

    // Ambient wave (faster, more erratic than normal orbs)
    sb.x += Math.sin(G.time * 0.8 + sb.phase) * 1.2 * dt * 10;
    sb.y += Math.cos(G.time * 0.7 + sb.phase * 1.5) * 1.2 * dt * 10;

    // Brownian drift (faster direction changes)
    const driftSpeed = 18 + madFrac * 12;
    sb.x += Math.cos(sb.driftAngle) * driftSpeed * dt;
    sb.y += Math.sin(sb.driftAngle) * driftSpeed * dt;

    // Cursor gravity — moderate pull so shadow balls gather near cursor (enables Dark Prism)
    if (G.cursorX > 0 && G.cursorY > 0) {
      const cdx = G.cursorX - sb.x;
      const cdy = G.cursorY - sb.y;
      const cDist = Math.sqrt(cdx * cdx + cdy * cdy) + 1;
      const cursorReachMult = 8.0 + madness * 6.0;
      const cursorStrMult = (0.7 + madness * 0.5);
      const effDist = cDist / cursorReachMult;
      const pullBase = 350 * madPhys * cursorStrMult;
      const cursorPull = Math.min(25 * madPhys * cursorStrMult, pullBase / (effDist + 25)) * dt;
      sb.x += (cdx / cDist) * cursorPull;
      sb.y += (cdy / cDist) * cursorPull;
    }

    // Whirlwind effect — shadow balls caught in biome swirl (amplified 1.5×)
    if (whirlwindActive > 0) {
      const maxDur = 2.7 + madness * 0.75;
      const waveStr = Math.sin((maxDur - whirlwindActive) / maxDur * Math.PI);
      const sdx = sb.x - gcx, sdy = sb.y - gcy;
      const sd = Math.sqrt(sdx * sdx + sdy * sdy) + 1;
      const swirlMadMult = 1.25 + madness * 1.75;
      const sStr = waveStr * 75 * madPhys * swirlMadMult * dt * Math.min(1, sd / 200); // 1.5× normal
      sb.vx += (-sdy / sd * whirlwindDir) * sStr;
      sb.vy += (sdx / sd * whirlwindDir) * sStr;
      sb.vx -= (sdx / sd) * sStr * 0.3;
      sb.vy -= (sdy / sd) * sStr * 0.3;
    }

    // ABYSS pressure wave — pushed toward center (amplified 1.5×)
    if (abyssPressureWave > 0) {
      const waveStr = Math.sin((2.25 - abyssPressureWave) / 2.25 * Math.PI);
      const pdx = gcx - sb.x, pdy = gcy - sb.y;
      const pd = Math.sqrt(pdx * pdx + pdy * pdy) + 1;
      const abyssMadMult = 1.25 + madness * 1.75;
      const pushStr = waveStr * 120 * abyssMadMult * dt * Math.min(1, pd / 200); // 1.5× normal
      sb.vx += (pdx / pd) * pushStr;
      sb.vy += (pdy / pd) * pushStr;
    }

    // Strong repulsion — shadow balls push hard to stay spread out
    const repelRange = 80 + sb.radius * 6;
    let repelChecks = 0;
    for (let j = Math.max(0, i - 10); j < Math.min(G.shadowBalls.length, i + 10) && repelChecks < 6; j++) {
      if (j === i) continue;
      const other = G.shadowBalls[j];
      if (!other.alive) continue;
      const cdx = other.x - sb.x, cdy = other.y - sb.y;
      const cd = Math.sqrt(cdx * cdx + cdy * cdy);
      if (cd < repelRange && cd > 1) {
        repelChecks++;
        const rnx = cdx / cd, rny = cdy / cd;
        const repelF = (1 - cd / repelRange) * 80 * dt;
        sb.vx -= rnx * repelF;
        sb.vy -= rny * repelF;
      }
    }

    // Apply velocity with strong damping (shadow balls are floaty)
    sb.x += sb.vx * dt;
    sb.y += sb.vy * dt;
    sb.vx *= 0.92;
    sb.vy *= 0.92;

    // Velocity-based stretch — strong elongation in movement direction
    const sbSpeed = Math.sqrt(sb.vx * sb.vx + sb.vy * sb.vy);
    const stretchAmt = Math.min(1.8, sbSpeed / 60); // much stronger: up to 180% elongation
    if (sbSpeed > 3) {
      sb.stretchAngle = Math.atan2(sb.vy, sb.vx);
      sb.stretchX = 1 + stretchAmt;
      sb.stretchY = 1 / (1 + stretchAmt * 0.7); // conserve area roughly
    } else {
      sb.stretchX += (1 - sb.stretchX) * 4 * dt; // relax back to circle
      sb.stretchY += (1 - sb.stretchY) * 4 * dt;
    }

    // --- BLACK HOLE GRAVITY + FEEDING ---
    for (let bhi = 0; bhi < G.blackHoles.length; bhi++) {
      const bh = G.blackHoles[bhi];
      const dx = bh.x - sb.x;
      const dy = bh.y - sb.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < bh.gravityRadius * madPhys * 1.5 && d > 3) {
        // Much stronger pull than normal orbs (3×) — shadow balls are deeply drawn to black holes
        const accel = bh.strength * madPhys * 3.0 * dt / Math.max(d, 20);
        const nx = dx / d, ny = dy / d;
        sb.vx += nx * accel;
        sb.vy += ny * accel;
        // Tangential spin
        sb.vx += (-ny) * accel * BH_TANGENT_STRENGTH;
        sb.vy += (nx) * accel * BH_TANGENT_STRENGTH;

        // Swallow: shadow ball touches event horizon → feeds fractional mass
        // Mass based on shadow ball size relative to normal orbs (3-9px vs 18px = 17-50%)
        if (d < bh.radius * BH_SWALLOW_RADIUS_MULT) {
          sb.alive = false;
          const massFrac = sb.radius / BASE_CIRCLE_RADIUS; // ~0.17 to ~0.50
          bh.mass += massFrac;
          bh.radius = BH_VISUAL_RADIUS + bh.mass * 3;
          bh.gravityRadius = BH_GRAVITY_RADIUS + bh.mass * 15;
          bh.strength = BH_STRENGTH + bh.mass * 80;
          // Subtle dark particle burst
          for (let p = 0; p < 4; p++) {
            G.particles.push({
              x: sb.x, y: sb.y,
              vx: (Math.random() - 0.5) * 60,
              vy: (Math.random() - 0.5) * 60,
              radius: 1 + Math.random() * 2,
              color: '#1a1a2e',
              life: 0.4 + Math.random() * 0.3,
              maxLife: 0.7,
              layer: 'fg'
            });
          }
          if (bh.mass >= BH_COLLAPSE_THRESHOLD) {
            spawnFloatingText(bh.x, bh.y - 30, 'TAP TO COLLAPSE', '#e0a0ff');
          }
        }
      }
    }

    // Supermassive black hole gravity + feeding
    if (G.superBlackHole) {
      const sbh = G.superBlackHole;
      const dx = sbh.x - sb.x;
      const dy = sbh.y - sb.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < sbh.gravityRadius * madPhys * 1.5 && d > 3) {
        const pullStr = sbh.strength * madPhys * 3.0 * dt / Math.max(Math.sqrt(d) * 4, 10);
        const nx = dx / d, ny = dy / d;
        sb.vx += nx * pullStr;
        sb.vy += ny * pullStr;
        sb.vx += (-ny) * pullStr * sbh.tangentRatio;
        sb.vy += (nx) * pullStr * sbh.tangentRatio;

        // Swallow — fractional mass from shadow balls
        if (d < sbh.radius * SBH_SWALLOW_FRAC) {
          sb.alive = false;
          const massFrac = sb.radius / BASE_CIRCLE_RADIUS; // ~0.17 to ~0.50
          sbh.mass += massFrac;
          sbh.radius = sbh.baseRadius + sbh.mass * 5;
          sbh.gravityRadius = sbh.baseGravityRadius + sbh.mass * 20;
          sbh.strength = sbh.baseStrength + sbh.mass * 150;
          for (let p = 0; p < 4; p++) {
            G.particles.push({
              x: sb.x, y: sb.y,
              vx: (Math.random() - 0.5) * 80,
              vy: (Math.random() - 0.5) * 80,
              radius: 1 + Math.random() * 2,
              color: '#0a0a1e',
              life: 0.4 + Math.random() * 0.3,
              maxLife: 0.7,
              layer: 'fg'
            });
          }
          if (sbh.mass >= SBH_COLLAPSE_MASS && !sbh.collapseReady) {
            sbh.collapseReady = true;
            sbh.pulseTime = 0;
            spawnFloatingText(sbh.x, sbh.y - 40, 'TAP TO COLLAPSE!', '#ff6080');
          }
        }
      }
    }

    // Keep on screen — soft bounce off game boundaries
    const margin = 30;
    const gL = G.gameLeft, gR = G.gameRight, gT = G.gameTop, gB = G.gameBottom;
    if (sb.x < gL - margin) { sb.x = gL - margin; sb.vx = Math.abs(sb.vx) * 0.5; }
    if (sb.x > gR + margin) { sb.x = gR + margin; sb.vx = -Math.abs(sb.vx) * 0.5; }
    if (sb.y < gT - margin) { sb.y = gT - margin; sb.vy = Math.abs(sb.vy) * 0.5; }
    if (sb.y > gB + margin) { sb.y = gB + margin; sb.vy = -Math.abs(sb.vy) * 0.5; }

    // Remove dead shadow balls
    if (!sb.alive) {
      G.shadowBalls.splice(i, 1);
    }
  }

  // --- HIDDEN MECHANIC: Shadow Ball Prism — detect dense stacking ---
  // When enough shadow balls cluster tightly, they form a "dark prism" that inverts gravity.
  // Activation has a 2s cooldown after deactivation to prevent hectic toggling.
  // Once active, stays on for at least 3s grace period after cluster disperses.

  // Tick cooldown
  if (G.prismCooldown > 0) G.prismCooldown = Math.max(0, G.prismCooldown - dt);

  let clusterDetected = false;
  if (G.shadowBalls.length >= 12 && G.prismCooldown <= 0) {
    const PRISM_RADIUS = 35;
    const PRISM_THRESHOLD = 10;
    const step = Math.max(1, Math.floor(G.shadowBalls.length / 30));
    for (let i = 0; i < G.shadowBalls.length; i += step) {
      const probe = G.shadowBalls[i];
      let clusterCount = 0;
      for (let j = 0; j < G.shadowBalls.length; j++) {
        if (j === i) continue;
        const cdx = G.shadowBalls[j].x - probe.x;
        const cdy = G.shadowBalls[j].y - probe.y;
        if (cdx * cdx + cdy * cdy < PRISM_RADIUS * PRISM_RADIUS) {
          clusterCount++;
          if (clusterCount >= PRISM_THRESHOLD) break;
        }
      }
      if (clusterCount >= PRISM_THRESHOLD) {
        clusterDetected = true;
        if (!G.prismClusterActive) {
          // First trigger — visual burst + shake
          spawnFloatingText(probe.x, probe.y - 20, 'DARK PRISM', '#c080ff');
          for (let j = 0; j < G.shadowBalls.length; j++) {
            const cdx2 = G.shadowBalls[j].x - probe.x;
            const cdy2 = G.shadowBalls[j].y - probe.y;
            const cd = Math.sqrt(cdx2 * cdx2 + cdy2 * cdy2) + 1;
            if (cd < PRISM_RADIUS * 3) {
              G.shadowBalls[j].vx += (cdx2 / cd) * 120;
              G.shadowBalls[j].vy += (cdy2 / cd) * 120;
            }
          }
          G.shakeAmount = Math.max(G.shakeAmount, 8);
        }
        break;
      }
    }
  }

  // Manage prism state: active while cluster exists, 3s grace after disengage, 2s cooldown after off
  if (clusterDetected) {
    G.prismClusterActive = true;
    G.gravityInvertTimer = 3.0; // 3s grace period while cluster held
  } else {
    if (G.prismClusterActive) G.prismClusterActive = false;
    // Grace period: count down after cluster breaks
    if (G.gravityInvertTimer > 0) {
      G.gravityInvertTimer = Math.max(0, G.gravityInvertTimer - dt);
      // When grace fully expires, start cooldown
      if (G.gravityInvertTimer <= 0) {
        G.prismCooldown = 5.0; // 5s cooldown before it can trigger again (was 2s)
      }
    }
  }

  // --- Smooth gravity inversion factor (ease in/out) ---
  const invertTarget = G.gravityInvertTimer > 0 ? -1 : 1;
  // Minimum hold time: prevent rapid flip-flopping
  if (G.gravityInvertSwitchCooldown > 0) {
    G.gravityInvertSwitchCooldown -= dt;
  }
  // Detect state direction change — start cooldown
  const currentSign = G.gravityInvertFactor >= 0 ? 1 : -1;
  if (currentSign !== Math.sign(invertTarget) && G.gravityInvertSwitchCooldown <= 0) {
    G.gravityInvertSwitchCooldown = 1.8;
  }
  // Lerp toward target (~0.4-0.5s transition)
  G.gravityInvertFactor += (invertTarget - G.gravityInvertFactor) * dt * 2.5;
  G.gravityInvertFactor = Math.max(-1, Math.min(1, G.gravityInvertFactor));
}

function renderShadowBalls(ctx) {
  if (G.shadowBalls.length === 0) return;

  ctx.save();

  // Shadow orbs grow during gravity inversion
  const sbInvertEffect = Math.max(0, -G.gravityInvertFactor); // 0 normal, 1 fully inverted
  for (let i = 0; i < G.shadowBalls.length; i++) {
    const sb = G.shadowBalls[i];
    const r = sb.radius * (1.0 + 0.3 * sbInvertEffect);
    const a = sb.alpha * 0.85;

    if (sb.stretchX > 1.05) {
      ctx.save();
      ctx.translate(sb.x, sb.y);
      ctx.rotate(sb.stretchAngle);
      ctx.scale(sb.stretchX, sb.stretchY);
      // 1px feathered edge via radial gradient
      if (r > 2) {
        const g = ctx.createRadialGradient(0, 0, Math.max(0, r - 1), 0, 0, r + 0.5);
        g.addColorStop(0, `rgba(0,0,0,${a})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
      } else {
        ctx.fillStyle = `rgba(0,0,0,${a})`;
      }
      ctx.beginPath();
      ctx.arc(0, 0, r + 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else {
      if (r > 2) {
        const g = ctx.createRadialGradient(sb.x, sb.y, Math.max(0, r - 1), sb.x, sb.y, r + 0.5);
        g.addColorStop(0, `rgba(0,0,0,${a})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
      } else {
        ctx.fillStyle = `rgba(0,0,0,${a})`;
      }
      ctx.beginPath();
      ctx.arc(sb.x, sb.y, r + 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}

// ==================================================
// SECTION 10: CHAIN REACTION ENGINE
// ==================================================
function startChain(x, y) {
  G.taps--;
  // If a chain is already active, this tap adds to it instead of starting fresh
  if (!G.chainActive) {
    G.chainActive = true;
    G.chainGenId++;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainQueue = [];
  }
  G.chainOriginX = x;
  G.chainOriginY = y;

  // Find nearest circle
  let nearestCircle = null, nearDist = Infinity;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    const d = dist(x, y, c.x, c.y);
    if (d < nearDist) { nearDist = d; nearestCircle = c; }
  }

  // Attractor Field: normal taps create brief gravity well
  if (G.upgrades.attractorField > 0) {
    const lvl = G.upgrades.attractorField;
    const aRange = 60 + lvl * 30;
    G.gravityWells.push({
      x, y,
      strength: 50 + lvl * 35,
      radius: aRange,
      life: 0.5 + lvl * 0.15,
      maxLife: 0.5 + lvl * 0.15,
      color: getCurrentPalette().accent
    });
  }

  if (nearestCircle && nearDist < MAX_TAP_DISTANCE + nearestCircle.radius) {
    // Pop the nearest circle immediately
    nearestCircle.queued = true;
    G.chainQueue.push({ circleId: nearestCircle.id, triggerTime: 0 });
  } else {
    // Phantom pop — create a temporary explosion at tap point
    phantomPop(x, y);
  }
  updateHUD();
}

function phantomPop(x, y) {
  const phantomR = getBlastRadius() * 0.7;
  createExplosion(x, y, phantomR, '#ffffff', false);
  playPhantomSound();

  // Still check if anything is in range — create links
  const blastR = phantomR + G.upgrades.novaRadius * 12;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    const d = dist(x, y, c.x, c.y);
    if (d < blastR + c.radius) {
      c.queued = true;
      const distFactor = d / (blastR + c.radius);
      const tension = getLinkTensionTime() * (0.6 + distFactor * 0.4) + Math.random() * 0.08;
      G.chainLinks.push({
        srcX: x, srcY: y,
        targetId: c.id,
        color: '#ffffff',
        timer: 0,
        duration: tension
      });
    }
  }

  if (G.chainLinks.length === 0 && G.chainQueue.length === 0) {
    // Nothing hit, chain ends immediately
    G.chainActive = false;
  }
}

function popCircle(circleId) {
  const circle = findCircleById(circleId);
  if (!circle || circle.popped) return;

  // VOID CRACK orbs: first hit cracks them + creates gravity well pulling orbs in
  if (circle.armored && circle.armorHP > 1) {
    circle.armorHP = 1;
    circle.queued = false; // un-queue so next blast can re-target
    createExplosion(circle.x, circle.y, circle.radius * 2, '#9040ff', true);
    G.shakeAmount = Math.max(G.shakeAmount, 3);
    // Gravity well on crack — pulls nearby orbs inward for juicy chain potential
    G.gravityWells.push({
      x: circle.x, y: circle.y,
      strength: 180,
      radius: getBlastRadius() * 1.8,
      life: 0.8,
      maxLife: 0.8,
      color: '#8030ff'
    });
    playVoidCrackSound();
    return; // don't pop yet
  }
  // VOID CRACK pop: second hit — repulsion burst pushes orbs outward
  if (circle.armored && circle.armorHP === 1) {
    const repulseR = getBlastRadius() * 1.5;
    for (let i = 0; i < G.circles.length; i++) {
      const other = G.circles[i];
      if (other.popped || !other.alive || other.id === circle.id) continue;
      const d = dist(circle.x, circle.y, other.x, other.y);
      if (d < repulseR && d > 3) {
        const dx = other.x - circle.x, dy = other.y - circle.y;
        const pushStr = (1 - d / repulseR) * 250;
        other.vx += (dx / d) * pushStr;
        other.vy += (dy / d) * pushStr;
      }
    }
    createExplosion(circle.x, circle.y, repulseR, '#c060ff', false);
    G.shakeAmount = Math.max(G.shakeAmount, 5);
  }

  circle.popped = true;
  circle.tethered = false; // release tether on pop
  G.chainCount++;
  // Track pop position for directional respawn bias
  G.popCenterX = G.popCenterX * 0.9 + circle.x * 0.1;
  G.popCenterY = G.popCenterY * 0.9 + circle.y * 0.1;
  G.popTrackCount++;
  // XP scales with generation AND orb size — bigger orbs reward more, smaller much less
  // Diminishing returns after 15 pops (was 20)
  const xpValues = [1, 0.5, 0.25, 0.15, 0.08, 0.04];
  const sizeXpScale = Math.max(0.15, (circle.radius / BASE_CIRCLE_RADIUS) * 0.6);
  const baseXp = circle.shrapnel ? 0.15 : (xpValues[circle.generation] || 0.15);
  const dimFactor = G.chainCount <= 12 ? 1.0 : 12 / G.chainCount;
  // EXPANSE: ancient orbs worth 2× XP (fewer but heavier)
  const expanseXpMult = G.biomeOverride === 2 ? 2.0 : 1.0;
  G.chainXpValue += baseXp * sizeXpScale * dimFactor * expanseXpMult;

  // Calculate blast radius (scales with level AND orb size)
  const baseR = getBlastRadius();
  const novaBonus = G.upgrades.novaRadius * 5;
  const sizeScale = circle.radius / BASE_CIRCLE_RADIUS; // 1.0 for normal, up to 2.5 for merged
  let blastR = (baseR + novaBonus) * (0.7 + 0.3 * sizeScale);
  if (circle.volatile) blastR *= 3;

  // Super Cell: create persistent gravity well + Phase 5 implosion
  if (circle.superCell) {
    const tetherCount = circle.scTethers ? circle.scTethers.length : 0;
    // Gravity well strength scales with remaining tethers
    const implodeStr = tetherCount > 0 ? SC_GRAVITY_STRENGTH * (1 + tetherCount * 0.5) : SC_GRAVITY_STRENGTH;
    const implodeLife = tetherCount > 0 ? SC_GRAVITY_LIFE * (1 + tetherCount * 0.3) : SC_GRAVITY_LIFE;
    G.gravityWells.push({
      x: circle.x, y: circle.y,
      strength: implodeStr,
      radius: blastR * (2.5 + tetherCount * 0.5),
      life: implodeLife,
      maxLife: implodeLife,
      color: circle.color
    });
    blastR *= 1.5; // SC has bigger blast

    // Phase 5: IMPLOSION — tethered orbs rush inward and auto-pop
    if (circle.scTethers && circle.scTethers.length > 0) {
      for (let t = 0; t < circle.scTethers.length; t++) {
        const orb = findCircleById(circle.scTethers[t].orbId);
        if (!orb || !orb.alive || orb.popped) continue;
        orb.tethered = false;
        // Launch orb toward Archon position with strong velocity
        const dx = circle.x - orb.x, dy = circle.y - orb.y;
        const d = Math.sqrt(dx * dx + dy * dy) || 1;
        const rushSpeed = 600 + d * 2;
        orb.vx = (dx / d) * rushSpeed;
        orb.vy = (dy / d) * rushSpeed;
        // Queue for delayed pop (staggered timing for dramatic effect)
        orb.queued = true;
        const impDelay = 0.08 + t * 0.06 + d / 1500;
        G.chainLinks.push({
          srcX: circle.x, srcY: circle.y,
          targetId: orb.id,
          color: circle.color,
          timer: 0,
          duration: impDelay
        });
      }
      circle.scTethers = [];
      const impLore = ['THE ARCHON REMEMBERS', 'FRAGMENTS REUNITE', 'WHOLENESS DEVOURS'][Math.floor(Math.random() * 3)];
      spawnFloatingText(circle.x, circle.y - circle.radius - 25, impLore, '#ffcc00', 1.8, { fontSize: 14 });
      G.shakeAmount = Math.max(G.shakeAmount, 4 + tetherCount);
    }
  }

  // Visual explosion
  createExplosion(circle.x, circle.y, blastR, circle.color, false);

  // Audio
  if (circle.superCell) {
    playSCPopSound(G.chainCount);
  } else {
    playPopSound(G.chainCount);
  }

  // Particles
  spawnPopParticles(circle.x, circle.y, circle.color);

  // Feedback escalation
  applyChainFeedback(G.chainCount);

  // Gravity Well: pull nearby orbs toward this pop — gradual falloff, scales with orb size + madness
  if (G.upgrades.gravityWell > 0) {
    const gwMadPhys = getMadnessPhysicsScale();
    const pullStrength = G.upgrades.gravityWell * 22 * sizeScale * gwMadPhys;
    const pullRange = blastR * 2.8 * gwMadPhys;
    for (let i = 0; i < G.circles.length; i++) {
      const other = G.circles[i];
      if (other.popped || !other.alive) continue;
      const d = dist(circle.x, circle.y, other.x, other.y);
      if (d < pullRange && d > 5) {
        const dx = circle.x - other.x, dy = circle.y - other.y;
        // Gradual: inverse distance with smooth edge falloff
        const edgeFade = 1 - (d / pullRange);
        const pull = pullStrength * edgeFade * edgeFade / Math.max(d, 15);
        other.x += (dx / d) * pull * d * 0.5;
        other.y += (dy / d) * pull * d * 0.5;
      }
    }
  }

  // Find neighbors in blast radius — create links instead of instant queue
  for (let i = 0; i < G.circles.length; i++) {
    const other = G.circles[i];
    if (other.popped || other.queued || !other.alive) continue;
    if (other.shrapnelImmune > 0) continue; // shrapnel needs time to fly out
    if (other.tethered) continue; // tethered to Nexus — immune to chain pops, must direct-tap
    // Fragments born during THIS chain survive it — poppable in the next chain
    if (other.chainBornId === G.chainGenId && G.chainActive) continue;
    const d = dist(circle.x, circle.y, other.x, other.y);
    if (d < blastR + other.radius) {
      // Rift Wall check — blast can't propagate through walls
      let blocked = false;
      for (let wi = 0; wi < G.riftWalls.length; wi++) {
        const rw = G.riftWalls[wi];
        if (rw.hp <= 0) continue;
        if (lineSegmentsIntersect(circle.x, circle.y, other.x, other.y, rw.x1, rw.y1, rw.x2, rw.y2)) {
          blocked = true;
          break;
        }
      }
      if (blocked) continue;

      other.queued = true;
      const distFactor = d / (blastR + other.radius);
      const tension = getLinkTensionTime() * (0.6 + distFactor * 0.4) + Math.random() * 0.08;
      G.chainLinks.push({
        srcX: circle.x, srcY: circle.y,
        targetId: other.id,
        color: circle.color,
        timer: 0,
        duration: tension
      });
    }
  }

  // Boss damage check — chain pops can hurt the boss (size-scaled)
  damageBoss(circle.x, circle.y, blastR, circle.radius);

  // Rift Wall damage — blasts hitting walls weaken them
  damageRiftWall(circle.x, circle.y, blastR);

  // Echo Burst
  if (G.upgrades.echoBurst > 0 && Math.random() < G.upgrades.echoBurst * 0.08) {
    const echoR = blastR * 1.3;
    createExplosion(circle.x, circle.y, echoR, circle.color, true);
    for (let i = 0; i < G.circles.length; i++) {
      const other = G.circles[i];
      if (other.popped || other.queued || !other.alive) continue;
      if (other.shrapnelImmune > 0) continue;
      if (other.chainBornId === G.chainGenId && G.chainActive) continue;
      const d = dist(circle.x, circle.y, other.x, other.y);
      if (d < echoR + other.radius) {
        // Rift Wall check for echo burst too
        let echoBlocked = false;
        for (let wi = 0; wi < G.riftWalls.length; wi++) {
          const rw = G.riftWalls[wi];
          if (rw.hp <= 0) continue;
          if (lineSegmentsIntersect(circle.x, circle.y, other.x, other.y, rw.x1, rw.y1, rw.x2, rw.y2)) {
            echoBlocked = true; break;
          }
        }
        if (echoBlocked) continue;

        other.queued = true;
        const tension = getLinkTensionTime() * 0.5 + Math.random() * 0.06;
        G.chainLinks.push({
          srcX: circle.x, srcY: circle.y,
          targetId: other.id,
          color: circle.color,
          timer: 0,
          duration: tension
        });
      }
    }
  }

  // Phase 6: GRAVITY BRIDGE propagation — blast travels along bridges to connected orbs
  if (G.bridges.length > 0) {
    for (let bi = G.bridges.length - 1; bi >= 0; bi--) {
      const br = G.bridges[bi];
      let partnerId = -1;
      if (br.orbIdA === circle.id) partnerId = br.orbIdB;
      else if (br.orbIdB === circle.id) partnerId = br.orbIdA;
      if (partnerId < 0) continue;

      const partner = findCircleById(partnerId);
      if (!partner || !partner.alive || partner.popped || partner.queued) {
        G.bridges.splice(bi, 1); // remove used bridge
        continue;
      }
      if (partner.tethered) { G.bridges.splice(bi, 1); continue; } // boss-tethered immune
      if (partner.chainBornId === G.chainGenId && G.chainActive) { G.bridges.splice(bi, 1); continue; }

      // Queue the bridged partner with short delay (cascading chain)
      partner.queued = true;
      const bridgeDelay = 0.05 + Math.random() * 0.06;
      G.chainLinks.push({
        srcX: circle.x, srcY: circle.y,
        targetId: partner.id,
        color: circle.color,
        timer: 0,
        duration: bridgeDelay
      });
      // Remove the bridge after it fires
      G.bridges.splice(bi, 1);
    }
  }

  // Compute "away from cursor" base angle for directional fragments/shrapnel/fission
  let awayAngle = Math.random() * Math.PI * 2; // fallback: random
  if (G.cursorX > 0 && G.cursorY > 0) {
    awayAngle = Math.atan2(circle.y - G.cursorY, circle.x - G.cursorX);
  }

  // Combo shrapnel: popped balls spawn 40%-size balls LAUNCHED away from cursor
  // Spawned AFTER blast-radius check so they don't get immediately queued/popped
  // These are real gameplay objects — poppable by other blasts, affected by gravity
  // Threshold scales with level (6 early → 2 late), base 2 shrapnel + combo scaling
  const shrapnelThreshold = getShrapnelThreshold();
  if (G.chainCount >= shrapnelThreshold) {
    const baseShrapnel = 1;
    const comboBonus = Math.floor(G.chainCount / 8);
    const shrapnelCount = Math.min(4, Math.floor(baseShrapnel * (1 + comboBonus * 0.4)));
    for (let s = 0; s < shrapnelCount; s++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      const spread = (shrapnelCount > 1) ? ((s / (shrapnelCount - 1)) - 0.5) * Math.PI : 0;
      const angle = awayAngle + spread + (Math.random() - 0.5) * 0.5;
      const speed = 400 + Math.random() * 250;
      const sc = createCircle(circle.x, circle.y);
      sc.radius = BASE_CIRCLE_RADIUS * 0.4 + Math.random() * 3;
      sc.baseRadius = sc.radius;
      sc.generation = 1;
      sc.superCell = false;
      sc.spikeCount = 0;
      sc.scCooldown = 999;
      sc.armored = false; sc.armorHP = 0;  // shrapnel never armored
      sc.vx = Math.cos(angle) * speed;
      sc.vy = Math.sin(angle) * speed;
      sc.spawnAnim = 0;
      sc.shrapnel = true;
      sc.shrapnelImmune = 0.35; // immune to blasts for 350ms so it can fly out visibly
      sc.chainBornId = G.chainGenId; // survives this chain, poppable in next
      G.circles.push(sc);
    }
  }

  // Fission — spawns mini orbs that fly outward. Cannot chain-fission (no recursion).
  // Only non-fission orbs trigger fission; fission orbs themselves do NOT spawn more.
  // Capped at 2 orbs max. Small, fast, long immunity — spread out, don't instant-chain.
  if (G.upgrades.fission > 0 && !circle.fissionSpawn) {
    const fissionCount = Math.min(2, G.upgrades.fission); // max 2 (was 3)
    for (let i = 0; i < fissionCount; i++) {
      if (G.circles.length < MAX_CIRCLES) {
        const fSpread = (fissionCount > 1) ? ((i / (fissionCount - 1)) - 0.5) * Math.PI * 0.8 : 0;
        const angle = awayAngle + fSpread + (Math.random() - 0.5) * 0.4;
        const speed = 150 + Math.random() * 80; // even faster escape
        const fc = createCircle(circle.x, circle.y);
        fc.radius = BASE_CIRCLE_RADIUS * 0.4; // tiny (was 0.5)
        fc.baseRadius = fc.radius;
        fc.generation = Math.max(3, circle.generation + 1); // gen-3 minimum (minimal XP)
        fc.superCell = false;
        fc.spikeCount = 0;
        fc.scCooldown = 999;
        fc.armored = false; fc.armorHP = 0;
        fc.vx = Math.cos(angle) * speed;
        fc.vy = Math.sin(angle) * speed;
        fc.spawnAnim = 0.5;
        fc.shrapnel = true;      // reduced XP
        fc.fissionSpawn = true;   // prevents recursive fission
        fc.shrapnelImmune = 0.8;  // 800ms immunity — must fly far before catchable
        fc.chainBornId = G.chainGenId; // survives this chain, poppable in next
        G.circles.push(fc);
      }
    }
  }

  // Aftershock — leave lingering hot zone
  if (G.upgrades.aftershock > 0) {
    if (G.aftershocks.length < MAX_AFTERSHOCKS) {
      G.aftershocks.push({
        x: circle.x, y: circle.y,
        radius: blastR * 0.7,
        life: G.upgrades.aftershock * 0.5,
        maxLife: G.upgrades.aftershock * 0.5,
        color: circle.color
      });
    }
  }

  // FRACTURING SYSTEM: Orbs shatter into smaller pieces on pop
  // Fragments fly AWAY from cursor position (cursor-relative direction)
  // Gen 0 (100%) → gen-1 (60%) → gen-2 (35%) → gen-3 (20%) → gen-4 (12%) → gen-5 (7%)
  const nextGen = circle.generation + 1;
  const fracCounts = getFractureCounts();
  const fracCount = fracCounts[circle.generation] || 0;
  if (nextGen <= 5 && fracCount > 0 && G.circles.length < MAX_CIRCLES - 2) {
    const FRAC_SCALES = [1.0, 0.6, 0.35, 0.20, 0.12, 0.07];
    const scale = FRAC_SCALES[nextGen];
    const count = fracCount;
    const speed = 50 + (nextGen * 15);
    for (let m = 0; m < count; m++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      // Spread fragments in a cone centered on "away from cursor" direction
      const spread = (count > 1) ? ((m / (count - 1)) - 0.5) * Math.PI * 0.8 : 0;
      const angle = awayAngle + spread + (Math.random() - 0.5) * 0.6;
      const spawnDist = 6 + Math.random() * 10;
      const mx = circle.x + Math.cos(angle) * spawnDist;
      const my = circle.y + Math.sin(angle) * spawnDist;
      const mc = createCircle(mx, my);
      mc.radius = BASE_CIRCLE_RADIUS * scale + Math.random() * 2;
      mc.baseRadius = mc.radius;
      mc.generation = nextGen;
      mc.superCell = false;
      mc.spikeCount = 0;
      mc.scCooldown = 999;
      mc.armored = false; mc.armorHP = 0;  // fragments never armored
      mc.spawnAnim = 0;
      mc.shrapnelImmune = 0.2; // brief immunity so they fly out visibly
      mc.chainBornId = G.chainGenId; // survives this chain, poppable in next
      mc.vx = Math.cos(angle) * speed;
      mc.vy = Math.sin(angle) * speed;
      G.circles.push(mc);
    }
  }

  // CASCADE BURST: gen-1 and gen-2 orbs spawn bonus micro-fragments — directional
  const cascadeCount = getCascadeBurstCount(circle.generation);
  if (cascadeCount > 0 && G.circles.length < MAX_CIRCLES - 2) {
    const MICRO_SCALES = [0, 0.35, 0.18, 0.12]; // gen-1 bursts to 35%, gen-2 to 18%, gen-3 to 12%
    const microScale = MICRO_SCALES[circle.generation] || 0.12;
    const microGen = Math.min(4, circle.generation + 1);
    for (let cb = 0; cb < cascadeCount; cb++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      const angle = awayAngle + (Math.random() - 0.5) * Math.PI * 0.6;
      const speed = 60 + Math.random() * 40;
      const mc = createCircle(circle.x, circle.y);
      mc.radius = BASE_CIRCLE_RADIUS * microScale + Math.random() * 1.5;
      mc.baseRadius = mc.radius;
      mc.generation = microGen;
      mc.superCell = false;
      mc.spikeCount = 0;
      mc.scCooldown = 999;
      mc.armored = false; mc.armorHP = 0;
      mc.spawnAnim = 0;
      mc.shrapnelImmune = 0.25;
      mc.chainBornId = G.chainGenId; // survives this chain, poppable in next
      mc.vx = Math.cos(angle) * speed;
      mc.vy = Math.sin(angle) * speed;
      G.circles.push(mc);
    }
  }

  // Mark for removal after chain
  circle.alive = false;
}

function updateAftershocks(dt) {
  for (let a = G.aftershocks.length - 1; a >= 0; a--) {
    const as = G.aftershocks[a];
    as.life -= dt;
    if (as.life <= 0) { G.aftershocks.splice(a, 1); continue; }
    // Aftershocks pop circles that drift into hot zones
    if (G.chainActive) {
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (c.popped || c.queued || !c.alive) continue;
        if (c.shrapnelImmune > 0) continue;
        if (c.chainBornId === G.chainGenId) continue; // chain-born particles immune this chain
        const d = dist(as.x, as.y, c.x, c.y);
        if (d < as.radius + c.radius) {
          c.queued = true;
          G.chainQueue.push({ circleId: c.id, triggerTime: G.chainTimer + Math.random() * 0.05 });
        }
      }
    }
  }
}

function updateGravityWells(dt) {
  const gwMadPhys = getMadnessPhysicsScale();
  for (let i = G.gravityWells.length - 1; i >= 0; i--) {
    const gw = G.gravityWells[i];
    gw.life -= dt;
    if (gw.life <= 0) { G.gravityWells.splice(i, 1); continue; }
    const progress = 1 - (gw.life / gw.maxLife);
    const pullMult = Math.min(1, progress * 2); // ramps up over first half of life
    for (let j = 0; j < G.circles.length; j++) {
      const c = G.circles[j];
      if (c.popped || !c.alive) continue;
      const d = dist(gw.x, gw.y, c.x, c.y);
      if (d < gw.radius * gwMadPhys && d > 3) {
        const dx = gw.x - c.x, dy = gw.y - c.y;
        const accel = gw.strength * gwMadPhys * pullMult * dt / Math.max(d, 30);
        c.vx += (dx / d) * accel;
        c.vy += (dy / d) * accel;
      }
    }
  }
}

// ==================================================
// BLACK HOLE — Star Control style gravity + compression pop mechanic
// Pulls orbs inward. Orbs compressed near the core build up "mass".
// When enough mass accumulates → free chain pop (gravitational collapse).
// Orbs that touch the event horizon get swallowed (destroyed) and add mass.
// The player can also tap the black hole to trigger an early collapse.
// ==================================================
const BH_VISUAL_RADIUS = 25;           // smaller, subtler visual
const BH_GRAVITY_RADIUS = 567;         // pull range — wider to catch more orbs (+35%)
const BH_STRENGTH = 1485;               // strong pull for visible orbits (+35%)
const BH_TANGENT_STRENGTH = 0.55;      // tangential force ratio — creates orbital spin
const BH_COLLAPSE_THRESHOLD = 5;       // swallowed orbs needed for free pop
const BH_SWALLOW_RADIUS_MULT = 0.5;    // fraction of visual radius = swallow zone (smaller = harder to swallow)

function createBlackHoleObj() {
  const margin = 80;
  const bhL = G.gameLeft || 0, bhT = G.gameTop || 0;
  const bhW = G.gameW || G.W, bhH = G.gameH || G.H;
  const bh = {
    x: bhL + margin + Math.random() * (bhW - margin * 2),
    y: bhT + margin + Math.random() * (bhH - margin * 2),
    radius: BH_VISUAL_RADIUS,
    gravityRadius: BH_GRAVITY_RADIUS,
    strength: BH_STRENGTH,
    life: 8 + Math.random() * 8,
    maxLife: 0,
    phase: Math.random() * Math.PI * 2,
    fadeIn: 0,
    mass: 0,
    collapseReady: false,
    pulseTime: 0,
    dust: []
  };
  for (let di = 0; di < 25; di++) {
    bh.dust.push({
      angle: Math.random() * Math.PI * 2,
      dist: 0.3 + Math.random() * 0.6,
      size: 0.5 + Math.random() * 1.5,
      speed: 0.3 + Math.random() * 0.8
    });
  }
  bh.maxLife = bh.life;
  return bh;
}

function updateBlackHole(dt) {
  const madness = getMadnessAmount();
  // Max simultaneous black holes: 1 below 75%, ramps to 4 at 100%
  const maxBH = madness >= 0.75 ? 1 + Math.floor((madness - 0.75) / 0.25 * 3) : 1;
  // Spawn interval: shorter at high madness (more frequent spawns)
  const spawnInterval = madness >= 0.75 ? 15 + Math.random() * 10 : 25 + Math.random() * 20;

  // Spawn logic
  if (G.blackHoles.length < maxBH) {
    G.blackHoleTimer += dt;
    if (G.blackHoleTimer > spawnInterval) {
      G.blackHoleTimer = 0;
      const bh = createBlackHoleObj();
      G.blackHoles.push(bh);
      spawnFloatingText(bh.x, bh.y - 40, 'THE VOID OPENS', '#8050cc');
    }
  }

  if (G.blackHoles.length === 0) return;

  const bhMadPhys = getMadnessPhysicsScale();

  // Update each black hole
  for (let bhi = G.blackHoles.length - 1; bhi >= 0; bhi--) {
    const bh = G.blackHoles[bhi];
    bh.phase += dt * 1.2;

    // Update star dust
    if (bh.dust) {
      for (let di = 0; di < bh.dust.length; di++) {
        const d = bh.dust[di];
        d.angle += d.speed * dt * 2.5;
        d.dist -= dt * 0.15;
        if (d.dist < 0.05) {
          d.dist = 0.7 + Math.random() * 0.25;
          d.angle = Math.random() * Math.PI * 2;
          d.size = 0.5 + Math.random() * 1.5;
          d.speed = 0.3 + Math.random() * 0.8;
        }
      }
    }

    if (bh.fadeIn < 1) bh.fadeIn = Math.min(1, bh.fadeIn + dt / 1.2);

    const horrorRate = 0.0015 + bh.mass * 0.001;
    G.horrorBoost = Math.min(0.35, G.horrorBoost + horrorRate * dt);

    bh.life -= dt;
    if (bh.life <= 0) {
      if (bh.mass >= BH_COLLAPSE_THRESHOLD) triggerBlackHoleCollapse(bh);
      G.blackHoles.splice(bhi, 1);
      continue;
    }

    const fadeOut = bh.life < 1.5 ? bh.life / 1.5 : 1;
    const fadeMult = bh.fadeIn * fadeOut;

    if (bh.mass >= BH_COLLAPSE_THRESHOLD && !bh.collapseReady) {
      bh.collapseReady = true;
      bh.pulseTime = 0;
    }
    if (bh.collapseReady) {
      bh.pulseTime += dt;
      if (bh.pulseTime > 3) {
        triggerBlackHoleCollapse(bh);
        G.blackHoles.splice(bhi, 1);
        continue;
      }
    }

    // Gravity pull on orbs
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = bh.x - c.x;
      const dy = bh.y - c.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d > bh.gravityRadius * bhMadPhys || d < 3) continue;

      const accel = bh.strength * bhMadPhys * fadeMult * dt / Math.max(d, 20);
      const nx = dx / d;
      const ny = dy / d;
      c.vx += nx * accel;
      c.vy += ny * accel;
      const tangentAccel = accel * BH_TANGENT_STRENGTH;
      c.vx += (-ny) * tangentAccel;
      c.vy += (nx) * tangentAccel;

      if (d < bh.radius * BH_SWALLOW_RADIUS_MULT) {
        c.alive = false;
        c.popped = true;
        bh.mass++;
        bh.radius = BH_VISUAL_RADIUS + bh.mass * 3;
        bh.gravityRadius = BH_GRAVITY_RADIUS + bh.mass * 15;
        bh.strength = BH_STRENGTH + bh.mass * 80;
        spawnPopParticles(c.x, c.y, c.color);
        if (bh.mass >= BH_COLLAPSE_THRESHOLD) {
          spawnFloatingText(bh.x, bh.y - 30, 'TAP TO COLLAPSE', '#e0a0ff', 1.2, { fontSize: 13 });
        } else {
          spawnFloatingText(bh.x, bh.y - 20, `${Math.floor(bh.mass)}/${BH_COLLAPSE_THRESHOLD}`, '#c080ff', 0.9, { fontSize: 11 });
        }
      }
    }

    // Gentle pull on bombs
    for (let i = 0; i < G.bombs.length; i++) {
      const b = G.bombs[i];
      const dx = bh.x - b.x;
      const dy = bh.y - b.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < bh.gravityRadius && d > 8) {
        const pull = bh.strength * 0.2 * fadeMult * dt / Math.max(d, 20);
        b.x += (dx / d) * pull;
        b.y += (dy / d) * pull;
      }
    }
  }

  // Compat: set G.blackHole to first active hole (for systems that check it)
  G.blackHole = G.blackHoles.length > 0 ? G.blackHoles[0] : null;
}

// Tapping a black hole triggers an early collapse
function tryTapBlackHole(x, y) {
  for (let bhi = 0; bhi < G.blackHoles.length; bhi++) {
    const bh = G.blackHoles[bhi];
    const d = dist(x, y, bh.x, bh.y);
    if (d <= bh.radius * 2.5) {
      triggerBlackHoleCollapse(bh);
      G.blackHoles.splice(bhi, 1);
      G.blackHole = G.blackHoles.length > 0 ? G.blackHoles[0] : null;
      return true;
    }
  }
  return false;
}

function triggerBlackHoleCollapse(bh) {
  // Gravitational collapse: free chain pop centered on the black hole
  // Blast radius scales with accumulated mass
  const baseBlast = BASE_BLAST_RADIUS * 0.8;
  const massBonus = bh.mass * 12;
  const collapseR = baseBlast + massBonus;

  // Collapse permanently pushes the world toward horror (halved rates + lower cap)
  G.horrorBoost = Math.min(0.35, G.horrorBoost + 0.01 + bh.mass * 0.003);

  // Visual explosion
  createExplosion(bh.x, bh.y, collapseR, '#a060ff', false);

  // Sound
  playPopSound(bh.mass);

  // Particles
  spawnPopParticles(bh.x, bh.y, '#a060ff');

  // Screen feedback scales with mass
  if (bh.mass >= 3) {
    G.shakeAmount = Math.min(12, 3 + bh.mass * 1.5);
    G.whiteGlow = Math.min(0.3, bh.mass * 0.04);
  }

  // Pop nearby orbs — this is a FREE chain (no tap cost)
  let poppedCount = 0;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    if (c.shrapnelImmune > 0) continue;
    const d = dist(bh.x, bh.y, c.x, c.y);
    if (d < collapseR + c.radius) {
      c.queued = true;
      const tension = getLinkTensionTime() * 0.5 + Math.random() * 0.1;
      G.chainLinks.push({
        srcX: bh.x, srcY: bh.y,
        targetId: c.id,
        color: '#a060ff',
        timer: 0,
        duration: tension
      });
      poppedCount++;
    }
  }

  // If we queued orbs, start a chain reaction (free — no tap deducted)
  if (poppedCount > 0 && !G.chainActive) {
    G.chainActive = true;
    G.chainGenId++;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainOriginX = bh.x;
    G.chainOriginY = bh.y;
  }

  // Floating text
  const label = bh.mass >= BH_COLLAPSE_THRESHOLD ? 'COLLAPSE' : 'SINGULARITY';
  spawnFloatingText(bh.x, bh.y - 30, label, '#c080ff');

  // Free tap reward — always at least +1, +2 if high mass
  const bhTapBonus = bh.mass >= 8 ? 2 : 1;
  G.taps += bhTapBonus;
  spawnFloatingText(bh.x, bh.y - 55, `+${bhTapBonus} TAP${bhTapBonus > 1 ? 'S' : ''}`, '#c080ff');
  playBonusTapSound();
}

// ==================================================
// SUPERMASSIVE BLACK HOLE — spawns at madness > 75%
// Enormous gravity well covering nearly the entire play area
// Creates urgency and spectacle at high madness
// ==================================================
const SBH_SPAWN_INTERVAL_MIN = 30; // seconds between spawns (30-50s)
const SBH_SPAWN_INTERVAL_MAX = 50;
const SBH_LIFETIME = 8;            // seconds alive
const SBH_COLLAPSE_MASS = 8;       // orbs needed for auto-collapse
const SBH_SWALLOW_FRAC = 0.12;     // swallow radius as fraction of visual radius

function updateSuperBlackHole(dt) {
  const madness = getMadnessAmount();

  // Only active above 75% madness
  if (madness < 0.75) {
    G.superBlackHoleTimer = 0;
    if (G.superBlackHole) {
      // Madness dropped — fade out gracefully
      G.superBlackHole.life = Math.min(G.superBlackHole.life, 1.0);
    }
    return;
  }

  // Spawn timer
  if (!G.superBlackHole) {
    G.superBlackHoleTimer += dt;
    const interval = SBH_SPAWN_INTERVAL_MIN + Math.random() * (SBH_SPAWN_INTERVAL_MAX - SBH_SPAWN_INTERVAL_MIN);
    if (G.superBlackHoleTimer < interval) return;
    G.superBlackHoleTimer = 0;

    // Spawn at a random position within the play area (biased toward center)
    const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
    const gw = G.gameW || G.W, gh = G.gameH || G.H;
    const spawnX = gcx + (Math.random() - 0.5) * gw * 0.4;
    const spawnY = gcy + (Math.random() - 0.5) * gh * 0.4;

    // Gravity radius: ~60-80% of the play area diagonal
    const areaDiag = Math.sqrt(gw * gw + gh * gh);
    const gravRadius = areaDiag * (0.55 + madness * 0.15); // 55-70% of diagonal

    // Visual radius: large but not absurd — 10-15% of shorter dimension
    const shorterDim = Math.min(gw, gh);
    const visRadius = shorterDim * 0.12;

    G.superBlackHole = {
      x: spawnX,
      y: spawnY,
      radius: visRadius,
      baseRadius: visRadius,
      gravityRadius: gravRadius,
      baseGravityRadius: gravRadius,
      strength: 3500,           // very strong base pull
      baseStrength: 3500,
      tangentRatio: 0.4,        // some orbital spin
      life: SBH_LIFETIME,
      maxLife: SBH_LIFETIME,
      fadeIn: 0,
      mass: 0,
      collapseReady: false,
      pulseTime: 0,
      dust: [],
      distortionPhase: Math.random() * Math.PI * 2,
      rumble: 0              // screen rumble intensity
    };

    // Initialize massive star dust cloud (more particles than regular BH)
    for (let di = 0; di < 60; di++) {
      G.superBlackHole.dust.push({
        angle: Math.random() * Math.PI * 2,
        dist: 0.2 + Math.random() * 0.8,
        size: 0.8 + Math.random() * 2.5,
        speed: 0.2 + Math.random() * 1.0,
        color: Math.floor(Math.random() * 5)
      });
    }

    G.superBlackHole.maxLife = G.superBlackHole.life;
    spawnFloatingText(spawnX, spawnY - 60, 'A GREAT VOID OPENS', '#ff3060');
    G.shakeAmount = Math.max(G.shakeAmount, 8);
    G.chromaticAb = Math.max(G.chromaticAb, 5);
    return;
  }

  // Update existing supermassive black hole
  const sbh = G.superBlackHole;
  sbh.distortionPhase += dt * 0.8;

  // Fade in (slower than regular — more dramatic)
  if (sbh.fadeIn < 1) sbh.fadeIn = Math.min(1, sbh.fadeIn + dt / 2.0);

  // Persistent rumble while active
  sbh.rumble = sbh.fadeIn * (0.5 + sbh.mass * 0.15);
  G.shakeAmount = Math.max(G.shakeAmount, sbh.rumble * 0.8);

  // Horror corruption (faster than regular BH, but halved for longer game)
  const sHorrorRate = 0.003 + sbh.mass * 0.0015;
  G.horrorBoost = Math.min(0.50, G.horrorBoost + sHorrorRate * dt);

  // Chromatic aberration while active
  G.chromaticAb = Math.max(G.chromaticAb, sbh.fadeIn * (2 + sbh.mass * 0.5));

  // Update star dust — faster spiral
  if (sbh.dust) {
    for (let di = 0; di < sbh.dust.length; di++) {
      const d = sbh.dust[di];
      d.angle += d.speed * dt * 3.0;
      d.dist -= dt * 0.08;
      if (d.dist < 0.05) {
        d.dist = 0.6 + Math.random() * 0.4;
        d.angle = Math.random() * Math.PI * 2;
        d.size = 0.8 + Math.random() * 2.5;
        d.speed = 0.2 + Math.random() * 1.0;
      }
    }
  }

  // Countdown life
  sbh.life -= dt;
  if (sbh.life <= 0) {
    if (sbh.mass >= 3) {
      triggerSuperBlackHoleCollapse(sbh);
    }
    G.superBlackHole = null;
    return;
  }

  const sFadeOut = sbh.life < 2.0 ? sbh.life / 2.0 : 1;
  const sFadeMult = sbh.fadeIn * sFadeOut;

  // Collapse check
  if (sbh.mass >= SBH_COLLAPSE_MASS && !sbh.collapseReady) {
    sbh.collapseReady = true;
    sbh.pulseTime = 0;
    spawnFloatingText(sbh.x, sbh.y - 40, 'TAP TO COLLAPSE!', '#ff6080');
  }
  if (sbh.collapseReady) {
    sbh.pulseTime += dt;
    if (sbh.pulseTime > 4) {
      triggerSuperBlackHoleCollapse(sbh);
      G.superBlackHole = null;
      return;
    }
  }

  // Gravity pull — VERY strong, nearly full play area
  const sMadPhys = getMadnessPhysicsScale();
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    const dx = sbh.x - c.x;
    const dy = sbh.y - c.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > sbh.gravityRadius * sMadPhys || d < 3) continue;

    // Much stronger radial pull than regular BH — 1/sqrt(d) for wider effective range
    const pullStr = sbh.strength * sMadPhys * sFadeMult * dt / Math.max(Math.sqrt(d) * 4, 10);
    const nx = dx / d;
    const ny = dy / d;
    c.vx += nx * pullStr;
    c.vy += ny * pullStr;

    // Tangential force for dramatic orbital spirals
    const tangentStr = pullStr * sbh.tangentRatio;
    c.vx += (-ny) * tangentStr;
    c.vy += (nx) * tangentStr;

    // Swallow: orb reaches inner event horizon
    if (d < sbh.radius * SBH_SWALLOW_FRAC) {
      c.alive = false;
      c.popped = true;
      sbh.mass++;
      // Grow with mass
      sbh.radius = sbh.baseRadius + sbh.mass * 5;
      sbh.gravityRadius = sbh.baseGravityRadius + sbh.mass * 20;
      sbh.strength = sbh.baseStrength + sbh.mass * 150;
      spawnPopParticles(c.x, c.y, '#ff4060');

      if (sbh.mass >= SBH_COLLAPSE_MASS) {
        if (!sbh.collapseReady) {
          sbh.collapseReady = true;
          sbh.pulseTime = 0;
          spawnFloatingText(sbh.x, sbh.y - 40, 'TAP TO COLLAPSE!', '#ff6080');
        }
      } else {
        spawnFloatingText(sbh.x, sbh.y - 25, `${Math.floor(sbh.mass)}/${SBH_COLLAPSE_MASS}`, '#ff6080');
      }
    }
  }

  // Pull bombs too — stronger than regular BH
  for (let i = 0; i < G.bombs.length; i++) {
    const b = G.bombs[i];
    const dx = sbh.x - b.x;
    const dy = sbh.y - b.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < sbh.gravityRadius && d > 8) {
      const pull = sbh.strength * 0.3 * sFadeMult * dt / Math.max(d, 20);
      b.x += (dx / d) * pull;
      b.y += (dy / d) * pull;
    }
  }
}

// Tapping the supermassive black hole triggers early collapse
function tryTapSuperBlackHole(x, y) {
  if (!G.superBlackHole) return false;
  const sbh = G.superBlackHole;
  const d = dist(x, y, sbh.x, sbh.y);
  if (d > sbh.radius * 3) return false;

  triggerSuperBlackHoleCollapse(sbh);
  G.superBlackHole = null;
  return true;
}

function triggerSuperBlackHoleCollapse(sbh) {
  const isSupernova = sbh.mass >= SBH_COLLAPSE_MASS; // fully loaded = SUPERNOVA

  // Collapse radius — supernova covers most of the play area
  const baseBlast = BASE_BLAST_RADIUS * (isSupernova ? 3.0 : 1.5);
  const massBonus = sbh.mass * (isSupernova ? 30 : 18);
  const collapseR = isSupernova
    ? Math.max(baseBlast + massBonus, Math.max(G.gameW || G.W, G.gameH || G.H) * 0.45)
    : baseBlast + massBonus;

  // Horror boost — supernova is cataclysmic (halved + lower cap for longer game)
  G.horrorBoost = Math.min(0.50, G.horrorBoost + (isSupernova ? 0.04 : 0.02) + sbh.mass * 0.004);

  if (isSupernova) {
    // SUPERNOVA — triple explosion cascade, screen-filling white blast
    createExplosion(sbh.x, sbh.y, collapseR, '#ffffff', false);
    createExplosion(sbh.x, sbh.y, collapseR * 0.7, '#ffe080', false);
    createExplosion(sbh.x, sbh.y, collapseR * 0.4, '#ff4060', false);
    // Spawn radial burst explosions outward
    for (let a = 0; a < 8; a++) {
      const angle = (a / 8) * Math.PI * 2;
      const bx = sbh.x + Math.cos(angle) * collapseR * 0.5;
      const by = sbh.y + Math.sin(angle) * collapseR * 0.5;
      createExplosion(bx, by, collapseR * 0.3, '#ff8040', false);
    }
  } else {
    // Regular collapse — double burst
    createExplosion(sbh.x, sbh.y, collapseR, '#ff2050', false);
    createExplosion(sbh.x, sbh.y, collapseR * 0.6, '#ffffff', false);
  }

  // Sound + dramatic screen effects — supernova = maximum everything
  playBossDeathSound();
  G.shakeAmount = Math.max(G.shakeAmount, isSupernova ? 25 : 8 + sbh.mass * 2);
  G.whiteGlow = isSupernova ? 1.0 : Math.min(0.6, 0.2 + sbh.mass * 0.05);
  G.chromaticAb = Math.max(G.chromaticAb, isSupernova ? 15 : 6 + sbh.mass);

  // Pop everything in blast radius — free chain
  let poppedCount = 0;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    if (c.shrapnelImmune > 0) continue;
    const d = dist(sbh.x, sbh.y, c.x, c.y);
    if (d < collapseR + c.radius) {
      c.queued = true;
      const tension = getLinkTensionTime() * (isSupernova ? 0.2 : 0.4) + Math.random() * 0.08;
      G.chainLinks.push({
        srcX: sbh.x, srcY: sbh.y,
        targetId: c.id,
        color: isSupernova ? '#ffffff' : '#ff4060',
        timer: 0,
        duration: tension
      });
      poppedCount++;
    }
  }

  if (poppedCount > 0 && !G.chainActive) {
    G.chainActive = true;
    G.chainGenId++;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainOriginX = sbh.x;
    G.chainOriginY = sbh.y;
  }

  // Floating text
  const sLabel = isSupernova ? '☀ SUPERNOVA ☀' : 'THE VOID RUPTURES';
  spawnFloatingText(sbh.x, sbh.y - 40, sLabel, isSupernova ? '#ffffff' : '#ff3060');

  // Tap reward — supernova gives massive bonus
  const sTapBonus = isSupernova ? Math.max(5, Math.min(10, 3 + Math.floor(sbh.mass * 0.8))) :
    Math.max(2, Math.min(5, 1 + Math.floor(sbh.mass * 0.5)));
  G.taps += sTapBonus;
  spawnFloatingText(sbh.x, sbh.y - 70, `+${sTapBonus} TAPS`, isSupernova ? '#ffe080' : '#ff8090');
  playBonusTapSound();

  // Damage boss if present — supernova deals double damage
  if (G.boss && G.boss.state !== 'dying') {
    const bossHits = isSupernova ? Math.min(6, sbh.mass) : Math.min(3, sbh.mass);
    for (let dmg = 0; dmg < bossHits; dmg++) {
      damageBoss(sbh.x, sbh.y, collapseR);
      G.boss.hitCooldown = 0;
    }
  }
}

// ==================================================
// MAIN BIOME: Whirlwind Effect
// Periodic tangential swirl toward center, chaotic at high madness
// ==================================================
let whirlwindTimer = 0;
let whirlwindActive = 0; // >0 = swirl in progress (seconds remaining)
let whirlwindDir = 1;    // 1=clockwise, -1=counter-clockwise

// BPM-synced PGE timing — fires on a musical beat grid with semi-random skips
const PGE_BPM = 90;                        // beats per minute (syncable to music)
const PGE_BEAT_SEC = 60 / PGE_BPM;         // ~0.6667 seconds per beat
let pgeBeatAccum = 0;                       // accumulates time toward next beat
let pgeBeatsSkipped = 0;                    // how many consecutive beats we've skipped
const PGE_MIN_BEATS_BETWEEN = 6;           // minimum beats between PGE pulses (~4s at 90bpm)
const PGE_MAX_BEATS_BETWEEN = 14;          // maximum beats between (~9.3s)
let pgeBeatsSinceLast = 0;                  // beats since last PGE fired

function updateWhirlwind(dt) {
  // Only active in main biome (not ABYSS/EXPANSE — they have their own atmosphere)
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (isAbyss || G.biomeOverride === 2) return;

  const madness = getMadnessAmount();

  // BPM-synced trigger — accumulate time, check on each beat boundary
  pgeBeatAccum += dt;
  if (pgeBeatAccum >= PGE_BEAT_SEC) {
    pgeBeatAccum -= PGE_BEAT_SEC;
    pgeBeatsSinceLast++;

    if (whirlwindActive <= 0 && pgeBeatsSinceLast >= PGE_MIN_BEATS_BETWEEN) {
      // Probability of firing increases with each beat past minimum
      // At min beats: ~25% chance. Guaranteed by max beats.
      const beatsPast = pgeBeatsSinceLast - PGE_MIN_BEATS_BETWEEN;
      const maxRange = PGE_MAX_BEATS_BETWEEN - PGE_MIN_BEATS_BETWEEN;
      const fireChance = beatsPast >= maxRange ? 1.0 : 0.25 + 0.75 * (beatsPast / maxRange);
      if (Math.random() < fireChance) {
        // Duration: 2 beats at low madness, up to 4 beats at high (musical timing)
        const beatDur = 2 + madness * 2;
        whirlwindActive = beatDur * PGE_BEAT_SEC;
        pgeBeatsSinceLast = 0;
        whirlwindDir = Math.random() < 0.5 ? 1 : -1;
      }
    }
  }

  if (whirlwindActive > 0) {
    const maxDur = (2 + madness * 2) * PGE_BEAT_SEC;
    whirlwindActive -= dt;
    const waveStr = Math.sin((maxDur - whirlwindActive) / maxDur * Math.PI); // sine pulse
    const cx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const cy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = c.x - cx, dy = c.y - cy;
      const d = Math.sqrt(dx * dx + dy * dy) + 1;

      // Reduced strength: 0.8× at 0% madness → 2.0× at 100% (was 1.25→3.0)
      const swirlMadMult = 0.8 + madness * 1.2;
      const swirlStr = waveStr * 35 * getMadnessPhysicsScale() * swirlMadMult * dt * Math.min(1, d / 200);
      // Tangential: perpendicular to radial direction
      const tx = -dy / d * whirlwindDir;
      const ty = dx / d * whirlwindDir;
      c.vx += tx * swirlStr;
      c.vy += ty * swirlStr;
      // Slight inward pull
      c.vx -= (dx / d) * swirlStr * 0.25;
      c.vy -= (dy / d) * swirlStr * 0.25;

      // At high madness: add chaotic jitter
      if (madness > 0.3) {
        const chaos = (madness - 0.3) * 20 * dt * waveStr;
        c.vx += (Math.random() - 0.5) * chaos;
        c.vy += (Math.random() - 0.5) * chaos;
      }
    }
  }

  // Black hole vortex: when black holes are active, create persistent localized swirl
  for (let bhi = 0; bhi < G.blackHoles.length; bhi++) {
    const bh = G.blackHoles[bhi];
    if (bh.fadeIn <= 0.5) continue;
    const bhFade = bh.fadeIn * (bh.life < 1.5 ? bh.life / 1.5 : 1);
    const vortexRange = bh.gravityRadius * 0.8;
    const vortexStr = (30 + madness * 80) * bhFade * dt;
    const vortexDir = Math.sign(Math.sin(bh.phase * 0.3)) || 1;

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = c.x - bh.x, dy = c.y - bh.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < 3 || d > vortexRange) continue;
      const falloff = 1 - d / vortexRange;
      const sStr = vortexStr * falloff * falloff;
      const nx = dx / d, ny = dy / d;
      c.vx += (-ny) * vortexDir * sStr;
      c.vy += (nx) * vortexDir * sStr;
    }
  }
}

// ==================================================
// ABYSS MECHANIC: Abyssal Pressure Waves
// Periodic crushing waves push all orbs toward screen center
// Creates dense clusters for chain reactions
// ==================================================
let abyssPressureTimer = 0;
let abyssPressureWave = 0; // 0 = no wave, >0 = wave in progress
let abyssBeatAccum = 0;
let abyssBeatsSinceLast = 0;

function updateAbyssalPressure(dt) {
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (!isAbyss) return;

  const abyssMad = getMadnessAmount();

  // BPM-synced pressure wave — same beat grid as B1 whirlwind
  abyssBeatAccum += dt;
  if (abyssBeatAccum >= PGE_BEAT_SEC) {
    abyssBeatAccum -= PGE_BEAT_SEC;
    abyssBeatsSinceLast++;

    if (abyssPressureWave <= 0 && abyssBeatsSinceLast >= PGE_MIN_BEATS_BETWEEN) {
      const beatsPast = abyssBeatsSinceLast - PGE_MIN_BEATS_BETWEEN;
      const maxRange = PGE_MAX_BEATS_BETWEEN - PGE_MIN_BEATS_BETWEEN;
      const fireChance = beatsPast >= maxRange ? 1.0 : 0.25 + 0.75 * (beatsPast / maxRange);
      if (Math.random() < fireChance) {
        const beatDur = 2 + abyssMad * 2; // 2-4 beats duration
        abyssPressureWave = beatDur * PGE_BEAT_SEC;
        abyssBeatsSinceLast = 0;
        playAbyssWooshSound();
      }
    }
  }

  if (abyssPressureWave > 0) {
    const maxDur = (2 + abyssMad * 2) * PGE_BEAT_SEC;
    abyssPressureWave -= dt;
    const waveStr = Math.sin((maxDur - abyssPressureWave) / maxDur * Math.PI); // sine pulse
    const cx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const cy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = cx - c.x, dy = cy - c.y;
      const d = Math.sqrt(dx * dx + dy * dy) + 1;
      // Reduced strength: 0.6× base → 1.5× at full madness (was 1.25→3.0)
      const abyssMadMult = 0.6 + abyssMad * 0.9;
      const pushStr = waveStr * 50 * abyssMadMult * dt * Math.min(1, d / 200);
      c.vx += (dx / d) * pushStr;
      c.vy += (dy / d) * pushStr;
    }
  }

  // Gentle underwater current — horizontal sine drift, also scales with madness
  const abyssCurMult = abyssMad < 0.1 ? 1.0 : 1.0 + Math.min(1.0, (abyssMad - 0.1) / 0.9);
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    const currentStr = 6 * abyssCurMult * dt; // reduced from 8
    const currentAngle = Math.sin(G.time * 0.1 + c.y * 0.003) * 0.3;
    c.vx += Math.cos(currentAngle) * currentStr;
    c.vy += Math.sin(currentAngle) * currentStr * 0.3;
  }
}

function renderBlackHole(ctx) {
  if (G.blackHoles.length === 0) return;
  for (let bhi = 0; bhi < G.blackHoles.length; bhi++) {
  const bh = G.blackHoles[bhi];
  const fadeOut = bh.life < 1.5 ? bh.life / 1.5 : 1;
  const alpha = bh.fadeIn * fadeOut;
  const r = bh.radius;
  if (r * alpha < 1) return;

  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';

  ctx.save();

  if (isAbyss) {
    // === ABYSS: Black Whirlpool ===
    const p = getCurrentPalette();
    const spin = G.time * 2.5; // rotation speed

    // Outer swirl field — concentric spinning rings
    for (let ring = 5; ring >= 1; ring--) {
      const ringR = r * (0.5 + ring * 0.5);
      const ringAlpha = alpha * 0.06 * (1 - ring * 0.12);
      ctx.globalAlpha = Math.max(0, ringAlpha);
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = 1.5 - ring * 0.15;
      ctx.beginPath();
      // Spiral arc segments — each ring rotates at different speed
      const segments = 3 + ring;
      for (let s = 0; s < segments; s++) {
        const startAngle = spin * (1 + ring * 0.3) + (s / segments) * Math.PI * 2;
        const arcLen = Math.PI * (0.3 + 0.15 * ring);
        ctx.arc(bh.x, bh.y, ringR, startAngle, startAngle + arcLen);
        ctx.moveTo(bh.x + Math.cos(startAngle + arcLen + 0.3) * ringR, bh.y + Math.sin(startAngle + arcLen + 0.3) * ringR);
      }
      ctx.stroke();
    }

    // Dark vortex center — deep ocean black
    ctx.globalAlpha = alpha * 0.85;
    const vortexGrad = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, r);
    vortexGrad.addColorStop(0, '#000206');
    vortexGrad.addColorStop(0.5, '#001020');
    vortexGrad.addColorStop(0.85, p.accent + '40');
    vortexGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = vortexGrad;
    ctx.beginPath();
    ctx.arc(bh.x, bh.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Foam/bubble particles spiraling around edge
    if (bh.dust) {
      const foamColors = [p.accent, p.colors[0], '#88ccdd', '#aaddee'];
      for (let s = 0; s < bh.dust.length; s++) {
        const d = bh.dust[s];
        const spiralAngle = d.angle + spin * (1.2 + d.dist * 0.8);
        const px = bh.x + Math.cos(spiralAngle) * d.dist * r * 1.2;
        const py = bh.y + Math.sin(spiralAngle) * d.dist * r * 1.2;
        ctx.globalAlpha = alpha * d.dist * 0.6;
        ctx.fillStyle = foamColors[s % foamColors.length];
        ctx.beginPath();
        ctx.arc(px, py, d.size * 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Bioluminescent edge glow
    ctx.globalAlpha = alpha * 0.2;
    ctx.strokeStyle = p.accent;
    ctx.lineWidth = 1.5 + Math.sin(spin * 0.5) * 0.5;
    ctx.beginPath();
    ctx.arc(bh.x, bh.y, r * 0.85, 0, Math.PI * 2);
    ctx.stroke();

    // Mass progress arc — clockwise fill on outer rim
    if (bh.mass > 0 && bh.mass < BH_COLLAPSE_THRESHOLD) {
      const progress = bh.mass / BH_COLLAPSE_THRESHOLD;
      const arcStart = -Math.PI / 2; // 12 o'clock
      const arcEnd = arcStart + progress * Math.PI * 2;
      ctx.globalAlpha = alpha * 0.7;
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, r * 0.95, arcStart, arcEnd);
      ctx.stroke();
      // Dim track behind the progress
      ctx.globalAlpha = alpha * 0.1;
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, r * 0.95, arcEnd, arcStart + Math.PI * 2);
      ctx.stroke();
    }

    // Collapse-ready pulse — uses biome accent
    if (bh.collapseReady) {
      const pulseT = bh.pulseTime * 3;
      const pulseAlpha = 0.15 + 0.15 * Math.sin(pulseT);
      ctx.globalAlpha = alpha * pulseAlpha;
      ctx.strokeStyle = p.colors[0];
      ctx.lineWidth = 2;
      const pulseR = r * (1.5 + 0.3 * Math.sin(pulseT * 0.7));
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, pulseR, 0, Math.PI * 2);
      ctx.stroke();
    }
  } else {
    // === DEFAULT: Black Hole ===
    // Fire shift: violet → golden/fiery between WT 50-80%
    const mad = getMadnessAmount();
    const fireT = mad <= 0.50 ? 0 : Math.min(1, (mad - 0.50) / 0.30);
    const ft = fireT * fireT; // quadratic ease-in
    // Lerp helper: blend two hex colors
    const lerpHex = (a, b, t) => {
      const ar = parseInt(a.slice(1,3),16), ag = parseInt(a.slice(3,5),16), ab = parseInt(a.slice(5,7),16);
      const br = parseInt(b.slice(1,3),16), bg = parseInt(b.slice(3,5),16), bb = parseInt(b.slice(5,7),16);
      const nr = Math.round(ar + (br - ar) * t), ng = Math.round(ag + (bg - ag) * t), nb = Math.round(ab + (bb - ab) * t);
      return '#' + ((1<<24)|(nr<<16)|(ng<<8)|nb).toString(16).slice(1);
    };

    // Colors that shift: violet → golden/fiery
    const fieldCol    = lerpHex('#6030ff', '#ff8020', ft);
    const innerCol    = lerpHex('#050008', '#0a0400', ft);
    const edgeCol     = lerpHex('#180030', '#301800', ft);
    const rimCol      = lerpHex('#7040aa', '#aa7020', ft);
    const progressCol = lerpHex('#c080ff', '#ffa040', ft);
    const pulseCol    = lerpHex('#e0a0ff', '#ffcc44', ft);

    // Subtle gravity field hint
    ctx.globalAlpha = alpha * 0.025;
    const fieldGrad = ctx.createRadialGradient(bh.x, bh.y, r, bh.x, bh.y, bh.gravityRadius * 0.6);
    fieldGrad.addColorStop(0, fieldCol);
    fieldGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = fieldGrad;
    ctx.beginPath();
    ctx.arc(bh.x, bh.y, bh.gravityRadius * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Event horizon — black center with shifting edge color
    ctx.globalAlpha = alpha * 0.9;
    const horizonGrad = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, r);
    horizonGrad.addColorStop(0, '#000000');
    horizonGrad.addColorStop(0.6, innerCol);
    horizonGrad.addColorStop(0.85, edgeCol);
    horizonGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = horizonGrad;
    ctx.beginPath();
    ctx.arc(bh.x, bh.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Star dust — tiny particles spiraling inside the event horizon
    if (bh.dust) {
      const dustColorsBase = ['#ffffff', '#aaccff', '#ffd080', '#c0a0ff'];
      const dustColorsFire = ['#ffffff', '#ffe0a0', '#ffaa30', '#ff8800'];
      for (let s = 0; s < bh.dust.length; s++) {
        const d = bh.dust[s];
        const dx = bh.x + Math.cos(d.angle) * d.dist * r;
        const dy = bh.y + Math.sin(d.angle) * d.dist * r;
        ctx.globalAlpha = alpha * d.dist * 0.8;
        ctx.fillStyle = lerpHex(dustColorsBase[s % 4], dustColorsFire[s % 4], ft);
        ctx.beginPath();
        ctx.arc(dx, dy, d.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Thin bright edge
    ctx.globalAlpha = alpha * 0.35;
    ctx.strokeStyle = rimCol;
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(bh.x, bh.y, r * 0.8, 0, Math.PI * 2);
    ctx.stroke();

    // Mass progress arc — clockwise fill on outer rim
    if (bh.mass > 0 && bh.mass < BH_COLLAPSE_THRESHOLD) {
      const progress = bh.mass / BH_COLLAPSE_THRESHOLD;
      const arcStart = -Math.PI / 2; // 12 o'clock
      const arcEnd = arcStart + progress * Math.PI * 2;
      ctx.globalAlpha = alpha * 0.7;
      ctx.strokeStyle = progressCol;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, r * 0.9, arcStart, arcEnd);
      ctx.stroke();
      // Dim track behind the progress
      ctx.globalAlpha = alpha * 0.1;
      ctx.strokeStyle = rimCol;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, r * 0.9, arcEnd, arcStart + Math.PI * 2);
      ctx.stroke();
    }

    // Collapse-ready pulse
    if (bh.collapseReady) {
      const pulseT = bh.pulseTime * 3;
      const pulseAlpha = 0.15 + 0.15 * Math.sin(pulseT);
      ctx.globalAlpha = alpha * pulseAlpha;
      ctx.strokeStyle = pulseCol;
      ctx.lineWidth = 2;
      const pulseR = r * (1.5 + 0.3 * Math.sin(pulseT * 0.7));
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, pulseR, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  ctx.restore();
  } // end for each black hole
}

function renderSuperBlackHole(ctx) {
  if (!G.superBlackHole) return;
  const sbh = G.superBlackHole;
  const fadeOut = sbh.life < 2.0 ? sbh.life / 2.0 : 1;
  const alpha = sbh.fadeIn * fadeOut;
  const r = sbh.radius;
  if (r * alpha < 1) return;

  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';

  ctx.save();

  if (isAbyss) {
    // === ABYSS: Supermassive Whirlpool (Maelstrom) ===
    const p = getCurrentPalette();
    const spin = G.time * 1.8;

    // Massive swirl field — wide spinning current rings
    for (let ring = 7; ring >= 1; ring--) {
      const ringR = r * (0.4 + ring * 0.7) + Math.sin(sbh.distortionPhase + ring * 1.5) * r * 0.1;
      const ringAlpha = alpha * 0.05 * (1 - ring * 0.08);
      ctx.globalAlpha = Math.max(0, ringAlpha);
      ctx.strokeStyle = ring <= 3 ? p.accent : p.colors[ring % 3];
      ctx.lineWidth = 2.0 - ring * 0.15;
      ctx.beginPath();
      const segments = 4 + ring;
      for (let s = 0; s < segments; s++) {
        const startAngle = spin * (0.8 + ring * 0.25) + (s / segments) * Math.PI * 2;
        const arcLen = Math.PI * (0.25 + 0.12 * ring);
        ctx.arc(sbh.x, sbh.y, ringR, startAngle, startAngle + arcLen);
        ctx.moveTo(sbh.x + Math.cos(startAngle + arcLen + 0.4) * ringR, sbh.y + Math.sin(startAngle + arcLen + 0.4) * ringR);
      }
      ctx.stroke();
    }

    // Deep abyss vortex center
    ctx.globalAlpha = alpha * 0.92;
    const vortexGrad = ctx.createRadialGradient(sbh.x, sbh.y, 0, sbh.x, sbh.y, r);
    vortexGrad.addColorStop(0, '#000104');
    vortexGrad.addColorStop(0.3, '#001018');
    vortexGrad.addColorStop(0.6, '#002030');
    vortexGrad.addColorStop(0.85, p.accent + '50');
    vortexGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = vortexGrad;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Bioluminescent accretion ring — glowing water ring
    ctx.globalAlpha = alpha * 0.2;
    ctx.globalCompositeOperation = 'lighter';
    const accrGrad = ctx.createRadialGradient(sbh.x, sbh.y, r * 0.6, sbh.x, sbh.y, r * 1.4);
    accrGrad.addColorStop(0, 'transparent');
    accrGrad.addColorStop(0.4, p.accent + '60');
    accrGrad.addColorStop(0.7, p.colors[0] + '40');
    accrGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = accrGrad;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, r * 1.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';

    // Spiraling foam/debris particles
    if (sbh.dust) {
      const foamColors = [p.accent, p.colors[0], p.colors[1], '#88ccdd', '#aaddee'];
      for (let s = 0; s < sbh.dust.length; s++) {
        const d = sbh.dust[s];
        const spiralAngle = d.angle + spin * (1.0 + d.dist * 0.6);
        const px = sbh.x + Math.cos(spiralAngle) * d.dist * r * 1.8;
        const py = sbh.y + Math.sin(spiralAngle) * d.dist * r * 1.8;
        ctx.globalAlpha = alpha * d.dist * 0.5;
        ctx.fillStyle = foamColors[d.color % foamColors.length];
        ctx.beginPath();
        ctx.arc(px, py, d.size * 1.2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Glowing vortex edge
    ctx.globalAlpha = alpha * 0.35;
    ctx.strokeStyle = p.accent;
    ctx.lineWidth = 2 + Math.sin(spin * 0.4) * 0.7;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, r * 0.85, 0, Math.PI * 2);
    ctx.stroke();

    // Collapse-ready pulse — tidal wave warning
    if (sbh.collapseReady) {
      const pulseT = sbh.pulseTime * 2.5;
      const pulseAlpha = 0.2 + 0.2 * Math.sin(pulseT);
      ctx.globalAlpha = alpha * pulseAlpha;
      ctx.strokeStyle = p.colors[0];
      ctx.lineWidth = 3;
      const pulseR = r * (1.8 + 0.5 * Math.sin(pulseT * 0.6));
      ctx.beginPath();
      ctx.arc(sbh.x, sbh.y, pulseR, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = alpha * pulseAlpha * 0.3;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(sbh.x, sbh.y, pulseR * 1.4, 0, Math.PI * 2);
      ctx.stroke();
    }
  } else {
    // === DEFAULT: Supermassive Black Hole ===
    // Fire shift: violet/red → golden/fiery between WT 50-80%
    const mad = getMadnessAmount();
    const fireT = mad <= 0.50 ? 0 : Math.min(1, (mad - 0.50) / 0.30);
    const ft = fireT * fireT;
    const lerpHex = (a, b, t) => {
      const ar = parseInt(a.slice(1,3),16), ag = parseInt(a.slice(3,5),16), ab = parseInt(a.slice(5,7),16);
      const br = parseInt(b.slice(1,3),16), bg = parseInt(b.slice(3,5),16), bb = parseInt(b.slice(5,7),16);
      const nr = Math.round(ar + (br - ar) * t), ng = Math.round(ag + (bg - ag) * t), nb = Math.round(ab + (bb - ab) * t);
      return '#' + ((1<<24)|(nr<<16)|(ng<<8)|nb).toString(16).slice(1);
    };

    // Colors that shift: red-violet → golden/fiery
    const distInner  = lerpHex('#ff1040', '#ff8020', ft);
    const distOuter  = lerpHex('#6020a0', '#aa6010', ft);
    const ringCol    = lerpHex('#a040ff', '#cc8020', ft);
    const voidMid1   = lerpHex('#020004', '#040200', ft);
    const voidMid2   = lerpHex('#0a0015', '#0f0800', ft);
    const voidEdge   = lerpHex('#200030', '#302000', ft);
    const edgeCol    = lerpHex('#ff4060', '#ffaa30', ft);
    const pulseCol   = lerpHex('#ff6080', '#ffcc44', ft);

    // Massive gravity distortion field — pulsing, ominous
    const distPulse = 0.7 + 0.3 * Math.sin(sbh.distortionPhase * 2);
    ctx.globalAlpha = alpha * 0.04 * distPulse;
    const distGrad = ctx.createRadialGradient(sbh.x, sbh.y, r * 0.5, sbh.x, sbh.y, sbh.gravityRadius * 0.7);
    distGrad.addColorStop(0, distInner);
    distGrad.addColorStop(0.4, distOuter);
    distGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = distGrad;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, sbh.gravityRadius * 0.7, 0, Math.PI * 2);
    ctx.fill();

    // Distortion rings — concentric pulsing rings
    ctx.globalAlpha = alpha * 0.06;
    ctx.strokeStyle = ringCol;
    ctx.lineWidth = 1.2;
    for (let ring = 1; ring <= 4; ring++) {
      const ringR = r * (1.5 + ring * 0.8) + Math.sin(sbh.distortionPhase + ring) * r * 0.15;
      const ringAlpha = alpha * 0.06 * (1 - ring * 0.2);
      ctx.globalAlpha = Math.max(0, ringAlpha);
      ctx.beginPath();
      ctx.arc(sbh.x, sbh.y, ringR, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Dark void center — deeper and larger than regular BH
    ctx.globalAlpha = alpha * 0.95;
    const voidGrad = ctx.createRadialGradient(sbh.x, sbh.y, 0, sbh.x, sbh.y, r);
    voidGrad.addColorStop(0, '#000000');
    voidGrad.addColorStop(0.4, voidMid1);
    voidGrad.addColorStop(0.7, voidMid2);
    voidGrad.addColorStop(0.9, voidEdge);
    voidGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = voidGrad;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Inner accretion glow — shifts from red/violet to orange/gold
    const accrInner = ft < 0.5 ? '#ff204080' : '#ff802080';
    const accrOuter = ft < 0.5 ? '#a030ff40' : '#cc801040';
    ctx.globalAlpha = alpha * 0.25;
    const accrGrad = ctx.createRadialGradient(sbh.x, sbh.y, r * 0.6, sbh.x, sbh.y, r * 1.3);
    accrGrad.addColorStop(0, 'transparent');
    accrGrad.addColorStop(0.5, accrInner);
    accrGrad.addColorStop(0.8, accrOuter);
    accrGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = accrGrad;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, r * 1.3, 0, Math.PI * 2);
    ctx.fill();

    // Star dust — larger, more dramatic particles spiraling in
    if (sbh.dust) {
      const dustColorsBase = ['#ffffff', '#ff8090', '#ffcc60', '#c0a0ff', '#80ddff'];
      const dustColorsFire = ['#ffffff', '#ffaa40', '#ffcc30', '#ff8800', '#ffe080'];
      for (let s = 0; s < sbh.dust.length; s++) {
        const d = sbh.dust[s];
        const px = sbh.x + Math.cos(d.angle) * d.dist * r * 1.5;
        const py = sbh.y + Math.sin(d.angle) * d.dist * r * 1.5;
        const pAlpha = alpha * d.dist * 0.7;
        ctx.globalAlpha = pAlpha;
        ctx.fillStyle = lerpHex(dustColorsBase[d.color % 5], dustColorsFire[d.color % 5], ft);
        ctx.beginPath();
        ctx.arc(px, py, d.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Hot bright edge
    ctx.globalAlpha = alpha * 0.45;
    ctx.strokeStyle = edgeCol;
    ctx.lineWidth = 1.5 + Math.sin(sbh.distortionPhase * 1.5) * 0.5;
    ctx.beginPath();
    ctx.arc(sbh.x, sbh.y, r * 0.85, 0, Math.PI * 2);
    ctx.stroke();

    // Collapse-ready mega pulse
    if (sbh.collapseReady) {
      const pulseT = sbh.pulseTime * 2.5;
      const pulseAlpha = 0.2 + 0.2 * Math.sin(pulseT);
      ctx.globalAlpha = alpha * pulseAlpha;
      ctx.strokeStyle = pulseCol;
      ctx.lineWidth = 3;
      const pulseR = r * (1.8 + 0.5 * Math.sin(pulseT * 0.6));
      ctx.beginPath();
      ctx.arc(sbh.x, sbh.y, pulseR, 0, Math.PI * 2);
      ctx.stroke();

      // Second outer pulse ring
      ctx.globalAlpha = alpha * pulseAlpha * 0.4;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.5;
      const outerPulseR = pulseR * 1.5;
      ctx.beginPath();
      ctx.arc(sbh.x, sbh.y, outerPulseR, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ==================================================
// MINI BLACK HOLES — Gravitational Needles
// Tiny visual (4-6px), massive gravity (6000), small pull radius (~150px)
// Objects mostly slingshot past because the target is so small.
// Spawns 3x less often than supermassives, only at 75%+ madness.
// ==================================================
const MINI_BH_SPAWN_MIN = 90;   // seconds (SBH is 30-50, so 3x rarer)
const MINI_BH_SPAWN_MAX = 150;
const MINI_BH_STRENGTH = 6000;
const MINI_BH_GRAV_RADIUS = 300;  // 2× wider pull radius (was 150)
const MINI_BH_VISUAL_RADIUS = 5;
const MINI_BH_LIFETIME_MIN = 4;
const MINI_BH_LIFETIME_MAX = 7;

function updateMiniBlackHoles(dt) {
  if (!G.miniBlackHoles) return;
  const madness = getMadnessAmount();

  // Spawn logic — only at high madness, max 1 at a time
  if (madness >= 0.75 && G.miniBlackHoles.length < 1) {
    G.miniBlackHoleTimer += dt;
    const interval = MINI_BH_SPAWN_MIN + Math.random() * (MINI_BH_SPAWN_MAX - MINI_BH_SPAWN_MIN);
    if (G.miniBlackHoleTimer >= interval) {
      G.miniBlackHoleTimer = 0;
      const margin = 60;
      const gw = G.gameW || G.W, gh = G.gameH || G.H;
      const gL = G.gameLeft || 0, gT = G.gameTop || 0;
      const mbh = {
        x: gL + margin + Math.random() * (gw - margin * 2),
        y: gT + margin + Math.random() * (gh - margin * 2),
        radius: MINI_BH_VISUAL_RADIUS,
        gravityRadius: MINI_BH_GRAV_RADIUS,
        strength: MINI_BH_STRENGTH,
        life: MINI_BH_LIFETIME_MIN + Math.random() * (MINI_BH_LIFETIME_MAX - MINI_BH_LIFETIME_MIN),
        maxLife: 0,
        fadeIn: 0,
        phase: Math.random() * Math.PI * 2,
        dust: []
      };
      mbh.maxLife = mbh.life;
      // Small dust ring
      for (let di = 0; di < 8; di++) {
        mbh.dust.push({
          angle: Math.random() * Math.PI * 2,
          dist: 0.3 + Math.random() * 0.5,
          size: 0.3 + Math.random() * 0.6,
          speed: 0.8 + Math.random() * 1.5
        });
      }
      G.miniBlackHoles.push(mbh);
      spawnFloatingText(mbh.x, mbh.y - 20, 'GRAVITATIONAL NEEDLE', '#60e0ff', 1.5, { fontSize: 11 });
    }
  }

  if (G.miniBlackHoles.length === 0) return;

  const phys = getMadnessPhysicsScale();

  for (let mi = G.miniBlackHoles.length - 1; mi >= 0; mi--) {
    const mbh = G.miniBlackHoles[mi];
    mbh.phase += dt * 3.0; // fast spin

    // Dust update
    for (let di = 0; di < mbh.dust.length; di++) {
      const d = mbh.dust[di];
      d.angle += d.speed * dt * 5;
      d.dist -= dt * 0.3;
      if (d.dist < 0.05) {
        d.dist = 0.5 + Math.random() * 0.3;
        d.angle = Math.random() * Math.PI * 2;
      }
    }

    if (mbh.fadeIn < 1) mbh.fadeIn = Math.min(1, mbh.fadeIn + dt / 0.6);

    mbh.life -= dt;
    if (mbh.life <= 0) {
      G.miniBlackHoles.splice(mi, 1);
      continue;
    }

    const fadeOut = mbh.life < 1.0 ? mbh.life : 1;
    const fadeMult = mbh.fadeIn * fadeOut;

    // Gravity pull on orbs — very strong but tiny swallow zone (objects fly past)
    // + spaghettification: orbs stretch toward the black hole
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = mbh.x - c.x;
      const dy = mbh.y - c.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d > mbh.gravityRadius * phys || d < 2) continue;

      // 1/d falloff (not 1/d²) for strong close pull, still felt at range
      const accel = mbh.strength * phys * fadeMult * dt / Math.max(d, 8);
      const nx = dx / d;
      const ny = dy / d;
      c.vx += nx * accel;
      c.vy += ny * accel;
      // Strong tangential spin — makes orbits more visible
      const tangent = accel * 0.7;
      c.vx += (-ny) * tangent;
      c.vy += (nx) * tangent;

      // Spaghettification — stretch orbs toward the black hole
      // Closer = more stretch. Max stretch at d < gravityRadius * 0.3
      const spaghettiZone = mbh.gravityRadius * 0.6;
      if (d < spaghettiZone) {
        const spaghettiT = 1 - (d / spaghettiZone); // 0 at edge, 1 at center
        const stretchAmount = 1 + spaghettiT * spaghettiT * 1.8; // max 2.8× elongation
        const squashAmount = 1 / Math.sqrt(stretchAmount);       // volume-preserving squash
        c.stretchX = stretchAmount;
        c.stretchY = squashAmount;
        c.stretchAngle = Math.atan2(dy, dx); // stretch TOWARD the black hole
      } else {
        // Gentle return to normal outside spaghetti zone
        if (c.stretchX > 1.01) {
          c.stretchX += (1 - c.stretchX) * dt * 4;
          c.stretchY += (1 - c.stretchY) * dt * 4;
        }
      }

      // Swallow only if orb somehow hits dead center (very unlikely at high speed)
      if (d < 3) {
        c.alive = false;
        c.popped = true;
        spawnPopParticles(c.x, c.y, c.color);
      }
    }
  }
}

function renderMiniBlackHoles(ctx) {
  if (!G.miniBlackHoles || G.miniBlackHoles.length === 0) return;
  for (let mi = 0; mi < G.miniBlackHoles.length; mi++) {
    const mbh = G.miniBlackHoles[mi];
    const fadeOut = mbh.life < 1.0 ? mbh.life : 1;
    const alpha = mbh.fadeIn * fadeOut;
    const r = mbh.radius;

    ctx.save();

    // Gravity distortion ring — faint pulsing circle showing pull range
    const pulseR = mbh.gravityRadius * (0.8 + 0.2 * Math.sin(mbh.phase * 2));
    ctx.globalAlpha = alpha * 0.04;
    ctx.strokeStyle = '#60e0ff';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(mbh.x, mbh.y, pulseR, 0, Math.PI * 2);
    ctx.stroke();

    // Bright accretion ring — very small, fast spinning
    ctx.globalAlpha = alpha * 0.3;
    ctx.strokeStyle = '#80d0ff';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    const ringR = r * 3;
    const segments = 4;
    for (let s = 0; s < segments; s++) {
      const a = mbh.phase * 2 + (s / segments) * Math.PI * 2;
      ctx.arc(mbh.x, mbh.y, ringR, a, a + Math.PI * 0.35);
      ctx.moveTo(mbh.x + Math.cos(a + Math.PI * 0.5) * ringR, mbh.y + Math.sin(a + Math.PI * 0.5) * ringR);
    }
    ctx.stroke();

    // Dust particles — fast spinning dots
    for (let di = 0; di < mbh.dust.length; di++) {
      const d = mbh.dust[di];
      const px = mbh.x + Math.cos(d.angle) * d.dist * r * 4;
      const py = mbh.y + Math.sin(d.angle) * d.dist * r * 4;
      ctx.globalAlpha = alpha * d.dist * 0.5;
      ctx.fillStyle = '#a0e8ff';
      ctx.beginPath();
      ctx.arc(px, py, d.size, 0, Math.PI * 2);
      ctx.fill();
    }

    // Core — intense bright point
    ctx.globalAlpha = alpha * 0.9;
    const coreGrad = ctx.createRadialGradient(mbh.x, mbh.y, 0, mbh.x, mbh.y, r);
    coreGrad.addColorStop(0, '#ffffff');
    coreGrad.addColorStop(0.4, '#80d0ff');
    coreGrad.addColorStop(0.8, '#2060a0');
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.arc(mbh.x, mbh.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Bright center dot
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(mbh.x, mbh.y, r * 0.3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

function updateChainLinks(dt) {
  for (let i = G.chainLinks.length - 1; i >= 0; i--) {
    const link = G.chainLinks[i];
    link.timer += dt;
    const target = findCircleById(link.targetId);
    if (!target || target.popped) {
      G.chainLinks.splice(i, 1);
      continue;
    }
    // Pull target toward source point
    const d = dist(link.srcX, link.srcY, target.x, target.y);
    if (d > 2) {
      const progress = Math.min(link.timer / link.duration, 1);
      const pull = LINK_PULL_STRENGTH * progress * progress * dt;
      const dx = link.srcX - target.x;
      const dy = link.srcY - target.y;
      target.x += (dx / d) * pull;
      target.y += (dy / d) * pull;
    }
    // When tension time is up, pop the target
    if (link.timer >= link.duration) {
      G.chainLinks.splice(i, 1);
      if (!target.popped) {
        G.chainQueue.push({ circleId: target.id, triggerTime: G.chainTimer });
      }
    }
  }
}

function updateChainReaction(dt) {
  if (!G.chainActive) return;

  G.chainTimer += dt;

  // If delayed blast is active, only update that (chain is frozen)
  if (G.delayedBlast) {
    updateDelayedBlast(dt);
    return;
  }

  updateChainLinks(dt);

  let poppedThisFrame = false;
  for (let i = G.chainQueue.length - 1; i >= 0; i--) {
    const entry = G.chainQueue[i];
    if (G.chainTimer >= entry.triggerTime) {
      G.chainQueue.splice(i, 1);
      const circle = findCircleById(entry.circleId);
      if (!circle || circle.popped) continue;
      popCircle(entry.circleId);
      poppedThisFrame = true;
    }
  }

  // Chain ends when queue is empty, no links active, no delayed blast, and no pops this frame
  if (G.chainQueue.length === 0 && G.chainLinks.length === 0 && !G.delayedBlast && !poppedThisFrame) {
    endChain();
  }
}

function endChain() {
  G.chainActive = false;
  G.tapTimer = G.tapTimerMax; // Reset timer after chain
  const count = G.chainCount;
  if (count > G.bestChain) G.bestChain = count;

  // Score — base = count², boosted by level multiplier (1.0 at lvl1, grows 10% per level)
  // Score: quadratic up to 30 pops, then linear growth (prevents mega-score explosions)
  const levelMult = 1 + (G.level - 1) * 0.1;
  const rawScore = count <= 30 ? count * count : (900 + (count - 30) * 30);
  // EXPANSE: 1.5× score (ancient heavy orbs are more valuable)
  const biomeScoreMult = G.biomeOverride === 2 ? 1.5 : 1.0;
  G.score += Math.floor(rawScore * levelMult * biomeScoreMult);

  // Progressive zoom: 2.0 at score 0 → 0.5 at score ~250000 (faster curve)
  G.zoomTarget = Math.max(0.5, 2.0 - G.score * (1.5 / 250000));

  // XP (shrapnel balls worth 25%)
  G.xp += Math.floor(G.chainXpValue);

  // Bonus taps — level-scaled thresholds (harder early, easier late)
  const bt = getBonusTapThresholds();
  let bonus = 0;
  if (count >= bt.big) bonus = 2;
  else if (count >= bt.mid) bonus = 1;
  else if (count >= bt.small && Math.random() < bt.smallChance) bonus = 1;

  if (bonus > 0) {
    const fuelMult = 1 + G.upgrades.chainFuel * 0.3;
    bonus = Math.ceil(bonus * fuelMult);
    G.taps += bonus;
    playBonusTapSound();
    spawnFloatingText(G.W / 2, G.H * 0.3, `+${bonus} TAP${bonus > 1 ? 'S' : ''}`, '#00ffa0');
  }

  // Clean up
  G.circles = G.circles.filter(c => c.alive && !c.popped);
  G.circles.forEach(c => { c.queued = false; });

  // FIELD CLEAR CHECK: if all orbs are gone → mega explosion + boss damage + advance
  if (G.circles.length === 0) {
    const clearCx = (G.gameLeft + G.gameRight) * 0.5 || G.W * 0.5;
    const clearCy = (G.gameTop + G.gameBottom) * 0.5 || G.H * 0.5;
    const megaR = Math.max(G.gameW || G.W, G.gameH || G.H) * 0.6;
    createExplosion(clearCx, clearCy, megaR, '#ffffff', false);
    G.shakeAmount = Math.max(G.shakeAmount, 15);
    G.whiteGlow = 1.0;
    G.chromaticAb = 8;
    playBossDeathSound();
    // Damage boss heavily (5 HP)
    if (G.boss && G.boss.state !== 'dying') {
      for (let dmg = 0; dmg < 5; dmg++) {
        damageBoss(clearCx, clearCy, megaR, BASE_CIRCLE_RADIUS * 3); // field clear = max damage
        G.boss.hitCooldown = 0; // reset cooldown between hits
      }
    }
    advanceBiome();
    spawnFloatingText(clearCx, clearCy - 50, 'FIELD CLEARED!', '#ffffff');
    // Big bonus taps for clearing the field
    G.taps += 3;
    playBonusTapSound();
    spawnFloatingText(clearCx, clearCy + 20, '+3 TAPS', '#ffffff');
  }

  // Refill
  refillCircles();

  // Check level-up
  checkLevelUp();

  // Check game over
  if (G.taps <= 0 && !G.pendingLevelUp) {
    G.state = 'game_over';
    showGameOver();
  }

  updateHUD();
}

function applyChainFeedback(chainIndex) {
  if (chainIndex >= 6) {
    G.shakeAmount = Math.min(14, 1 + (chainIndex - 6) * 0.4);
  }
  if (chainIndex >= 20) {
    G.chromaticAb = Math.min(6, 1.5 + (chainIndex - 20) * 0.3);
  }
  if (chainIndex >= 40) {
    G.whiteGlow = Math.min(0.6, 0.1 + (chainIndex - 40) * 0.04);
  }

  // Trigger tiered delayed blast at threshold crossings
  if (!G.delayedBlast) {
    let tier = 0, duration = 0, scale = 1;
    if (chainIndex === DELAYED_BLAST_MEGA) {
      tier = 3; duration = 0.75; scale = 0.05;
    } else if (chainIndex === DELAYED_BLAST_MAJOR) {
      tier = 2; duration = 0.5; scale = 0.12;
    } else if (chainIndex === DELAYED_BLAST_MINOR) {
      tier = 1; duration = 0.25; scale = 0.25;
    }
    if (tier > 0) {
      triggerDelayedBlast(tier, duration, scale);
    }
  }
}

function triggerDelayedBlast(tier, duration, targetTimeScale) {
  // Collect all pending targets (from links + queue)
  const targetIds = [];
  for (let i = 0; i < G.chainLinks.length; i++) {
    const t = findCircleById(G.chainLinks[i].targetId);
    if (t && !t.popped) {
      targetIds.push(t.id);
    }
  }
  for (let i = 0; i < G.chainQueue.length; i++) {
    const t = findCircleById(G.chainQueue[i].circleId);
    if (t && !t.popped) {
      targetIds.push(t.id);
    }
  }
  if (targetIds.length === 0) return;

  // Center the megacombo explosion on the original tap position
  G.delayedBlast = {
    tier, duration, targetTimeScale,
    timer: 0,
    centerX: G.chainOriginX, centerY: G.chainOriginY,
    targetIds,
    executed: false
  };

  // Freeze: clear queue and links so nothing pops during buildup
  G.chainQueue = [];
  G.chainLinks = [];

  // Mark targets as still queued so they don't get picked up again
  for (const id of targetIds) {
    const c = findCircleById(id);
    if (c) c.queued = true;
  }

  playDelayedBlastBuildup(tier, duration);
}

function updateDelayedBlast(dt) {
  if (!G.delayedBlast) return;
  const db = G.delayedBlast;

  // Use raw dt for buildup so slo-mo doesn't make it take forever
  db.timer += G.rawDt;

  const progress = Math.min(db.timer / db.duration, 1);

  // Slo-mo ramps down then snaps back at detonation
  G.timeScale = lerp(db.targetTimeScale, 0.02, progress * progress);

  // Pull all targets toward convergence center
  const pullForce = 80 + 200 * progress * progress;
  for (const id of db.targetIds) {
    const c = findCircleById(id);
    if (!c || c.popped) continue;
    const d = dist(db.centerX, db.centerY, c.x, c.y);
    if (d > 2) {
      const dx = db.centerX - c.x;
      const dy = db.centerY - c.y;
      c.x += (dx / d) * pullForce * G.rawDt;
      c.y += (dy / d) * pullForce * G.rawDt;
    }
  }

  // Darkening overlay intensity
  db.darkness = progress * (db.tier === 3 ? 0.6 : db.tier === 2 ? 0.4 : 0.2);

  // Execute at end
  if (db.timer >= db.duration) {
    executeDelayedBlast();
  }
}

function executeDelayedBlast() {
  const db = G.delayedBlast;
  if (!db || db.executed) return;
  db.executed = true;

  // Pop all targets simultaneously
  for (const id of db.targetIds) {
    const c = findCircleById(id);
    if (c && !c.popped) {
      popCircle(id);
    }
  }

  // Massive visual feedback based on tier
  const shakeAmt = db.tier === 3 ? 25 : db.tier === 2 ? 16 : 8;
  G.shakeAmount = shakeAmt;
  G.chromaticAb = db.tier === 3 ? 8 : db.tier === 2 ? 5 : 2;
  if (db.tier >= 2) G.whiteGlow = db.tier === 3 ? 0.8 : 0.4;

  // Big explosion at center
  const radius = db.tier === 3 ? 300 : db.tier === 2 ? 200 : 120;
  createExplosion(db.centerX, db.centerY, radius, getCurrentPalette().accent, false);

  // Shockwave: push all surviving orbs away from blast center
  const pushForce = db.tier === 3 ? 900 : db.tier === 2 ? 600 : 350;
  const pushRadius = radius * 2.5;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    const dx = c.x - db.centerX;
    const dy = c.y - db.centerY;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < pushRadius && d > 1) {
      const falloff = 1 - d / pushRadius;
      c.vx += (dx / d) * pushForce * falloff;
      c.vy += (dy / d) * pushForce * falloff;
    }
  }

  // Restore time
  G.timeScale = 1.0;

  playDelayedBlastExplosion(db.tier);

  G.delayedBlast = null;
}

// ==================================================
// SECTION 10d: BOSS SYSTEM
// ==================================================

// --- Boss Audio ---
function playBossSpawnSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(40, now);
  osc.frequency.exponentialRampToValueAtTime(200, now + 1.0);
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.linearRampToValueAtTime(0.15, now + 0.4);
  gain.gain.linearRampToValueAtTime(0.12, now + 0.8);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 1.3);
  // Sub rumble
  const sub = G.audioCtx.createOscillator();
  const subG = G.audioCtx.createGain();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(25, now);
  subG.gain.setValueAtTime(0.12, now);
  subG.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
  sub.connect(subG);
  subG.connect(G.audioCtx.destination);
  sub.start(now);
  sub.stop(now + 1.6);
}

function playBossHitSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(80, now);
  osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.25);
}

function playBossDeathSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Bass boom
  const bass = G.audioCtx.createOscillator();
  const bassG = G.audioCtx.createGain();
  bass.type = 'sine';
  bass.frequency.setValueAtTime(50, now);
  bass.frequency.exponentialRampToValueAtTime(20, now + 0.5);
  bassG.gain.setValueAtTime(0.2, now);
  bassG.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  bass.connect(bassG);
  bassG.connect(G.audioCtx.destination);
  bass.start(now);
  bass.stop(now + 0.7);
  // Mid crunch
  const mid = G.audioCtx.createOscillator();
  const midG = G.audioCtx.createGain();
  mid.type = 'sawtooth';
  mid.frequency.setValueAtTime(200, now);
  mid.frequency.exponentialRampToValueAtTime(60, now + 0.3);
  midG.gain.setValueAtTime(0.08, now);
  midG.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
  mid.connect(midG);
  midG.connect(G.audioCtx.destination);
  mid.start(now);
  mid.stop(now + 0.4);
  // High shimmer
  const hi = G.audioCtx.createOscillator();
  const hiG = G.audioCtx.createGain();
  hi.type = 'sine';
  hi.frequency.setValueAtTime(800, now + 0.1);
  hi.frequency.exponentialRampToValueAtTime(2000, now + 0.6);
  hiG.gain.setValueAtTime(0.001, now);
  hiG.gain.linearRampToValueAtTime(0.06, now + 0.15);
  hiG.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
  hi.connect(hiG);
  hiG.connect(G.audioCtx.destination);
  hi.start(now);
  hi.stop(now + 0.9);
}

// --- Wormhole: B1 Level Ending at Peak Madness ---
// After enough boss kills at near-max madness, a wormhole tears open and consumes the field.
function trySpawnWormhole() {
  if (G.wormhole) return;
  if (G.biomeOverride !== -1) return;        // B1 only (not ABYSS, not TESTLEVEL)
  if (G.bossKillCount < 4) return;           // need 2 full boss cycles (4 kills)
  if (getMadnessAmount() < 0.95) return;     // near-peak madness
  if (G.boss) return;                         // not during a boss fight

  const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
  const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;

  G.wormhole = {
    x: gcx, y: gcy,
    radius: 0,
    maxRadius: 120,
    phase: 0,
    timer: 0,
    growDuration: 4.0,
    consumeTimer: 0,
    consumeTimeout: 12.0,
    particles: [],
    orbsConsumed: 0,
    active: false,
    completed: false
  };
  for (let i = 0; i < 40; i++) {
    G.wormhole.particles.push({
      angle: Math.random() * Math.PI * 2,
      dist: 0.3 + Math.random() * 1.0,
      speed: 1.5 + Math.random() * 2.5,
      size: 1 + Math.random() * 2,
      alpha: 0.3 + Math.random() * 0.5
    });
  }
  spawnFloatingText(gcx, gcy - 40, 'THE MEMBRANE TEARS', '#d060ff', 3.0, { fontSize: 16 });
  G.shakeAmount = Math.max(G.shakeAmount, 12);
}

function updateWormhole(dt) {
  if (!G.wormhole) return;
  const w = G.wormhole;
  w.timer += dt;
  w.phase += dt * 2.5;

  // Growth phase (ease-in quadratic)
  if (w.timer < w.growDuration) {
    const t = w.timer / w.growDuration;
    w.radius = w.maxRadius * t * t;
    // Gentle gravity preview during growth
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (!c.alive || c.popped) continue;
      const dx = w.x - c.x, dy = w.y - c.y;
      const d = Math.sqrt(dx * dx + dy * dy) + 1;
      const pullStr = 30 * t * (1 / Math.sqrt(d / 50 + 1)) * dt;
      c.x += (dx / d) * pullStr;
      c.y += (dy / d) * pullStr;
    }
    // Update particles
    for (let p of w.particles) {
      p.angle += p.speed * dt;
    }
    return;
  }

  w.active = true;
  w.consumeTimer += dt;

  // Strong gravity well — pull intensifies over time
  const pullMult = Math.min(3, w.consumeTimer / 3);
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    const dx = w.x - c.x, dy = w.y - c.y;
    const d = Math.sqrt(dx * dx + dy * dy) + 1;
    const pullStr = 200 * pullMult * (1 / Math.sqrt(d / 30 + 1)) * dt;
    c.x += (dx / d) * pullStr;
    c.y += (dy / d) * pullStr;
    // Consume orbs near center
    if (d < w.radius * 0.4) {
      c.alive = false;
      c.popped = true;
      w.orbsConsumed++;
      spawnPopParticles(c.x, c.y, c.color);
    }
  }

  // Also suck in shadow balls
  if (G.shadowBalls) {
    for (let i = G.shadowBalls.length - 1; i >= 0; i--) {
      const sb = G.shadowBalls[i];
      const dx = w.x - sb.x, dy = w.y - sb.y;
      const d = Math.sqrt(dx * dx + dy * dy) + 1;
      sb.x += (dx / d) * 150 * pullMult * dt;
      sb.y += (dy / d) * 150 * pullMult * dt;
      if (d < w.radius * 0.5) G.shadowBalls.splice(i, 1);
    }
  }

  // Update particles (spiral inward)
  for (let p of w.particles) {
    p.angle += p.speed * dt;
    p.dist = Math.max(0.05, p.dist - dt * 0.12);
    if (p.dist < 0.1) {
      p.dist = 0.5 + Math.random() * 0.5;
      p.angle = Math.random() * Math.PI * 2;
    }
  }

  // Screen shake during consumption
  G.shakeAmount = Math.max(G.shakeAmount, 3 + pullMult * 2);

  // Check completion
  let aliveCount = 0;
  for (let i = 0; i < G.circles.length; i++) {
    if (G.circles[i].alive && !G.circles[i].popped) aliveCount++;
  }
  if ((aliveCount === 0 || w.consumeTimer >= w.consumeTimeout) && !w.completed) {
    w.completed = true;
    G.shakeAmount = Math.max(G.shakeAmount, 18);
    spawnFloatingText(w.x, w.y, 'REALITY CONSUMED', '#ffffff', 2.5, { fontSize: 18 });
    // Delayed biome advance for dramatic effect
    setTimeout(() => {
      G.wormhole = null;
      advanceBiome();
      spawnInitialCircles();
    }, 1500);
  }
}

function renderWormhole(ctx) {
  if (!G.wormhole) return;
  const w = G.wormhole;
  const progress = Math.min(1, w.timer / w.growDuration);
  ctx.save();

  // Outer distortion ring
  ctx.globalAlpha = 0.35 * progress;
  ctx.strokeStyle = '#a040ff';
  ctx.lineWidth = 3 + Math.sin(w.phase) * 1.5;
  ctx.beginPath();
  ctx.arc(w.x, w.y, w.radius * 1.3, 0, Math.PI * 2);
  ctx.stroke();

  // Second ring (wider, fainter)
  ctx.globalAlpha = 0.12 * progress;
  ctx.strokeStyle = '#6020c0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(w.x, w.y, w.radius * 1.7 + Math.sin(w.phase * 1.3) * 8, 0, Math.PI * 2);
  ctx.stroke();

  // Dark center void
  ctx.globalAlpha = 0.92 * progress;
  const voidGrad = ctx.createRadialGradient(w.x, w.y, 0, w.x, w.y, w.radius);
  voidGrad.addColorStop(0, 'rgba(0,0,0,1)');
  voidGrad.addColorStop(0.4, 'rgba(10,0,30,0.9)');
  voidGrad.addColorStop(0.7, 'rgba(60,15,120,0.4)');
  voidGrad.addColorStop(0.9, 'rgba(100,30,180,0.15)');
  voidGrad.addColorStop(1, 'rgba(140,50,220,0)');
  ctx.fillStyle = voidGrad;
  ctx.beginPath();
  ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
  ctx.fill();

  // Swirling particles
  for (let p of w.particles) {
    const px = w.x + Math.cos(p.angle) * w.radius * p.dist;
    const py = w.y + Math.sin(p.angle) * w.radius * p.dist;
    ctx.globalAlpha = p.alpha * progress * (0.5 + 0.5 * Math.sin(w.phase + p.angle));
    ctx.fillStyle = p.dist > 0.6 ? '#c080ff' : '#ffffff';
    ctx.beginPath();
    ctx.arc(px, py, p.size * progress, 0, Math.PI * 2);
    ctx.fill();
  }

  // Inner accretion ring (visible once active)
  if (w.active) {
    ctx.globalAlpha = 0.25 + Math.sin(w.phase * 2) * 0.1;
    ctx.strokeStyle = '#e0a0ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(w.x, w.y, w.radius * 0.3, 0, Math.PI * 2);
    ctx.stroke();

    // Spinning radial streaks
    ctx.globalAlpha = 0.15;
    for (let s = 0; s < 6; s++) {
      const a = w.phase * 1.5 + (s / 6) * Math.PI * 2;
      const innerR = w.radius * 0.2;
      const outerR = w.radius * 0.85;
      ctx.strokeStyle = s % 2 === 0 ? '#d080ff' : '#8040c0';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(w.x + Math.cos(a) * innerR, w.y + Math.sin(a) * innerR);
      ctx.lineTo(w.x + Math.cos(a + 0.15) * outerR, w.y + Math.sin(a + 0.15) * outerR);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// --- Boss Spawning (madness-gated) ---
// Phase 1: spawns at ~50% madness (half-madness) — normal boss
// Phase 2: spawns at ~90% madness (peak) — erratic, bizarre variant
// After killing both, cycle repeats with scaling difficulty
function trySpawnBoss(dt) {
  if (G.boss || G.pendingLevelUp) return;

  const madness = getMadnessAmount();

  // Determine which boss phase we're in
  // bossSpawnPhase: 0=waiting for first, 1=killed first waiting for peak, 2=both killed → cycle
  const phase = G.bossKillCount % 2; // 0=next is mid-madness, 1=next is peak-madness
  const madnessThreshold = phase === 0 ? 0.35 : 0.75;

  if (madness < madnessThreshold) return;

  // Cooldown timer after killing previous boss (10s grace period)
  G.bossTimer += dt;
  if (G.bossTimer < 10) return;
  G.bossTimer = 0;

  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  // EXPANSE: no boss yet (deferred for later)
  if (G.biomeOverride === 2) return;
  const bossType = isAbyss ? 'leviathan' : 'nexus';
  const isPeakBoss = phase === 1; // erratic variant
  const baseHP = bossType === 'leviathan' ? 10 : 8;
  const peakBonus = isPeakBoss ? 15 : 0;
  const hp = baseHP + G.level * 3 + G.bossKillCount * 2 + peakBonus;

  // Spawn at random visible game edge
  let sx, sy;
  const bL = G.gameLeft || 0, bT = G.gameTop || 0;
  const bR = G.gameRight || G.W, bB = G.gameBottom || G.H;
  const edge = Math.floor(Math.random() * 4);
  if (edge === 0) { sx = bL + Math.random() * (bR - bL); sy = bT - 60; }
  else if (edge === 1) { sx = bR + 60; sy = bT + Math.random() * (bB - bT); }
  else if (edge === 2) { sx = bL + Math.random() * (bR - bL); sy = bB + 60; }
  else { sx = bL - 60; sy = bT + Math.random() * (bB - bT); }

  // Generate eye phases — peak boss has MORE eyes, erratic blink
  const baseEyeCount = bossType === 'nexus' ? (12 + Math.floor(Math.random() * 8)) : 2;
  const eyeCount = isPeakBoss ? baseEyeCount + 10 : baseEyeCount;
  const eyePhases = [];
  for (let i = 0; i < eyeCount; i++) {
    eyePhases.push({
      angle: (i / eyeCount) * Math.PI * 2 + Math.random() * 0.8,
      dist: isPeakBoss ? (0.1 + Math.random() * 0.55) : (0.1 + Math.random() * 0.5),
      size: isPeakBoss ? (0.06 + Math.random() * 0.12) : (0.07 + Math.random() * 0.09),
      blinkPhase: Math.random() * 10,
      blinkSpeed: isPeakBoss ? (1.5 + Math.random() * 3.0) : (0.8 + Math.random() * 0.6),
      reflectAngle: Math.random() * Math.PI * 2,
      eyeVariant: Math.floor(Math.random() * 4), // 0-3: four distinct eye styles
      mouthVariant: Math.floor(Math.random() * 4) // 0-3: four distinct mouth styles (used when erratic)
    });
  }

  // Generate tentacles — peak Leviathan has MORE, longer tentacles
  const baseTentCount = bossType === 'leviathan' ? (4 + Math.floor(Math.random() * 3)) : 0;
  const tentCount = isPeakBoss ? baseTentCount + 3 : baseTentCount;
  const tentacles = [];
  for (let i = 0; i < tentCount; i++) {
    tentacles.push({
      angle: (i / tentCount) * Math.PI * 2 + Math.random() * 0.3,
      length: isPeakBoss ? 1.4 : 1.0,
      hp: isPeakBoss ? 3 : 2,
      maxHp: isPeakBoss ? 3 : 2,
      grabTarget: null,
      regrowTimer: 0,
      phase: Math.random() * Math.PI * 2
    });
  }

  G.boss = {
    type: bossType,
    x: sx, y: sy,
    targetX: G.W * (0.3 + Math.random() * 0.4),
    targetY: G.H * (0.3 + Math.random() * 0.4),
    radius: isPeakBoss ? 140 : 55,
    hp: hp, maxHp: hp,
    phase: 0,
    spawnAnim: 1.0,
    state: 'idle',
    stateTimer: isPeakBoss ? 1.0 : 3 + Math.random() * 2,
    hitCooldown: 0,
    hitFlash: 0,
    eyePhases: eyePhases,
    tentacles: tentacles,
    mawOpen: 0,
    orbitAngle: Math.random() * Math.PI * 2,
    dyingTimer: 0,
    erratic: isPeakBoss,  // flag for erratic behavior
    // Nexus shield tethers (Phase 2 mechanic)
    tethers: [],            // array of { orbId, pulsePhase }
    shieldUp: bossType === 'nexus',  // Nexus starts shielded
    shieldTimer: 0,         // countdown: when shieldUp=false, time until regen
    tetherCooldown: 1.5,    // initial delay before first tethers form
    // Leviathan bloat/burst (Phase 3 mechanic)
    orbsEaten: 0,           // total orbs consumed
    bloatState: 'none',     // 'none' | 'bloated'
    bloatTimer: 0,          // countdown during bloat (3s window)
    bloatOrbsHeld: 0        // orbs eaten since last bloat cycle
  };

  const name = isPeakBoss
    ? (bossType === 'nexus' ? 'THE NEXUS HUNGERS' : 'THE LEVIATHAN DEVOURS')
    : (bossType === 'nexus' ? 'A NEXUS FORMS' : 'THE LEVIATHAN STIRS');
  spawnFloatingText(G.W / 2, G.H * 0.3, name, bossType === 'nexus' ? '#d050ff' : '#00e5ff');
  playBossSpawnSound();
  G.shakeAmount = Math.max(G.shakeAmount, isPeakBoss ? 12 : 6);
}

// --- Boss Update ---
function updateBoss(dt) {
  if (!G.boss) {
    trySpawnBoss(dt);
    return;
  }

  const b = G.boss;
  b.phase += dt;
  b.hitCooldown = Math.max(0, b.hitCooldown - dt);
  b.hitFlash = Math.max(0, b.hitFlash - dt * 5);

  // Boss slowly regenerates health — forces player to focus on boss
  if (b.state !== 'dying' && b.hp < b.maxHp && b.hitCooldown <= 0) {
    b.regenTimer = (b.regenTimer || 0) + dt;
    const regenRate = b.erratic ? 4.0 : 6.0; // erratic boss regens faster (every 4s vs 6s)
    if (b.regenTimer >= regenRate) {
      b.regenTimer = 0;
      b.hp = Math.min(b.maxHp, b.hp + 1);
      spawnFloatingText(b.x, b.y - b.radius - 20, '+1 HP',
        b.type === 'nexus' ? '#8030a0' : '#006080');
    }
  } else {
    b.regenTimer = 0; // reset timer when being hit
  }

  // Spawn animation — slide toward target position
  if (b.spawnAnim > 0) {
    b.spawnAnim = Math.max(0, b.spawnAnim - dt * 0.8);
    b.x = lerp(b.x, b.targetX, dt * 1.5);
    b.y = lerp(b.y, b.targetY, dt * 1.5);
    return;
  }

  // Death animation
  if (b.state === 'dying') {
    b.dyingTimer += dt;
    const deathDur = b.type === 'leviathan' ? 2.0 : 1.5;
    if (b.dyingTimer >= deathDur) {
      // Boss dies — reward player
      const reward = 3;
      G.taps += reward;
      spawnFloatingText(b.x, b.y - 40, '+' + reward + ' TAPS', '#00ffa0');

      // XP reward
      const xpReward = G.level * 5;
      G.chainXpValue += xpReward;

      // Mega explosion — pop nearby orbs for FREE
      const blastR = getBlastRadius() * 2;
      createExplosion(b.x, b.y, blastR, b.type === 'nexus' ? '#d050ff' : '#00e5ff', false);
      G.shakeAmount = Math.max(G.shakeAmount, 12);

      // Pop orbs in range (free, no tap cost)
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (c.popped || !c.alive || c.queued) continue;
        const d = dist(b.x, b.y, c.x, c.y);
        if (d < blastR + c.radius) {
          c.queued = true;
          G.chainQueue.push({ circleId: c.id, triggerTime: G.chainTimer + Math.random() * 0.15 });
          if (!G.chainActive) {
            G.chainActive = true;
            G.chainGenId++;
            G.chainCount = 0;
            G.chainXpValue = 0;
            G.chainTimer = 0;
          }
        }
      }

      // Release all tethered orbs on death
      if (b.tethers) {
        for (let t = 0; t < b.tethers.length; t++) {
          const orb = findCircleById(b.tethers[t].orbId);
          if (orb) orb.tethered = false;
        }
      }

      const deathMsg = b.type === 'nexus' ? 'THE NEXUS SHATTERS' : 'THE LEVIATHAN SINKS';
      spawnFloatingText(b.x, b.y, deathMsg, '#ffffff');
      playBossDeathSound();
      G.bossKillCount++;
      G.boss = null;
      G.bossTimer = 0;
      return;
    }
    // Death anim: expand and fade
    b.radius = 55 + b.dyingTimer * 40;
    return;
  }

  // Movement — orbit around shifting center (uses game boundaries)
  const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
  const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
  const gw = G.gameW || G.W, gh = G.gameH || G.H;
  const bossGL = G.gameLeft || 0, bossGT = G.gameTop || 0;
  const bossGR = G.gameRight || G.W, bossGB = G.gameBottom || G.H;

  if (b.erratic) {
    // ERRATIC BOSS: fast, jerky, unpredictable movement
    b.orbitAngle += dt * (1.2 + Math.sin(b.phase * 3.7) * 0.8);
    const chaosX = Math.sin(b.phase * 2.3) * gw * 0.3 + Math.cos(b.phase * 4.1) * gw * 0.1;
    const chaosY = Math.cos(b.phase * 1.7) * gh * 0.25 + Math.sin(b.phase * 3.3) * gh * 0.1;
    const orbitR = 100 + Math.sin(b.phase * 1.5) * 120;
    b.targetX = gcx + chaosX + Math.cos(b.orbitAngle) * orbitR;
    b.targetY = gcy + chaosY + Math.sin(b.orbitAngle) * orbitR;
    // Clamp to game area
    b.targetX = Math.max(bossGL + 40, Math.min(bossGR - 40, b.targetX));
    b.targetY = Math.max(bossGT + 40, Math.min(bossGB - 40, b.targetY));
    // Faster tracking (jerky)
    b.x = lerp(b.x, b.targetX, dt * 2.5);
    b.y = lerp(b.y, b.targetY, dt * 2.5);
    // Pulsing size distortion
    b.radius = 140 + Math.sin(b.phase * 4) * 20;
  } else if (b.type === 'nexus') {
    b.orbitAngle += dt * 0.3;
    const ncx = gcx + Math.sin(b.phase * 0.07) * gw * 0.15;
    const ncy = gcy + Math.cos(b.phase * 0.09) * gh * 0.1;
    const orbitR = 150 + Math.sin(b.phase * 0.2) * 80;
    b.targetX = ncx + Math.cos(b.orbitAngle) * orbitR;
    b.targetY = ncy + Math.sin(b.orbitAngle) * orbitR;
    b.x = lerp(b.x, b.targetX, dt * 0.8);
    b.y = lerp(b.y, b.targetY, dt * 0.8);
  } else {
    // Leviathan: slow drift + vertical bob
    b.orbitAngle += dt * 0.15;
    b.targetX = gcx + Math.sin(b.orbitAngle) * gw * 0.25;
    b.targetY = gcy + Math.sin(b.phase * 0.5) * 60;
    b.x = lerp(b.x, b.targetX, dt * 0.8);
    b.y = lerp(b.y, b.targetY, dt * 0.8);
  }

  // --- BOSS-ORB PHYSICAL INTERACTION ---
  // Bosses push nearby orbs away from their body + occasionally consume orbs near their core
  if (b.state !== 'dying') {
    const bossEatRadius = b.radius * 0.3;  // core eating zone
    const bossPushRadius = b.radius * 1.2;  // push zone extends past body
    const pushStrength = b.erratic ? 250 : 150; // erratic bosses push harder
    // Leviathan eats more, Nexus pushes more
    const eatChance = b.type === 'leviathan' ? 0.015 : 0.005; // per orb per frame

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (!c.alive || c.popped || c.tethered || c.superCell) continue;
      const dx = c.x - b.x, dy = c.y - b.y;
      const d = Math.sqrt(dx * dx + dy * dy);

      if (d < bossEatRadius && Math.random() < eatChance) {
        // CONSUMED — orb too close to the boss core
        c.alive = false;
        c.popped = true;
        spawnPopParticles(c.x, c.y, c.color);
        // Leviathan: consumed orbs feed bloat (if not already bloated)
        if (b.type === 'leviathan' && b.bloatState !== 'bloated') {
          b.orbsEaten = (b.orbsEaten || 0) + 1;
        }
      } else if (d < bossPushRadius && d > 3) {
        // PUSHED AWAY — boss body repels nearby orbs
        const pushFalloff = 1 - (d / bossPushRadius);
        const push = pushStrength * pushFalloff * pushFalloff * dt;
        const nx = dx / d, ny = dy / d;
        c.vx += nx * push;
        c.vy += ny * push;
      }
    }
  }

  // State machine — erratic boss cycles much faster with chaotic timing
  b.stateTimer -= dt;
  if (b.stateTimer <= 0) {
    if (b.erratic) {
      // Erratic: rapid random state changes
      const states = b.type === 'nexus'
        ? ['idle', 'absorbing', 'shielding', 'absorbing', 'idle']
        : ['idle', 'grabbing', 'pressure', 'grabbing', 'idle'];
      b.state = states[Math.floor(Math.random() * states.length)];
      b.stateTimer = 0.5 + Math.random() * 1.5; // very fast cycling
    } else {
      // Normal: predictable cycle
      if (b.state === 'idle') {
        b.state = b.type === 'nexus' ? 'absorbing' : 'grabbing';
        b.stateTimer = b.type === 'nexus' ? 2.0 : 2.5;
      } else if (b.state === 'absorbing' || b.state === 'grabbing') {
        b.state = b.type === 'nexus' ? 'shielding' : 'pressure';
        b.stateTimer = b.type === 'nexus' ? 3.0 : 1.5;
      } else {
        b.state = 'idle';
        b.stateTimer = 3 + Math.random() * 2;
      }
    }
  }

  // --- NEXUS SHIELD TETHERS ---
  if (b.type === 'nexus' && b.state !== 'dying') {
    // Tether cooldown (initial delay + regen delay)
    if (b.tetherCooldown > 0) {
      b.tetherCooldown -= dt;
    }

    // Prune dead/popped tethered orbs
    for (let t = b.tethers.length - 1; t >= 0; t--) {
      const orb = findCircleById(b.tethers[t].orbId);
      if (!orb || !orb.alive || orb.popped) {
        b.tethers.splice(t, 1);
      }
    }

    if (b.shieldUp) {
      // Shield is up — maintain tethers
      if (b.tethers.length === 0 && b.tetherCooldown <= 0) {
        // All tethers broken! Shield drops
        b.shieldUp = false;
        b.shieldTimer = 4.0; // 4 seconds vulnerable
        spawnFloatingText(b.x, b.y - b.radius - 30, 'SHIELD DOWN!', '#ff4040', 1.5, { fontSize: 16 });
        G.shakeAmount = Math.max(G.shakeAmount, 6);
        // Un-tether any remaining orbs
        for (let i = 0; i < G.circles.length; i++) {
          G.circles[i].tethered = false;
        }
      } else if (b.tethers.length < 3 && b.tetherCooldown <= 0) {
        // Need more tethers — find nearby orbs to tether
        const tetherRange = 250 + b.radius;
        const candidates = [];
        for (let i = 0; i < G.circles.length; i++) {
          const c = G.circles[i];
          if (!c.alive || c.popped || c.tethered || c.superCell || c.queued) continue;
          const d = dist(b.x, b.y, c.x, c.y);
          if (d < tetherRange && d > b.radius * 1.2) {
            candidates.push({ orb: c, dist: d });
          }
        }
        // Sort by distance, pick closest
        candidates.sort((a, b2) => a.dist - b2.dist);
        const needed = (3 + Math.floor(Math.random() * 2)) - b.tethers.length; // 3-4 total
        for (let i = 0; i < Math.min(needed, candidates.length); i++) {
          const c = candidates[i].orb;
          c.tethered = true;
          b.tethers.push({ orbId: c.id, pulsePhase: Math.random() * Math.PI * 2 });
        }
      }
      // Update tether pulse phases
      for (let t = 0; t < b.tethers.length; t++) {
        b.tethers[t].pulsePhase += dt * 4;
      }
    } else {
      // Shield is down — countdown to regen
      b.shieldTimer -= dt;
      if (b.shieldTimer <= 0) {
        // Shield regenerates
        b.shieldUp = true;
        b.tetherCooldown = 0.5; // brief delay before tethers form
        spawnFloatingText(b.x, b.y - b.radius - 30, 'SHIELD RESTORED', '#d050ff', 1.2, { fontSize: 14 });
      }
    }
  }

  // --- ERRATIC (PEAK) BOSS: CONTINUOUS HUNGER — eats balls in ALL states ---
  if (b.erratic && b.state !== 'dying') {
    const hungerRange = 280; // massive pull range
    const hungerStr = 160;
    const swallowDist = b.radius * 0.6;
    b.orbsEaten = b.orbsEaten || 0;
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive || c.queued) continue;
      const d = dist(b.x, b.y, c.x, c.y);
      if (d < hungerRange && d > 3) {
        const dx = b.x - c.x, dy = b.y - c.y;
        // Relentless pull — gets stronger as orbs get closer
        const pull = hungerStr * dt / Math.max(d, 10);
        c.vx += (dx / d) * pull;
        c.vy += (dy / d) * pull;
        // Devour orbs that touch — heals AND grows stronger (not during bloat)
        if (d < swallowDist && b.bloatState !== 'bloated') {
          c.alive = false; c.popped = true;
          b.orbsEaten++;
          b.bloatOrbsHeld = (b.bloatOrbsHeld || 0) + 1;
          spawnPopParticles(c.x, c.y, '#ff2040');
          // Heal from eating
          b.hp = Math.min(b.maxHp, b.hp + 1);
          // Every 3 orbs eaten: gain +1 max HP (boss gets tougher)
          if (b.orbsEaten % 3 === 0) {
            b.maxHp++;
            b.hp = Math.min(b.maxHp, b.hp + 1);
            spawnFloatingText(b.x, b.y - b.radius - 25, 'IT GROWS', '#ff3050');
          }
          // Grow slightly bigger with each meal
          b.radius = Math.min(200, b.radius + 0.5);
          G.shakeAmount = Math.max(G.shakeAmount, 2);
          // Bloat trigger
          if (b.bloatOrbsHeld >= 6 && b.bloatState === 'none') {
            b.bloatState = 'bloated';
            b.bloatTimer = 3.0;
            b.bloatBaseRadius = b.radius;
            spawnFloatingText(b.x, b.y - b.radius - 30, 'IT GORGES', '#80ff60', 1.5, { fontSize: 16 });
            G.shakeAmount = Math.max(G.shakeAmount, 5);
          }
        }
      }
    }
  }

  // --- Nexus behaviors ---
  if (b.type === 'nexus' && b.state === 'absorbing' && !b.erratic) {
    // Pull nearby orbs toward boss (gravity well) — normal nexus only
    const absorbRange = 120;
    const absorbStr = 60;
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive || c.queued) continue;
      const d = dist(b.x, b.y, c.x, c.y);
      if (d < absorbRange && d > 5) {
        const dx = b.x - c.x, dy = b.y - c.y;
        const pull = absorbStr * dt / Math.max(d, 15);
        c.vx += (dx / d) * pull;
        c.vy += (dy / d) * pull;
        // Swallow if very close
        if (d < b.radius * 0.5 && b.hp < b.maxHp) {
          c.alive = false; c.popped = true;
          b.hp = Math.min(b.maxHp, b.hp + 1);
          spawnPopParticles(c.x, c.y, c.color);
        }
      }
    }
  }

  // --- Leviathan behaviors ---
  if (b.type === 'leviathan') {
    // Update tentacles
    for (let t = 0; t < b.tentacles.length; t++) {
      const tent = b.tentacles[t];
      tent.phase += dt * 1.5;

      // Regrow severed tentacles
      if (tent.hp <= 0) {
        tent.regrowTimer += dt;
        if (tent.regrowTimer >= 5) {
          tent.hp = tent.maxHp;
          tent.regrowTimer = 0;
          tent.length = 1.0;
        }
        continue;
      }

      if (b.state === 'grabbing' || b.erratic) {
        // Extend toward nearest orb — erratic boss grabs in ALL states
        if (!tent.grabTarget) {
          let nearest = null, nearD = b.erratic ? 250 : 150;
          for (let i = 0; i < G.circles.length; i++) {
            const c = G.circles[i];
            if (c.popped || !c.alive || c.queued) continue;
            const d = dist(b.x, b.y, c.x, c.y);
            if (d < nearD) { nearD = d; nearest = c; }
          }
          if (nearest) {
            tent.grabTarget = nearest.id;
            tent.angle = Math.atan2(nearest.y - b.y, nearest.x - b.x);
          }
        }
        // Pull grabbed orb toward maw — erratic boss pulls harder
        if (tent.grabTarget) {
          const gc = findCircleById(tent.grabTarget);
          if (gc && gc.alive && !gc.popped) {
            const dx = b.x - gc.x, dy = b.y - gc.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            const grabPull = b.erratic ? 140 : 80;
            if (d > 5) {
              gc.vx += (dx / d) * grabPull * dt;
              gc.vy += (dy / d) * grabPull * dt;
            }
            // Swallow if close (but NOT during bloat — boss can't eat while bloated)
            if (d < b.radius * 0.6 && b.bloatState !== 'bloated') {
              gc.alive = false; gc.popped = true;
              b.hp = Math.min(b.maxHp, b.hp + 1);
              b.mawOpen = 1.0;
              spawnPopParticles(gc.x, gc.y, '#ff2040');
              tent.grabTarget = null;
              b.orbsEaten = (b.orbsEaten || 0) + 1;
              b.bloatOrbsHeld = (b.bloatOrbsHeld || 0) + 1;
              // Erratic boss grows from eating
              if (b.erratic) {
                if (b.orbsEaten % 3 === 0) {
                  b.maxHp++;
                  b.hp = Math.min(b.maxHp, b.hp + 1);
                  spawnFloatingText(b.x, b.y - b.radius - 25, 'IT GROWS', '#ff3050');
                }
                b.radius = Math.min(200, b.radius + 0.5);
              }
              // Bloat trigger: after eating 6+ orbs in a cycle
              if (b.bloatOrbsHeld >= 6 && b.bloatState === 'none') {
                b.bloatState = 'bloated';
                b.bloatTimer = 3.0;
                b.bloatBaseRadius = b.radius; // store for inflation
                spawnFloatingText(b.x, b.y - b.radius - 30, 'IT GORGES', '#80ff60', 1.5, { fontSize: 16 });
                G.shakeAmount = Math.max(G.shakeAmount, 5);
              }
            }
          } else {
            tent.grabTarget = null;
          }
        }
      } else {
        tent.grabTarget = null;
      }
    }

    // Maw close animation
    if (b.mawOpen > 0) b.mawOpen = Math.max(0, b.mawOpen - dt * 2);

    // --- BLOAT STATE ---
    if (b.bloatState === 'bloated') {
      b.bloatTimer -= dt;

      // Inflate visual — grows 30% bigger during bloat
      const bloatInflate = 1.0 + 0.3 * Math.sin(b.bloatTimer * 4); // pulsing inflation
      b.radius = (b.bloatBaseRadius || 55) * (1.15 + 0.15 * Math.sin(b.bloatTimer * 4));

      // Slow down movement during bloat
      b.x = lerp(b.x, b.targetX, dt * 0.2); // much slower tracking

      // Bloat window expired — player missed it!
      if (b.bloatTimer <= 0) {
        // Shockwave: scatter all orbs to edges
        const shockR = 400;
        const shockForce = 800;
        for (let i = 0; i < G.circles.length; i++) {
          const c = G.circles[i];
          if (!c.alive || c.popped) continue;
          const dx = c.x - b.x, dy = c.y - b.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < shockR && d > 1) {
            const falloff = 1 - d / shockR;
            c.vx += (dx / d) * shockForce * falloff;
            c.vy += (dy / d) * shockForce * falloff;
          }
        }
        // Heal 30% max HP
        const healAmount = Math.ceil(b.maxHp * 0.3);
        b.hp = Math.min(b.maxHp, b.hp + healAmount);

        createExplosion(b.x, b.y, shockR * 0.6, '#40ff80', false);
        G.shakeAmount = Math.max(G.shakeAmount, 12);
        spawnFloatingText(b.x, b.y - b.radius - 30, 'IT FEEDS +' + healAmount + 'HP', '#ff4040', 1.5, { fontSize: 14 });

        // Reset bloat cycle
        b.bloatState = 'none';
        b.bloatOrbsHeld = 0;
        b.radius = b.bloatBaseRadius || 55;
      }
    }

    // Pressure wave behavior
    if (b.state === 'pressure') {
      const waveT = (1.5 - b.stateTimer) / 1.5;
      const waveStr = Math.sin(waveT * Math.PI) * 120 * dt;
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (c.popped || !c.alive) continue;
        const dx = c.x - b.x, dy = c.y - b.y;
        const d = Math.sqrt(dx * dx + dy * dy) + 1;
        if (d < 200) {
          c.vx += (dx / d) * waveStr;
          c.vy += (dy / d) * waveStr;
        }
      }
    }
  }
}

// --- Boss Damage (called from popCircle) ---
function damageBoss(explosionX, explosionY, blastRadius, orbRadius) {
  if (!G.boss || G.boss.state === 'dying' || G.boss.hitCooldown > 0) return;
  const b = G.boss;

  // Nexus shield: block damage while tethers are active
  if (b.type === 'nexus' && b.shieldUp) {
    // Visual feedback — shield absorbs the hit
    if (b.hitCooldown <= 0) {
      b.hitCooldown = 0.3;
      spawnFloatingText(b.x, b.y - b.radius - 15, 'SHIELDED', '#9060cc', 0.6, { fontSize: 11 });
    }
    return;
  }

  const d = dist(explosionX, explosionY, b.x, b.y);
  if (d > blastRadius + b.radius) return;

  // Size-based damage: small orbs do less, big merged orbs do more
  const sizeRatio = (orbRadius || BASE_CIRCLE_RADIUS) / BASE_CIRCLE_RADIUS;
  let dmg = 1;
  if (sizeRatio < 0.5) dmg = 0; // tiny shrapnel does NO boss damage
  else if (sizeRatio < 0.8) dmg = 1; // small orbs = 1 HP
  else if (sizeRatio < 1.5) dmg = 1; // normal orbs = 1 HP
  else if (sizeRatio < 2.5) dmg = 2; // big merged = 2 HP
  else dmg = 3; // Big2 = 3 HP

  if (dmg <= 0) return; // too small to hurt boss

  // Void amplification: as WT rises, explosions carry void energy that hurts bosses more
  // Scales from +0% at 0% WT to +75% at 100% WT
  const voidMadness = getMadnessAmount();
  if (voidMadness > 0) {
    dmg = Math.ceil(dmg * (1 + voidMadness * 0.75));
  }

  // Leviathan bloat: 3× damage during bloated state!
  let bloatBurst = false;
  if (b.type === 'leviathan' && b.bloatState === 'bloated') {
    dmg *= 3;
    bloatBurst = true;
  }

  b.hp -= dmg;
  b.hitCooldown = 0.15;
  b.hitFlash = 1.0;
  G.shakeAmount = Math.max(G.shakeAmount, dmg + 2);
  playBossHitSound();

  // Bloat burst: drop all eaten orbs back as free pops!
  if (bloatBurst) {
    const dropCount = b.bloatOrbsHeld || 6;
    const dropAngleStep = (Math.PI * 2) / dropCount;
    for (let di = 0; di < dropCount; di++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      const dropAngle = di * dropAngleStep + Math.random() * 0.3;
      const dropDist = b.radius * 1.5 + Math.random() * 40;
      const dx = b.x + Math.cos(dropAngle) * dropDist;
      const dy = b.y + Math.sin(dropAngle) * dropDist;
      const fc = createCircle(dx, dy);
      fc.spawnAnim = 0;
      fc.vx = Math.cos(dropAngle) * (200 + Math.random() * 150);
      fc.vy = Math.sin(dropAngle) * (200 + Math.random() * 150);
      G.circles.push(fc);
    }
    // Big visual burst
    for (let pi = 0; pi < 20; pi++) {
      const pa = Math.random() * Math.PI * 2;
      spawnParticle(b.x + Math.cos(pa) * b.radius * 0.5, b.y + Math.sin(pa) * b.radius * 0.5,
        'spark', '#80ff60', { vx: Math.cos(pa) * 300, vy: Math.sin(pa) * 300, maxLife: 0.6, size: 4 });
    }
    spawnFloatingText(b.x, b.y - b.radius - 40, 'HUNGER RUPTURES -' + dmg + 'HP', '#80ff60', 2.0, { fontSize: 18 });
    G.shakeAmount = Math.max(G.shakeAmount, 8);
    // Reset bloat cycle
    b.bloatState = 'none';
    b.bloatOrbsHeld = 0;
    b.radius = b.bloatBaseRadius || 55;
  }

  const hpText = Math.max(0, b.hp) + '/' + b.maxHp;
  const bName = b.type === 'nexus' ? 'Nexus' : 'Leviathan';
  const dmgText = dmg > 1 ? ' -' + dmg + 'HP' : '';
  if (!bloatBurst) {
    spawnFloatingText(b.x, b.y - b.radius - 10, bName + ' ' + hpText + dmgText,
      b.type === 'nexus' ? '#d050ff' : '#00e5ff');
  }

  // Check for tentacle damage (Leviathan)
  if (b.type === 'leviathan') {
    for (let t = 0; t < b.tentacles.length; t++) {
      const tent = b.tentacles[t];
      if (tent.hp <= 0) continue;
      const tentEndX = b.x + Math.cos(tent.angle) * b.radius * 2 * tent.length;
      const tentEndY = b.y + Math.sin(tent.angle) * b.radius * 2 * tent.length;
      const td = dist(explosionX, explosionY, tentEndX, tentEndY);
      if (td < blastRadius) {
        tent.hp--;
        if (tent.hp <= 0) {
          tent.length = 0.3;
          tent.grabTarget = null;
          // Drop a free orb
          if (G.circles.length < MAX_CIRCLES) {
            const fc = createCircle(tentEndX, tentEndY);
            fc.spawnAnim = 0;
            G.circles.push(fc);
          }
        }
      }
    }
  }

  if (b.hp <= 0) {
    b.state = 'dying';
    b.dyingTimer = 0;
  }
}

// --- Boss Rendering ---
function renderBoss(ctx) {
  if (!G.boss) return;
  const b = G.boss;
  const alpha = b.spawnAnim > 0 ? (1 - b.spawnAnim) : (b.state === 'dying' ? Math.max(0, 1 - b.dyingTimer / 1.5) : 1);
  if (alpha < 0.01) return;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Erratic visual distortion — jittery position, flicker, scale throb
  if (b.erratic && b.state !== 'dying') {
    const jitterX = (Math.random() - 0.5) * 6;
    const jitterY = (Math.random() - 0.5) * 6;
    ctx.translate(jitterX, jitterY);
    // Random alpha flicker
    ctx.globalAlpha = alpha * (0.7 + Math.random() * 0.3);
  }

  if (b.type === 'nexus') {
    renderNexusBoss(ctx, b);
  } else {
    renderLeviathanBoss(ctx, b);
  }

  // HP bar arc
  if (b.state !== 'dying' && b.hp > 0) {
    const hpFrac = b.hp / b.maxHp;
    ctx.globalAlpha = alpha * 0.6;
    // Background arc
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.radius - 12, b.radius * 0.7, Math.PI, 0);
    ctx.stroke();
    // HP fill arc
    ctx.strokeStyle = hpFrac > 0.5 ? '#00ff80' : hpFrac > 0.25 ? '#ffcc00' : '#ff4040';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.radius - 12, b.radius * 0.7, Math.PI, Math.PI + Math.PI * hpFrac);
    ctx.stroke();
  }

  ctx.restore();
}

function renderNexusBoss(ctx, b) {
  const r = b.radius;

  // Hit flash
  if (b.hitFlash > 0) {
    ctx.globalAlpha = (ctx.globalAlpha || 1) * (1 - b.hitFlash * 0.3);
  }

  // Layer 0: Ominous aura — dark, subtle
  ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.12;
  const auraR = r * 2.5;
  const auraGrad = ctx.createRadialGradient(b.x, b.y, r * 0.5, b.x, b.y, auraR);
  auraGrad.addColorStop(0, '#200040');
  auraGrad.addColorStop(0.5, '#0a0018');
  auraGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(b.x, b.y, auraR, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = b.hitFlash > 0 ? (1 - b.hitFlash * 0.3) : 1;

  // Layer 1: Central mass — pure black, smooth wobbly tentacle edges
  const bodyPts = 24;
  // Build smooth control points with tentacle-like protrusions
  const bodyPoints = [];
  for (let p = 0; p < bodyPts; p++) {
    const angle = (p / bodyPts) * Math.PI * 2;
    // Layered wobble: slow organic + tentacle bulges
    const wobble = Math.sin(angle * 3 + b.phase * 1.2) * 0.10 +
                   Math.sin(angle * 5 + b.phase * 0.6) * 0.06 +
                   Math.sin(angle * 2 - b.phase * 0.9) * 0.12;
    // Every ~4th point extends further for tentacle-like protrusions
    const tentacle = (Math.sin(angle * 3.5 + b.phase * 0.4) > 0.5) ? 0.12 : 0;
    const pr = r * (0.82 + wobble + tentacle);
    bodyPoints.push({
      x: b.x + Math.cos(angle) * pr,
      y: b.y + Math.sin(angle) * pr
    });
  }
  // Draw smooth closed bezier curve through the points
  ctx.fillStyle = b.hitFlash > 0.5 ? '#ffffff' : '#010002';
  ctx.beginPath();
  ctx.moveTo(
    (bodyPoints[bodyPts - 1].x + bodyPoints[0].x) / 2,
    (bodyPoints[bodyPts - 1].y + bodyPoints[0].y) / 2
  );
  for (let p = 0; p < bodyPts; p++) {
    const curr = bodyPoints[p];
    const next = bodyPoints[(p + 1) % bodyPts];
    const mx = (curr.x + next.x) / 2;
    const my = (curr.y + next.y) / 2;
    ctx.quadraticCurveTo(curr.x, curr.y, mx, my);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 1b: Sparkling star effects inside body
  ctx.save();
  ctx.clip(); // clip to body shape
  if (!b._stars) {
    b._stars = [];
    for (let s = 0; s < 30; s++) {
      b._stars.push({
        ox: (Math.random() - 0.5) * 1.4, oy: (Math.random() - 0.5) * 1.4,
        size: 0.5 + Math.random() * 1.5,
        twinkleSpeed: 1.5 + Math.random() * 3,
        twinklePhase: Math.random() * Math.PI * 2
      });
    }
  }
  for (let s = 0; s < b._stars.length; s++) {
    const star = b._stars[s];
    const sx = b.x + star.ox * r * 0.65;
    const sy = b.y + star.oy * r * 0.65;
    const twinkle = 0.3 + 0.7 * Math.max(0, Math.sin(b.phase * star.twinkleSpeed + star.twinklePhase));
    ctx.globalAlpha = twinkle * 0.7;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(sx, sy, star.size, 0, Math.PI * 2);
    ctx.fill();
    // Tiny glow around brighter stars
    if (twinkle > 0.7 && star.size > 1) {
      ctx.globalAlpha = (twinkle - 0.7) * 0.4;
      ctx.beginPath();
      ctx.arc(sx, sy, star.size * 2.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.restore();
  ctx.globalAlpha = b.hitFlash > 0 ? (1 - b.hitFlash * 0.3) : 1;

  // Layer 2: Features — eyes (regular) or mouths (peak/erratic boss)
  if (b.erratic) {
    // === PEAK BOSS: Mass of hungry mouths — 4 vector variants ===
    for (let e = 0; e < b.eyePhases.length; e++) {
      const m = b.eyePhases[e];
      const mAngle = m.angle + b.phase * 0.08;
      const mx = b.x + Math.cos(mAngle) * r * m.dist;
      const my = b.y + Math.sin(mAngle) * r * m.dist;
      const mR = r * m.size * 1.3; // mouths larger than eyes
      const mv = m.mouthVariant || 0;

      // Chewing/open cycle
      const chew = Math.sin(b.phase * m.blinkSpeed + m.blinkPhase);
      const openAmt = 0.3 + 0.7 * Math.max(0, chew);
      const faceAngle = Math.atan2(my - b.y, mx - b.x) + Math.sin(b.phase * 0.5 + m.blinkPhase) * 0.3;
      const baseAlpha = b.hitFlash > 0.5 ? 0.4 : 0.95;

      ctx.save();
      ctx.translate(mx, my);
      ctx.rotate(faceAngle);

      if (mv === 0) {
        // --- M0: FANGED — Elongated predatory jaw, prominent canines ---
        // Outer lip shape — elongated horizontal ellipse
        ctx.globalAlpha = baseAlpha;
        ctx.fillStyle = '#1a0510';
        ctx.beginPath();
        ctx.ellipse(0, 0, mR * 1.15, mR * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Lip contour strokes — double line for fleshy look
        ctx.strokeStyle = '#3a0818';
        ctx.lineWidth = 1.2;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(0, 0, mR * 1.12, mR * 0.48, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.strokeStyle = '#5a1028';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.ellipse(0, 0, mR * 1.05, mR * 0.42, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Inner throat void
        const innerH = mR * 0.35 * openAmt;
        ctx.fillStyle = '#0a0002';
        ctx.globalAlpha = 0.95;
        ctx.beginPath();
        ctx.ellipse(0, 0, mR * 0.85, innerH, 0, 0, Math.PI * 2);
        ctx.fill();
        // Teeth — 4 large fangs (canines) + smaller teeth between
        if (openAmt > 0.3) {
          const ta = Math.min(1, (openAmt - 0.3) / 0.25);
          ctx.globalAlpha = 0.92 * ta;
          // Four prominent canines
          const fangH = mR * 0.38 * openAmt;
          const fangW = mR * 0.07;
          const fangPositions = [-0.7, -0.25, 0.25, 0.7]; // x positions as fraction of mR
          for (let f = 0; f < 4; f++) {
            const fx = fangPositions[f] * mR;
            const isOuter = f === 0 || f === 3;
            const fH = isOuter ? fangH * 0.85 : fangH;
            const fW = isOuter ? fangW * 0.8 : fangW;
            // Top fang (pointing down) — curved shape
            ctx.fillStyle = '#e8ddd0';
            ctx.beginPath();
            ctx.moveTo(fx - fW, -innerH * 0.7);
            ctx.quadraticCurveTo(fx - fW * 0.3, -innerH * 0.7 + fH * 0.6, fx, -innerH * 0.7 + fH);
            ctx.quadraticCurveTo(fx + fW * 0.3, -innerH * 0.7 + fH * 0.6, fx + fW, -innerH * 0.7);
            ctx.fill();
            // Fang edge highlight
            ctx.strokeStyle = '#c0b8a8';
            ctx.lineWidth = 0.4;
            ctx.beginPath();
            ctx.moveTo(fx - fW * 0.5, -innerH * 0.7);
            ctx.quadraticCurveTo(fx, -innerH * 0.7 + fH * 0.7, fx + fW * 0.2, -innerH * 0.7 + fH * 0.3);
            ctx.stroke();
            // Bottom fang (pointing up) — shorter
            ctx.fillStyle = '#ddd5c8';
            ctx.beginPath();
            ctx.moveTo(fx - fW * 0.8, innerH * 0.7);
            ctx.quadraticCurveTo(fx, innerH * 0.7 - fH * 0.65, fx + fW * 0.8, innerH * 0.7);
            ctx.fill();
          }
          // Small teeth between fangs
          ctx.fillStyle = '#d0c8c0';
          ctx.globalAlpha = 0.7 * ta;
          for (let t = 0; t < 7; t++) {
            const tx = -mR * 0.55 + (t / 6) * mR * 1.1;
            const tH = mR * 0.08 * (0.6 + 0.4 * Math.sin(t * 3.1 + m.blinkPhase));
            ctx.beginPath();
            ctx.moveTo(tx - mR * 0.025, -innerH * 0.65);
            ctx.lineTo(tx, -innerH * 0.65 + tH);
            ctx.lineTo(tx + mR * 0.025, -innerH * 0.65);
            ctx.fill();
          }
        }
        // Wet gleam along upper lip
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = '#cc6060';
        ctx.lineWidth = 0.6;
        ctx.beginPath();
        ctx.ellipse(0, -mR * 0.22, mR * 0.5, mR * 0.06, 0, Math.PI * 0.8, Math.PI * 0.2, true);
        ctx.stroke();

      } else if (mv === 1) {
        // --- M1: SCREAMER — Wide circular gaping maw, drool strands ---
        // Wide circular outer shape
        ctx.globalAlpha = baseAlpha;
        ctx.fillStyle = '#180510';
        ctx.beginPath();
        ctx.arc(0, 0, mR * 0.95, 0, Math.PI * 2);
        ctx.fill();
        // Lip ring — thick fleshy stroke
        ctx.strokeStyle = '#3a0a18';
        ctx.lineWidth = 2.0;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(0, 0, mR * 0.9, 0, Math.PI * 2);
        ctx.stroke();
        // Inner ring detail
        ctx.strokeStyle = '#50122a';
        ctx.lineWidth = 0.8;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, mR * 0.82, 0, Math.PI * 2);
        ctx.stroke();
        // Throat abyss — dark void with ridged palate
        const throatR = mR * 0.7 * openAmt;
        ctx.fillStyle = '#050001';
        ctx.globalAlpha = 0.95;
        ctx.beginPath();
        ctx.arc(0, 0, throatR, 0, Math.PI * 2);
        ctx.fill();
        // Palate ridges (horizontal lines across throat)
        ctx.strokeStyle = '#2a0008';
        ctx.lineWidth = 0.6;
        ctx.globalAlpha = 0.4 * openAmt;
        for (let pr = 0; pr < 5; pr++) {
          const py = -throatR * 0.6 + (pr / 4) * throatR * 0.8;
          const pw = Math.sqrt(Math.max(0, throatR * throatR - py * py)) * 0.7;
          ctx.beginPath();
          ctx.moveTo(-pw, py);
          ctx.quadraticCurveTo(0, py + throatR * 0.05, pw, py);
          ctx.stroke();
        }
        // Scattered irregular teeth around the rim
        if (openAmt > 0.35) {
          const ta = Math.min(1, (openAmt - 0.35) / 0.2);
          ctx.fillStyle = '#e0d8d0';
          ctx.globalAlpha = 0.85 * ta;
          const teethN = 10 + Math.floor(mR / 2);
          for (let t = 0; t < teethN; t++) {
            const tAngle = (t / teethN) * Math.PI * 2 + m.blinkPhase * 0.3;
            const tLen = mR * (0.12 + 0.08 * Math.sin(t * 2.7 + m.blinkPhase));
            const tW = mR * 0.04;
            const tBase = mR * 0.78;
            ctx.beginPath();
            ctx.moveTo(Math.cos(tAngle) * tBase + Math.cos(tAngle + 1.57) * tW,
                       Math.sin(tAngle) * tBase + Math.sin(tAngle + 1.57) * tW);
            ctx.lineTo(Math.cos(tAngle) * (tBase - tLen * openAmt),
                       Math.sin(tAngle) * (tBase - tLen * openAmt));
            ctx.lineTo(Math.cos(tAngle) * tBase - Math.cos(tAngle + 1.57) * tW,
                       Math.sin(tAngle) * tBase - Math.sin(tAngle + 1.57) * tW);
            ctx.fill();
          }
        }
        // Drool strands — thin lines hanging from top teeth
        ctx.strokeStyle = '#886068';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.35 * openAmt;
        for (let d = 0; d < 3; d++) {
          const dx = -mR * 0.3 + d * mR * 0.3;
          const dLen = mR * (0.3 + 0.2 * Math.sin(b.phase * 1.5 + d * 2.1));
          ctx.beginPath();
          ctx.moveTo(dx, -throatR * 0.6);
          ctx.quadraticCurveTo(dx + Math.sin(b.phase * 2 + d) * mR * 0.08, -throatR * 0.3 + dLen * 0.5,
                               dx + Math.sin(b.phase * 1.3 + d) * mR * 0.05, -throatR * 0.3 + dLen);
          ctx.stroke();
        }

      } else if (mv === 2) {
        // --- M2: SERRATED — Crooked irregular teeth rows, gums exposed ---
        // Outer gum shape — irregular fleshy mass
        ctx.globalAlpha = baseAlpha;
        ctx.fillStyle = '#200810';
        ctx.beginPath();
        // Wobbling gum outline
        for (let g = 0; g <= 24; g++) {
          const ga = (g / 24) * Math.PI * 2;
          const gWob = 1 + Math.sin(ga * 3 + m.blinkPhase) * 0.06 + Math.sin(ga * 7) * 0.03;
          const gx = Math.cos(ga) * mR * 0.95 * gWob;
          const gy = Math.sin(ga) * mR * 0.52 * gWob;
          if (g === 0) ctx.moveTo(gx, gy); else ctx.lineTo(gx, gy);
        }
        ctx.closePath();
        ctx.fill();
        // Gum tissue strokes — veiny texture
        ctx.strokeStyle = '#4a1525';
        ctx.lineWidth = 0.6;
        ctx.globalAlpha = 0.5;
        for (let v = 0; v < 6; v++) {
          const vx = -mR * 0.6 + (v / 5) * mR * 1.2;
          ctx.beginPath();
          ctx.moveTo(vx, -mR * 0.35);
          ctx.quadraticCurveTo(vx + Math.sin(v * 1.7) * mR * 0.06, 0, vx, mR * 0.35);
          ctx.stroke();
        }
        // Inner dark void
        const innerH = mR * 0.3 * openAmt;
        ctx.fillStyle = '#080002';
        ctx.globalAlpha = 0.95;
        ctx.beginPath();
        ctx.ellipse(0, 0, mR * 0.7, innerH, 0, 0, Math.PI * 2);
        ctx.fill();
        // Crooked teeth — deliberately irregular sizes, angles, spacing
        if (openAmt > 0.3) {
          const ta = Math.min(1, (openAmt - 0.3) / 0.25);
          ctx.globalAlpha = 0.9 * ta;
          // Irregular teeth with per-tooth seeded properties
          const seed = m.blinkPhase;
          for (let row = 0; row < 2; row++) {
            const ySign = row === 0 ? -1 : 1;
            const baseY = innerH * 0.7 * ySign;
            const teethN = 6 + Math.floor(mR / 4);
            for (let t = 0; t < teethN; t++) {
              const tSeed = seed + t * 7.31 + row * 13.7;
              const tSkew = Math.sin(tSeed) * 0.25; // angular skew
              const tScale = 0.5 + Math.abs(Math.sin(tSeed * 1.3)) * 0.7; // size variation
              const tGap = Math.sin(tSeed * 2.1) * mR * 0.02; // position jitter
              const tx = -mR * 0.6 + (t / (teethN - 1)) * mR * 1.2 + tGap;
              const tH = mR * 0.18 * tScale * openAmt;
              const tW = mR * 0.05 * (0.6 + tScale * 0.6);
              // Tooth body — slightly yellowish irregular shape
              const shade = Math.floor(200 + Math.sin(tSeed * 3.7) * 30);
              ctx.fillStyle = `rgb(${shade},${shade - 15},${shade - 30})`;
              ctx.save();
              ctx.translate(tx, baseY);
              ctx.rotate(tSkew * 0.3);
              ctx.beginPath();
              ctx.moveTo(-tW, 0);
              ctx.lineTo(-tW * 0.4, -ySign * tH * 0.6);
              ctx.lineTo(tW * 0.1, -ySign * tH);
              ctx.lineTo(tW * 0.5, -ySign * tH * 0.7);
              ctx.lineTo(tW, 0);
              ctx.fill();
              // Tooth outline
              ctx.strokeStyle = '#807060';
              ctx.lineWidth = 0.3;
              ctx.globalAlpha = 0.4 * ta;
              ctx.stroke();
              ctx.globalAlpha = 0.9 * ta;
              ctx.restore();
            }
          }
        }
        // Gum line accent
        ctx.strokeStyle = '#6a2038';
        ctx.lineWidth = 0.8;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.ellipse(0, 0, mR * 0.88, mR * 0.46, 0, 0, Math.PI * 2);
        ctx.stroke();

      } else {
        // --- M3: ABYSSAL MAW — Concentric tooth rings, deep spiraling void ---
        // Outer dark ring
        ctx.globalAlpha = baseAlpha;
        ctx.fillStyle = '#120008';
        ctx.beginPath();
        ctx.arc(0, 0, mR, 0, Math.PI * 2);
        ctx.fill();
        // Multiple concentric fleshy rings
        const ringColors = ['#1e0510', '#150308', '#0c0204', '#060001'];
        for (let ri = 0; ri < 4; ri++) {
          const rr = mR * (0.85 - ri * 0.15) * (0.5 + openAmt * 0.5);
          ctx.fillStyle = ringColors[ri];
          ctx.globalAlpha = 0.9;
          ctx.beginPath();
          ctx.arc(0, 0, rr, 0, Math.PI * 2);
          ctx.fill();
          // Ring contour stroke
          ctx.strokeStyle = '#3a0815';
          ctx.lineWidth = 0.6;
          ctx.globalAlpha = 0.4;
          ctx.beginPath();
          ctx.arc(0, 0, rr, 0, Math.PI * 2);
          ctx.stroke();
        }
        // Central void
        ctx.fillStyle = '#020000';
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(0, 0, mR * 0.25 * openAmt, 0, Math.PI * 2);
        ctx.fill();
        // Concentric tooth rings — each ring has teeth pointing inward
        if (openAmt > 0.3) {
          const ta = Math.min(1, (openAmt - 0.3) / 0.25);
          ctx.fillStyle = '#d8d0c5';
          ctx.globalAlpha = 0.85 * ta;
          // 3 rings of teeth at different radii
          for (let ring = 0; ring < 3; ring++) {
            const ringR = mR * (0.8 - ring * 0.18);
            const teethN = 8 + ring * 4;
            const toothLen = mR * (0.1 - ring * 0.015) * openAmt;
            // Rotate each ring differently over time for spiral effect
            const ringRot = b.phase * (0.15 + ring * 0.1) * (ring % 2 === 0 ? 1 : -1);
            for (let t = 0; t < teethN; t++) {
              const tAngle = (t / teethN) * Math.PI * 2 + m.blinkPhase + ringRot;
              const tW = Math.PI / teethN * 0.35;
              // Tooth points inward
              ctx.beginPath();
              ctx.moveTo(Math.cos(tAngle - tW) * ringR, Math.sin(tAngle - tW) * ringR);
              ctx.lineTo(Math.cos(tAngle) * (ringR - toothLen), Math.sin(tAngle) * (ringR - toothLen));
              ctx.lineTo(Math.cos(tAngle + tW) * ringR, Math.sin(tAngle + tW) * ringR);
              ctx.fill();
            }
            // Ring gets darker tooth color deeper in
            const shade = 200 - ring * 25;
            ctx.fillStyle = `rgb(${shade},${shade - 10},${shade - 20})`;
          }
        }
        // Subtle spiral lines — flesh folds pulling inward
        ctx.strokeStyle = '#3a0a12';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.3;
        for (let sp = 0; sp < 6; sp++) {
          const sAngle = (sp / 6) * Math.PI * 2 + b.phase * 0.1;
          ctx.beginPath();
          for (let si = 0; si < 20; si++) {
            const t = si / 19;
            const spiralR = mR * (0.9 - t * 0.65);
            const spiralA = sAngle + t * 1.5;
            const sx = Math.cos(spiralA) * spiralR;
            const sy = Math.sin(spiralA) * spiralR;
            if (si === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
          }
          ctx.stroke();
        }
      }

      ctx.restore();
    }
  } else {
    // === REGULAR BOSS: 4 desaturated vector-style eye variants ===
    for (let e = 0; e < b.eyePhases.length; e++) {
      const eye = b.eyePhases[e];
      const eAngle = eye.angle + b.phase * 0.1;
      const ex = b.x + Math.cos(eAngle) * r * eye.dist;
      const ey = b.y + Math.sin(eAngle) * r * eye.dist;
      const eR = r * eye.size;
      const variant = eye.eyeVariant || 0;

      // Blink
      const blink = Math.sin(b.phase * eye.blinkSpeed + eye.blinkPhase);
      if (blink < -0.85) continue;
      const openness = blink < -0.5 ? (blink + 0.85) / 0.35 : 1;
      const baseAlpha = b.hitFlash > 0.5 ? 0.4 : 0.95;

      // Iris tracking
      const lookDx = G.cursorX - ex, lookDy = G.cursorY - ey;
      const lookD = Math.sqrt(lookDx * lookDx + lookDy * lookDy) + 1;
      const lookStr = eR * 0.22;
      const irisX = ex + (lookDx / lookD) * lookStr;
      const irisY = ey + (lookDy / lookD) * lookStr * openness;
      const refAngle = eye.reflectAngle || 0;
      const faceAngle = Math.atan2(ey - b.y, ex - b.x);

      // --- Shared: Socket shadow ring (vector stroke) ---
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 1.2;
      ctx.globalAlpha = 0.4 * openness;
      ctx.beginPath();
      ctx.ellipse(ex, ey, eR * 1.12, eR * 1.08 * openness, faceAngle, 0, Math.PI * 2);
      ctx.stroke();

      // --- Shared: Sclera — flat off-white fill + crisp outline ---
      const scleraShade = variant === 0 ? '#d8d8d5' : variant === 1 ? '#ccccc8' : variant === 2 ? '#d2d2d6' : '#c8c5c2';
      ctx.fillStyle = scleraShade;
      ctx.globalAlpha = baseAlpha * openness;
      ctx.beginPath();
      ctx.ellipse(ex, ey, eR, eR * openness, 0, 0, Math.PI * 2);
      ctx.fill();
      // Sclera outline
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.7 * openness;
      ctx.beginPath();
      ctx.ellipse(ex, ey, eR * 0.98, eR * 0.98 * openness, 0, 0, Math.PI * 2);
      ctx.stroke();

      // --- Veins (thin vector lines) ---
      const veinCount = variant === 1 ? 6 : variant === 3 ? 7 : 4;
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 0.4;
      ctx.globalAlpha = 0.2 * openness;
      for (let v = 0; v < veinCount; v++) {
        const va = eye.blinkPhase + v * (Math.PI * 2 / veinCount);
        ctx.beginPath();
        ctx.moveTo(ex + Math.cos(va) * eR * 0.45, ey + Math.sin(va) * eR * 0.35 * openness);
        ctx.quadraticCurveTo(
          ex + Math.cos(va + 0.2) * eR * 0.7, ey + Math.sin(va + 0.1) * eR * 0.55 * openness,
          ex + Math.cos(va + 0.05) * eR * 0.95, ey + Math.sin(va - 0.08) * eR * 0.88 * openness
        );
        ctx.stroke();
      }

      // --- Per-variant iris + pupil (vector style) ---
      if (variant === 0) {
        // V0: PALE — light grey iris, round pupil, minimal
        const iR = eR * 0.48;
        // Iris fill — flat light grey
        ctx.fillStyle = '#8a8a88';
        ctx.globalAlpha = 0.9 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.fill();
        // Limbal ring stroke
        ctx.strokeStyle = '#404040';
        ctx.lineWidth = 1.0;
        ctx.globalAlpha = 0.8 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.stroke();
        // Pupil
        ctx.fillStyle = '#0a0a0a';
        ctx.globalAlpha = openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR * 0.42, 0, Math.PI * 2);
        ctx.fill();

      } else if (variant === 1) {
        // V1: STRIATED — mid-grey iris with radial line pattern, round pupil
        const iR = eR * 0.52;
        // Iris fill — mid grey
        ctx.fillStyle = '#787878';
        ctx.globalAlpha = 0.9 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.fill();
        // Radial striations (vector lines)
        ctx.strokeStyle = '#a0a0a0';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.45 * openness;
        for (let s = 0; s < 18; s++) {
          const sa = (s / 18) * Math.PI * 2 + eye.blinkPhase * 0.1;
          ctx.beginPath();
          ctx.moveTo(irisX + Math.cos(sa) * iR * 0.28, irisY + Math.sin(sa) * iR * 0.28);
          ctx.lineTo(irisX + Math.cos(sa) * iR * 0.88, irisY + Math.sin(sa) * iR * 0.88);
          ctx.stroke();
        }
        // Heavy limbal ring
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1.4;
        ctx.globalAlpha = 0.85 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.stroke();
        // Pupil
        ctx.fillStyle = '#060606';
        ctx.globalAlpha = openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR * 0.35, 0, Math.PI * 2);
        ctx.fill();

      } else if (variant === 2) {
        // V2: SLIT — light grey iris, vertical slit pupil
        const iR = eR * 0.55;
        // Iris fill — pale grey
        ctx.fillStyle = '#909094';
        ctx.globalAlpha = 0.9 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.fill();
        // Concentric iris rings (vector)
        ctx.strokeStyle = '#606068';
        ctx.lineWidth = 0.4;
        ctx.globalAlpha = 0.35 * openness;
        for (let ring = 1; ring <= 3; ring++) {
          ctx.beginPath();
          ctx.arc(irisX, irisY, iR * (0.3 + ring * 0.2), 0, Math.PI * 2);
          ctx.stroke();
        }
        // Limbal ring
        ctx.strokeStyle = '#303038';
        ctx.lineWidth = 1.2;
        ctx.globalAlpha = 0.8 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.stroke();
        // Vertical slit pupil
        ctx.fillStyle = '#080808';
        ctx.globalAlpha = openness;
        ctx.beginPath();
        ctx.ellipse(irisX, irisY, iR * 0.1, iR * 0.68, 0, 0, Math.PI * 2);
        ctx.fill();
        // Slit outline
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 0.6;
        ctx.beginPath();
        ctx.ellipse(irisX, irisY, iR * 0.12, iR * 0.7, 0, 0, Math.PI * 2);
        ctx.stroke();

      } else {
        // V3: CRACKED — dark grey iris with crack lines, horizontal slit pupil
        const iR = eR * 0.53;
        // Iris fill — darker grey
        ctx.fillStyle = '#606060';
        ctx.globalAlpha = 0.9 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.fill();
        // Crack lines (vector)
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 0.6;
        ctx.globalAlpha = 0.5 * openness;
        for (let s = 0; s < 12; s++) {
          const sa = (s / 12) * Math.PI * 2 + eye.blinkPhase * 0.15;
          const jag = Math.sin(s * 3.7) * iR * 0.08;
          ctx.beginPath();
          ctx.moveTo(irisX + Math.cos(sa) * iR * 0.2, irisY + Math.sin(sa) * iR * 0.2);
          ctx.lineTo(irisX + Math.cos(sa + 0.1) * iR * 0.55 + jag, irisY + Math.sin(sa - 0.08) * iR * 0.55);
          ctx.lineTo(irisX + Math.cos(sa) * iR * 0.85, irisY + Math.sin(sa) * iR * 0.85);
          ctx.stroke();
        }
        // Thick limbal ring
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1.6;
        ctx.globalAlpha = 0.85 * openness;
        ctx.beginPath();
        ctx.arc(irisX, irisY, iR, 0, Math.PI * 2);
        ctx.stroke();
        // Horizontal slit pupil
        ctx.fillStyle = '#050505';
        ctx.globalAlpha = openness;
        ctx.beginPath();
        ctx.ellipse(irisX, irisY, iR * 0.55, iR * 0.12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.ellipse(irisX, irisY, iR * 0.57, iR * 0.14, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // --- Shared: Specular highlight (crisp vector dot) ---
      const rx = ex + Math.cos(refAngle) * eR * 0.22;
      const ry = ey + Math.sin(refAngle) * eR * 0.18 * openness;
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.65 * openness;
      ctx.beginPath();
      ctx.arc(rx, ry, eR * 0.09, 0, Math.PI * 2);
      ctx.fill();
      // Smaller secondary highlight
      ctx.globalAlpha = 0.25 * openness;
      ctx.beginPath();
      ctx.arc(rx + eR * 0.18, ry + eR * 0.1, eR * 0.04, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;

  // --- Shield Tether Beams ---
  if (b.tethers && b.tethers.length > 0) {
    for (let t = 0; t < b.tethers.length; t++) {
      const tether = b.tethers[t];
      const orb = findCircleById(tether.orbId);
      if (!orb || !orb.alive || orb.popped) continue;

      const pulse = 0.5 + 0.5 * Math.sin(tether.pulsePhase);

      // Energy beam — pulsing line from boss center to tethered orb
      ctx.globalAlpha = 0.3 + pulse * 0.3;
      ctx.strokeStyle = '#d050ff';
      ctx.lineWidth = 1.5 + pulse;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(orb.x, orb.y);
      ctx.stroke();

      // Inner bright core line
      ctx.globalAlpha = 0.4 + pulse * 0.4;
      ctx.strokeStyle = '#f0a0ff';
      ctx.lineWidth = 0.5 + pulse * 0.5;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(orb.x, orb.y);
      ctx.stroke();

      // Tethered orb glow ring
      ctx.globalAlpha = 0.3 + pulse * 0.2;
      ctx.strokeStyle = '#d050ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, orb.radius + 4 + pulse * 3, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Shield status indicator — glow when shield is down (vulnerable)
  if (!b.shieldUp && b.shieldTimer > 0) {
    const urgency = b.shieldTimer < 1.5 ? Math.sin(G.time * 12) * 0.3 + 0.5 : 0.3;
    ctx.globalAlpha = urgency;
    ctx.strokeStyle = '#ff4040';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(b.x, b.y, r * 1.1, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

function renderLeviathanBoss(ctx, b) {
  const r = b.radius;
  const pal = getCurrentPalette();
  const accent = pal.accent || '#00e5ff';

  // Hit flash
  if (b.hitFlash > 0) {
    ctx.globalAlpha = (ctx.globalAlpha || 1) * (1 - b.hitFlash * 0.3);
  }

  // Layer 0: Bioluminescent glow
  ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.2;
  const glowR = r * 3;
  const glowGrad = ctx.createRadialGradient(b.x, b.y, r * 0.3, b.x, b.y, glowR);
  glowGrad.addColorStop(0, accent);
  glowGrad.addColorStop(0.4, '#004060');
  glowGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = glowGrad;
  ctx.beginPath();
  ctx.arc(b.x, b.y, glowR, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = b.hitFlash > 0 ? (1 - b.hitFlash * 0.3) : 1;

  // Layer 2: Tentacles
  for (let t = 0; t < b.tentacles.length; t++) {
    const tent = b.tentacles[t];
    if (tent.hp <= 0 && tent.length < 0.35) {
      // Severed stub
      ctx.strokeStyle = '#401020';
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.5;
      const stubEnd = r * 0.4;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(tent.angle) * r * 0.4, b.y + Math.sin(tent.angle) * r * 0.4);
      ctx.lineTo(b.x + Math.cos(tent.angle) * stubEnd * 1.5, b.y + Math.sin(tent.angle) * stubEnd * 1.5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      continue;
    }

    const tentLen = r * 2 * tent.length;
    const segments = 6;
    const segLen = tentLen / segments;
    const isGrabbing = b.state === 'grabbing' && tent.grabTarget;

    // Build tentacle path
    ctx.strokeStyle = isGrabbing ? accent : '#104050';
    ctx.lineWidth = isGrabbing ? 5 : 3.5;
    ctx.lineCap = 'round';
    ctx.globalAlpha = 0.8;
    ctx.beginPath();

    let px = b.x + Math.cos(tent.angle) * r * 0.4;
    let py = b.y + Math.sin(tent.angle) * r * 0.4;
    ctx.moveTo(px, py);

    for (let s = 1; s <= segments; s++) {
      const sf = s / segments;
      const curl = Math.sin(tent.phase + s * 1.2 + b.phase * 1.5) * 0.6 * sf;
      const segAngle = tent.angle + curl;
      px += Math.cos(segAngle) * segLen;
      py += Math.sin(segAngle) * segLen;

      // Taper linewidth
      ctx.lineWidth = (isGrabbing ? 5 : 3.5) * (1 - sf * 0.6);
      ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Suction cups along tentacle
    ctx.fillStyle = '#206060';
    ctx.globalAlpha = 0.3;
    let cpx = b.x + Math.cos(tent.angle) * r * 0.4;
    let cpy = b.y + Math.sin(tent.angle) * r * 0.4;
    for (let s = 1; s <= segments; s += 2) {
      const sf = s / segments;
      const curl = Math.sin(tent.phase + s * 1.2 + b.phase * 1.5) * 0.6 * sf;
      const segAngle = tent.angle + curl;
      cpx += Math.cos(segAngle) * segLen * 2;
      cpy += Math.sin(segAngle) * segLen * 2;
      ctx.beginPath();
      ctx.arc(cpx, cpy, 2.5 * (1 - sf * 0.5), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Layer 1: Central mantle — dark bulbous body
  const isBloated = b.bloatState === 'bloated';
  const bloatT = isBloated ? Math.max(0, b.bloatTimer / 3.0) : 0; // 1→0 during bloat
  const bloatPulse = isBloated ? Math.sin(G.time * (6 + (1 - bloatT) * 12)) * 0.5 + 0.5 : 0;

  const mantlePts = 20;
  const mantleGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r);
  if (b.hitFlash > 0.5) {
    mantleGrad.addColorStop(0, '#80ffff');
  } else if (isBloated) {
    // Stressed color shift: dark teal → sickly green/red as timer runs out
    const stressR = Math.floor(10 + (1 - bloatT) * 120 + bloatPulse * 40);
    const stressG = Math.floor(40 + bloatT * 60 + bloatPulse * 30);
    const stressB = Math.floor(20 + bloatT * 20);
    mantleGrad.addColorStop(0, `rgb(${stressR},${stressG},${stressB})`);
  } else {
    mantleGrad.addColorStop(0, '#0a1828');
  }
  mantleGrad.addColorStop(0.5, isBloated ? lerpColor('#081420', '#302010', 1 - bloatT) : '#081420');
  mantleGrad.addColorStop(0.85, isBloated ? lerpColor('#102030', '#402020', 1 - bloatT) : '#102030');
  mantleGrad.addColorStop(1, isBloated ? lerpColor(accent, '#ff4040', (1 - bloatT) * 0.7) : accent);
  ctx.fillStyle = mantleGrad;
  ctx.beginPath();
  for (let p = 0; p <= mantlePts; p++) {
    const angle = (p / mantlePts) * Math.PI * 2;
    const wobble = Math.sin(angle * 4 + b.phase * 0.8) * 0.06 +
                   Math.sin(angle * 7 + b.phase * 1.3) * 0.03;
    // Bloat wobble: body ripples more violently when bloated
    const bloatWobble = isBloated ? Math.sin(angle * 5 + G.time * 8) * 0.08 * (1 - bloatT) : 0;
    const pr = r * (0.8 + wobble + bloatWobble);
    const px = b.x + Math.cos(angle) * pr;
    const py = b.y + Math.sin(angle) * pr;
    if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  // Bloat countdown pulse ring
  if (isBloated) {
    const urgency = 1 - bloatT; // 0→1 as time runs out
    const pulseAlpha = 0.2 + bloatPulse * 0.4 * urgency;
    const pulseR = r * (1.1 + bloatPulse * 0.15);
    ctx.globalAlpha = pulseAlpha;
    ctx.strokeStyle = urgency > 0.7 ? '#ff2020' : '#80ff60';
    ctx.lineWidth = 2 + urgency * 2;
    ctx.beginPath();
    ctx.arc(b.x, b.y, pulseR, 0, Math.PI * 2);
    ctx.stroke();
    // Countdown arc (shows remaining time)
    ctx.globalAlpha = 0.5 + bloatPulse * 0.3;
    ctx.strokeStyle = '#80ff60';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(b.x, b.y, r * 1.25, -Math.PI / 2, -Math.PI / 2 + bloatT * Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Layer 3: Maw
  if (b.mawOpen > 0.05) {
    const mawAngle = b.tentacles.length > 0 ? b.tentacles[0].angle : 0;
    const mawX = b.x + Math.cos(mawAngle) * r * 0.3;
    const mawY = b.y + Math.sin(mawAngle) * r * 0.3;
    const mawR = r * 0.3 * b.mawOpen;
    ctx.fillStyle = '#000008';
    ctx.beginPath();
    ctx.arc(mawX, mawY, mawR, 0, Math.PI * 2);
    ctx.fill();
    // Teeth
    ctx.strokeStyle = '#c0d0e0';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5 * b.mawOpen;
    const teethCount = 8;
    for (let tt = 0; tt < teethCount; tt++) {
      const ta = (tt / teethCount) * Math.PI * 2;
      ctx.beginPath();
      ctx.arc(mawX + Math.cos(ta) * mawR * 0.7, mawY + Math.sin(ta) * mawR * 0.7, 2, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Layer 4: Eyes (2 large, vertical slit pupils)
  for (let e = 0; e < b.eyePhases.length; e++) {
    const eye = b.eyePhases[e];
    const eAngle = eye.angle + Math.sin(b.phase * 0.3) * 0.1;
    const ex = b.x + Math.cos(eAngle) * r * eye.dist;
    const ey = b.y + Math.sin(eAngle) * r * eye.dist;
    const eR = r * eye.size * 1.3;

    // Bioluminescent halo
    ctx.globalAlpha = 0.15;
    ctx.globalCompositeOperation = 'lighter';
    const haloGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, eR * 2);
    haloGrad.addColorStop(0, accent);
    haloGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = haloGrad;
    ctx.beginPath();
    ctx.arc(ex, ey, eR * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    // Sclera
    ctx.fillStyle = '#d0e8e0';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.ellipse(ex, ey, eR, eR * 0.7, eAngle, 0, Math.PI * 2);
    ctx.fill();

    // Vertical slit pupil
    const lookDx = G.cursorX - ex, lookDy = G.cursorY - ey;
    const lookD = Math.sqrt(lookDx * lookDx + lookDy * lookDy) + 1;
    const lookStr = eR * 0.2;
    const irisX = ex + (lookDx / lookD) * lookStr;
    const irisY = ey + (lookDy / lookD) * lookStr;
    ctx.fillStyle = '#00806080';
    ctx.beginPath();
    ctx.ellipse(irisX, irisY, eR * 0.35, eR * 0.55, eAngle, 0, Math.PI * 2);
    ctx.fill();
    // Vertical slit
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.ellipse(irisX, irisY, eR * 0.08, eR * 0.4, eAngle, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ==================================================
// SECTION 11: UPGRADE SYSTEM LOGIC
// ==================================================
function checkLevelUp() {
  if (G.xp >= G.xpToNext) {
    G.level++;
    G.xp -= G.xpToNext;
    G.xpToNext = Math.floor(G.xpToNext * XP_SCALE);

    // Update tap timer max for new level (more generous as you progress)
    G.tapTimerMax = getTapTimerMax();

    // Level-up reward: +1 bonus tap
    G.taps += 1;
    spawnFloatingText(G.W / 2, G.H * 0.25, '+1 TAP', '#00ffa0');

    // Palette transition
    const newPaletteIdx = Math.min(Math.floor((G.level - 1) / PALETTE_LEVELS), PALETTES.length - 1);
    if (newPaletteIdx !== G.biomeIndex) {
      G.prevPalette = getCurrentPalette();
      G.prevBiomeIndex = G.biomeIndex;
      G.biomeIndex = newPaletteIdx;
      G.biomeTransition = 0;
    }

    showUpgradePanel();
  }
}

function showUpgradePanel() {
  const available = Object.keys(UPGRADE_DEFS).filter(k => G.upgrades[k] < UPGRADE_DEFS[k].maxLvl);
  if (available.length === 0) return;

  // Pick ONE random upgrade — no choice, fate decides
  const pickedKey = available[Math.floor(Math.random() * available.length)];
  const def = UPGRADE_DEFS[pickedKey];
  const nextLvl = G.upgrades[pickedKey] + 1;

  // Auto level-up: apply immediately with floating text
  if (autoLevelUp) {
    G.pendingLevelUp = true;
    selectUpgrade(pickedKey);
    const cx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const cy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.4;
    spawnFloatingText(cx, cy, `${def.name} Lv${G.upgrades[pickedKey]}`, '#00ffa0', 1.8);
    return;
  }

  G.pendingLevelUp = true;
  const container = document.getElementById('upgrade-choices');
  container.innerHTML = '';

  // Single upgrade card — tap to accept
  const card = document.createElement('div');
  card.className = 'upgrade-card';
  card.innerHTML = `<div class="name">${def.name}</div><div class="level">Level ${G.upgrades[pickedKey]} → ${nextLvl}</div><div class="desc">${def.desc(nextLvl)}</div>`;
  card.addEventListener('click', (e) => { e.stopPropagation(); selectUpgrade(pickedKey); });
  card.addEventListener('touchend', (e) => { e.stopPropagation(); e.preventDefault(); selectUpgrade(pickedKey); });
  container.appendChild(card);

  document.getElementById('upgrade-panel').style.display = 'flex';
}

function selectUpgrade(key) {
  // Guard against double-fire (touchend + click both trigger on mobile)
  if (!G.pendingLevelUp) return;

  G.upgrades[key]++;
  G.pendingLevelUp = false;
  document.getElementById('upgrade-panel').style.display = 'none';

  // Immediate effects
  if (key === 'density') {
    const toAdd = 6;
    for (let i = 0; i < toAdd; i++) {
      G.refillQueue.push(G.refillTimer + i * 0.06);
    }
  }

  // Excess XP carries over but only one level-up per level
  // (no recursive checkLevelUp — next level-up happens at end of next chain)

  // Re-check game over if taps ran out during chain before level-up
  if (!G.pendingLevelUp && G.taps <= 0) {
    G.state = 'game_over';
    showGameOver();
  }

  updateHUD();
}

// ==================================================
// SECTION 12: RENDERING PIPELINE
// ==================================================
function render() {
  const ctx = G.ctx;
  const W = G.W, H = G.H;

  ctx.save();

  // Layer 1: Background gradient (rendered at full canvas, before zoom)
  renderBackground(ctx, W, H);

  // Layer 1c: The Watcher — cosmic entity behind the field (madness-tied, full-canvas, before zoom)
  renderWatcher(ctx, W, H);

  // Layer 1d: Galaxy background — deep space nebula on top of Watcher (default biome only)
  renderGalaxyBackground(ctx, W, H);

  // Zoom: scale around screen center (applies to all game content)
  if (G.zoomLevel !== 1) {
    const cx = W / 2, cy = H / 2;
    ctx.translate(cx, cy);
    ctx.scale(G.zoomLevel, G.zoomLevel);
    ctx.translate(-cx, -cy);
  }

  // Screen shake
  if (G.shakeAmount > 0.5) {
    const sx = (Math.random() - 0.5) * G.shakeAmount;
    const sy = (Math.random() - 0.5) * G.shakeAmount;
    ctx.translate(sx, sy);
  }

  // Layer 1b: Nebula clouds (ambient color blobs)
  renderNebulaClouds(ctx, W, H);

  // Layer 1b2: ABYSS-specific deep-sea background effects
  renderAbyssBackground(ctx, W, H);

  // Layer 1b3: EXPANSE-specific desert background effects
  renderExpanseBackground(ctx, W, H);

  // Layer 1c2: Void Stars — the other side bleeds through at mid-high WT
  renderVoidStars(ctx, W, H);

  // Layer 2: Persistent paint splats (BLOOM)
  renderPaintSplats(ctx);

  // Layer 3: Orb bloom glow
  // renderOrbBloom(ctx); // disabled — blur(6px) per-orb tanks perf

  // Layer 4: Aftershock zones
  renderAftershocks(ctx);

  // Layer 4b: Gravity wells
  renderGravityWells(ctx);

  // Layer 4b2: Rift Walls — energy barriers
  renderRiftWalls(ctx);

  // Layer 4c: Black hole + supermassive black hole
  renderBlackHole(ctx);
  renderSuperBlackHole(ctx);
  renderMiniBlackHoles(ctx);

  // Layer 4d: Boss entity
  renderBoss(ctx);

  // Layer 4e: Wormhole (B1 level ending)
  renderWormhole(ctx);

  // Layer 5: Background particles
  renderParticleLayer(ctx, 'bg');

  // Layer 5b: Chain links
  renderChainLinks(ctx);

  // Layer 5b2: Gravity bridges — energy connections between same-color orbs
  renderBridges(ctx);

  // Layer 5c: Bombs
  renderBombs(ctx);

  // Layer 5d: Shadow balls — dark phantom orbs behind normal circles
  renderShadowBalls(ctx);

  // Layer 6: Circles
  renderCircles(ctx);

  // Layer 6b: Hover proximity line — faint connection to nearest orb
  renderHoverProximity(ctx);

  // Layer 7: Explosions
  renderExplosions(ctx);

  // Layer 7b: Light rays from explosions
  renderLightRays(ctx, W, H);

  // Layer 7c: Chain energy field rings
  renderChainEnergyField(ctx, W, H);

  // Layer 8: Foreground particles
  renderParticleLayer(ctx, 'fg');

  // Layer 8b: TESTLEVEL lighting engine — darkness, point light at cursor, orb shadows
  renderTestLevelLighting(ctx, W, H);

  // Layer 9: Floating texts
  renderFloatingTexts(ctx);

  // Layer 10b: Delayed blast buildup (stays in zoom-space — centered on game point)
  if (G.delayedBlast && !G.delayedBlast.executed) {
    renderDelayedBlastBuildup(ctx, W, H);
  }

  ctx.restore();

  // Post-processing (no shake/zoom offset — full screen coverage)
  // Layer 10: White-hot glow (moved outside zoom so it always covers full screen)
  if (G.whiteGlow > 0.01) {
    renderWhiteGlow(ctx, W, H);
  }

  // Layer 12: Vignette
  renderVignette(ctx, W, H);

  // Layer 13: Chromatic aberration
  if (G.chromaticAb > 0.3) {
    renderChromaticAb(ctx, W, H);
  }

  // Layer 14: Tap timer bar (top of screen, under HUD) — prominent
  if (G.state === 'playing' && G.taps > 0 && !G.chainActive && !G.pendingLevelUp) {
    const timerT = Math.max(0, G.tapTimer / G.tapTimerMax);
    const barH = 6; // thicker bar for visibility
    const barY = 0; // top of screen — maximum visibility
    ctx.save();
    // Background track
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, barY, W, barH);
    // Fill — changes color as time runs low, brighter overall
    ctx.globalAlpha = 0.6 + (1 - timerT) * 0.4;
    if (timerT > 0.4) ctx.fillStyle = '#ffffff';
    else if (timerT > 0.15) ctx.fillStyle = '#ffd84d';
    else ctx.fillStyle = '#ff3c8e';
    ctx.fillRect(0, barY, W * timerT, barH);
    // Glow effect when time is low
    if (timerT < 0.25) {
      ctx.globalAlpha = (0.25 - timerT) * 1.5;
      ctx.shadowColor = timerT > 0.15 ? '#ffd84d' : '#ff3c8e';
      ctx.shadowBlur = 12;
      ctx.fillRect(0, barY, W * timerT, barH);
    }
    ctx.restore();
  }

  // Layer 14b: Dark Prism gravity inversion indicator (smooth)
  const invertVisual = Math.max(0, 0.5 - G.gravityInvertFactor); // 0 normal → 1 fully inverted
  if (invertVisual > 0.01 || G.prismClusterActive) {
    ctx.save();
    const effectStrength = G.prismClusterActive ? Math.max(invertVisual, 0.3) : invertVisual;
    const pulse = 0.6 + 0.4 * Math.sin(G.time * 5);
    // Screen-wide purple tint overlay (scales with inversion)
    ctx.globalAlpha = 0.15 * pulse * effectStrength;
    ctx.fillStyle = '#3a0a5e';
    ctx.fillRect(0, 0, W, H);
    // Vignette-style edge glow
    ctx.globalAlpha = 0.3 * pulse * effectStrength;
    const vig = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.25, W/2, H/2, Math.max(W,H)*0.7);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, '#2a0040');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);
    // Purple radial pulse from field center
    if (effectStrength > 0.3) {
      const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
      const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
      const pulseR = 80 + Math.sin(G.time * 3) * 40 + effectStrength * 200;
      ctx.globalAlpha = 0.08 * effectStrength * pulse;
      const radPulse = ctx.createRadialGradient(gcx, gcy, 0, gcx, gcy, pulseR);
      radPulse.addColorStop(0, '#b040ff');
      radPulse.addColorStop(0.5, '#6020a0');
      radPulse.addColorStop(1, 'transparent');
      ctx.fillStyle = radPulse;
      ctx.beginPath();
      ctx.arc(gcx, gcy, pulseR, 0, Math.PI * 2);
      ctx.fill();
    }
    // Large centered banner text
    ctx.globalAlpha = 0.95;
    ctx.font = '700 22px Orbitron, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#d0a0ff';
    ctx.shadowColor = '#a050ff';
    ctx.shadowBlur = 20;
    const label = G.prismClusterActive ? 'DARK PRISM ACTIVE' : 'DARK PRISM [' + G.gravityInvertTimer.toFixed(1) + 's]';
    ctx.fillText(label, W / 2, 128);
    ctx.shadowBlur = 0;
    // Thin top/bottom edge lines
    ctx.globalAlpha = 0.3 * pulse * effectStrength;
    ctx.strokeStyle = '#a050ff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(W, 0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H); ctx.lineTo(W, H); ctx.stroke();
    ctx.restore();
  }

  // Layer 15: World Transparency milestone banner — dramatic full-width text
  if (G.wtBanner) {
    renderWTBanner(ctx, W, H);
  }
}

function renderWTBanner(ctx, W, H) {
  const b = G.wtBanner;
  if (!b) return;
  const t = b.timer / b.duration; // 0→1 over lifetime

  // Envelope: fast fade-in, hold, slow fade-out
  let alpha;
  if (t < 0.12) alpha = t / 0.12;           // fade in (0→1 over 12%)
  else if (t < 0.7) alpha = 1;               // hold
  else alpha = 1 - (t - 0.7) / 0.3;          // fade out (1→0 over 30%)
  alpha = Math.max(0, Math.min(1, alpha));

  // Slight vertical drift — text slowly rises
  const yDrift = -t * 15;
  const centerY = H * 0.38 + yDrift;

  ctx.save();

  // Dark vignette band behind text for readability
  ctx.globalAlpha = alpha * 0.5;
  const bandGrad = ctx.createLinearGradient(0, centerY - 60, 0, centerY + 70);
  bandGrad.addColorStop(0, 'rgba(0,0,0,0)');
  bandGrad.addColorStop(0.25, 'rgba(0,0,0,0.6)');
  bandGrad.addColorStop(0.5, 'rgba(0,0,0,0.7)');
  bandGrad.addColorStop(0.75, 'rgba(0,0,0,0.6)');
  bandGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bandGrad;
  ctx.fillRect(0, centerY - 60, W, 130);

  // Horizontal accent lines flanking the text
  ctx.globalAlpha = alpha * 0.4;
  ctx.strokeStyle = b.color;
  ctx.lineWidth = 1;
  const lineExtend = alpha * W * 0.35;
  ctx.beginPath();
  ctx.moveTo(W / 2 - lineExtend, centerY - 28);
  ctx.lineTo(W / 2 + lineExtend, centerY - 28);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(W / 2 - lineExtend * 0.7, centerY + 32);
  ctx.lineTo(W / 2 + lineExtend * 0.7, centerY + 32);
  ctx.stroke();

  // Main text — large, bold
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const fontSize = Math.min(48, W * 0.055);
  ctx.font = `bold ${fontSize}px 'Orbitron', 'Courier New', monospace`;

  // Text glow
  ctx.globalAlpha = alpha * 0.6;
  ctx.shadowColor = b.color;
  ctx.shadowBlur = 25;
  ctx.fillStyle = b.color;
  ctx.fillText(b.text, W / 2, centerY);

  // Solid text on top
  ctx.shadowBlur = 0;
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#ffffff';
  ctx.fillText(b.text, W / 2, centerY);

  // Subtext — smaller, colored
  const subSize = Math.min(18, W * 0.022);
  ctx.font = `600 ${subSize}px 'Orbitron', 'Courier New', monospace`;
  ctx.globalAlpha = alpha * 0.7;
  ctx.letterSpacing = '4px';
  ctx.fillStyle = b.color;
  ctx.fillText(b.subtext, W / 2, centerY + fontSize * 0.7 + 8);

  // Lore quote — smaller italic text below subtext
  if (b.lore) {
    const loreSize = Math.min(13, W * 0.015);
    ctx.font = `italic ${loreSize}px 'Georgia', serif`;
    ctx.letterSpacing = '0px';
    ctx.globalAlpha = alpha * 0.5;
    ctx.fillStyle = '#cccccc';
    ctx.fillText(b.lore, W / 2, centerY + fontSize * 0.7 + 8 + subSize + 16);
  }

  ctx.restore();
}

// ==================================================
// THE WATCHER — cosmic entity looming behind the field
// Appears gradually after 90s, fully visible by 120s
// A silhouette of pure blackness: head, shoulders, one reaching hand
// Glowing white eyes that brighten during chains
// Surrounded by its own nebula haze
// ==================================================
// Watcher appearance is now tied to madness level (no fixed timer)

// Watcher images — tied to madness, gradually appear from the background
// Main biome: Watcher_test1.jpeg | ABYSS biome: Watchr_2.jpeg
const watcherMainImg = new Image();
watcherMainImg.src = 'images/Watcher_test1.jpeg';
let watcherMainLoaded = false;
watcherMainImg.onload = () => { watcherMainLoaded = true; };

// Galaxy background — VIDEO rendered on top of Watcher in default biome only
// Slowed down, looping, with smooth transition at loop point
const galaxyBgVideo = document.createElement('video');
galaxyBgVideo.src = 'Images/GalaxyBG_test.mp4';
galaxyBgVideo.muted = true;
galaxyBgVideo.loop = true;
galaxyBgVideo.playsInline = true;
galaxyBgVideo.preload = 'auto';
try { galaxyBgVideo.playbackRate = 0.07; } catch(e) {} // ultra slow initial — scales with madness (0.07→0.25)
let galaxyBgLoaded = false;
let galaxyBgPlaying = false;
galaxyBgVideo.addEventListener('canplaythrough', () => { galaxyBgLoaded = true; });
// Start playing when user interacts (autoplay policy)
function ensureGalaxyBgPlaying() {
  if (!galaxyBgPlaying && galaxyBgLoaded) {
    galaxyBgVideo.play().then(() => { galaxyBgPlaying = true; }).catch(() => {});
  }
}
let galaxyBgOpacity = 0; // smoothly interpolated
// Fallback image in case video doesn't load
const galaxyBgImg = new Image();
galaxyBgImg.src = 'images/BG_Galax.jpg';
let galaxyBgImgLoaded = false;
galaxyBgImg.onload = () => { galaxyBgImgLoaded = true; };

const watcherAbyssImg = new Image();
watcherAbyssImg.src = 'images/Watchr_2.jpeg';
let watcherAbyssLoaded = false;
watcherAbyssImg.onload = () => { watcherAbyssLoaded = true; };

function updateWatcher(dt) {
  const w = G.watcher;
  w.breathPhase += dt * 0.6;

  // Opacity tied to madness — main biome 17%, ABYSS 12%
  const madness = getMadnessAmount();
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const maxOpacity = isAbyss ? 0.12 : 0.17; // main biome Watcher stronger
  const targetOpacity = madness * maxOpacity;
  // Fade in slowly, fade OUT quickly (especially when dev-toggling madness off)
  const fadeSpeed = w.opacity > targetOpacity ? 3.0 : 0.5;
  w.opacity += (targetOpacity - w.opacity) * dt * fadeSpeed;

  // Eye glow reacts to chains — subtle brightening
  const targetGlow = G.chainActive ? 0.3 + Math.min(0.4, G.chainCount * 0.015) : 0.1;
  w.eyeGlow += (targetGlow - w.eyeGlow) * dt * 3;

  // Reach reacts to black hole presence (supermassive = stronger reaction)
  let targetReach = G.blackHole ? 0.5 + G.blackHole.mass * 0.04 : 0;
  if (G.superBlackHole) targetReach = Math.max(targetReach, 0.7 + G.superBlackHole.mass * 0.06);
  w.reachAmount += (targetReach - w.reachAmount) * dt * 1.5;
}

function renderWatcher(ctx, W, H) {
  const w = G.watcher;
  if (w.opacity < 0.001) return;

  // Choose image based on biome
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const img = isAbyss ? watcherAbyssImg : watcherMainImg;
  const loaded = isAbyss ? watcherAbyssLoaded : watcherMainLoaded;
  if (!loaded) return;

  ctx.save();

  // Cover the full canvas, centered — very subtle breathing and drift
  const breathe = 1 + Math.sin(w.breathPhase) * 0.003;
  const imgW = img.width;
  const imgH = img.height;
  const coverScale = Math.max(W / imgW, H / imgH) * 1.03 * breathe;
  const drawW = imgW * coverScale;
  const drawH = imgH * coverScale;
  const drawX = (W - drawW) / 2 + Math.sin(w.breathPhase * 0.15) * 2;
  const drawY = (H - drawH) / 2 + Math.cos(w.breathPhase * 0.1) * 1.5;

  // Main draw — opacity capped at 12%, tied to madness
  ctx.globalAlpha = w.opacity;
  ctx.drawImage(img, drawX, drawY, drawW, drawH);

  // Very subtle glow overlay during chains (additive blend)
  if (w.eyeGlow > 0.15 && w.opacity > 0.005) {
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = w.opacity * (w.eyeGlow - 0.1) * 0.15;
    ctx.drawImage(img, drawX, drawY, drawW, drawH);
    ctx.globalCompositeOperation = 'source-over';
  }

  ctx.restore();
}

// Galaxy background — deep space nebula VIDEO layer rendered on top of Watcher
// Only in default biome. Gradually becomes visible. Different depth plane (slower parallax).
// Video plays at 15% speed, loops, with smooth crossfade at loop boundary.
function renderGalaxyBackground(ctx, W, H) {
  // Try to start video playback
  ensureGalaxyBgPlaying();

  const hasVideo = galaxyBgLoaded && galaxyBgPlaying && galaxyBgVideo.readyState >= 2;
  const hasImg = galaxyBgImgLoaded;
  if (!hasVideo && !hasImg) return;

  // Only in default biome (not ABYSS)
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (isAbyss) {
    galaxyBgOpacity = Math.max(0, galaxyBgOpacity - G.dt * 2.0);
    if (galaxyBgOpacity < 0.001) return;
  } else {
    const madness = getMadnessAmount();
    const targetGalaxyOpacity = madness < 0.05 ? 0 :
      Math.min(0.22, (madness - 0.05) / 0.55 * 0.22); // max 22% opacity
    const gFadeSpeed = galaxyBgOpacity > targetGalaxyOpacity ? 2.0 : 0.3;
    galaxyBgOpacity += (targetGalaxyOpacity - galaxyBgOpacity) * G.dt * gFadeSpeed;
  }

  if (galaxyBgOpacity < 0.001) return;

  // Playback rate scales with madness: slow at start, slightly faster at peak
  // Chrome minimum playbackRate is ~0.0625 — clamp to 0.07 for safety
  // 0% madness → 0.07× (very slow), 100% madness → 0.25× (still slow but noticeably moving)
  const vidMadness = getMadnessAmount();
  const MIN_PLAYBACK = 0.07; // Chrome minimum safe playback rate
  const basePlaybackRate = MIN_PLAYBACK + vidMadness * 0.18; // 0.07 → 0.25

  // Dark Prism: reverse video playback by manually decrementing currentTime
  const prismReverse = G.gravityInvertFactor < 0;

  // Smooth loop transition: slow down further near the end of the video
  // and apply a brief opacity dip at the loop seam
  let loopFade = 1.0;
  if (hasVideo && galaxyBgVideo.duration > 0) {
    if (prismReverse) {
      // Reverse: pause native playback and manually step backwards
      try { galaxyBgVideo.playbackRate = MIN_PLAYBACK; } catch(e) {}
      const reverseStep = basePlaybackRate * 3 * G.dt; // 3x speed in reverse for visible effect
      galaxyBgVideo.currentTime = Math.max(0.1, galaxyBgVideo.currentTime - reverseStep);
      // Wrap around to end if we hit the start
      if (galaxyBgVideo.currentTime <= 0.2) {
        galaxyBgVideo.currentTime = galaxyBgVideo.duration - 0.5;
      }
    } else {
      const timeLeft = galaxyBgVideo.duration - galaxyBgVideo.currentTime;
      const timeFromStart = galaxyBgVideo.currentTime;
      let targetRate = basePlaybackRate;
      // Near end (last 1.5s): ramp down for smooth loop
      if (timeLeft < 1.5) {
        targetRate = Math.max(MIN_PLAYBACK, basePlaybackRate * (timeLeft / 1.5));
        if (timeLeft < 0.5) loopFade = timeLeft / 0.5;
      }
      // Near start (first 0.5s): fade back in, ramp speed up
      else if (timeFromStart < 0.5) {
        loopFade = timeFromStart / 0.5;
        targetRate = MIN_PLAYBACK + (basePlaybackRate - MIN_PLAYBACK) * Math.min(1, timeFromStart / 1.0);
      }
      try { galaxyBgVideo.playbackRate = Math.max(MIN_PLAYBACK, targetRate); } catch(e) {}
    }
  }

  const w = G.watcher;
  ctx.save();

  const gBreathe = 1 + Math.sin(w.breathPhase * 0.25) * 0.015
                     + Math.sin(w.breathPhase * 0.13) * 0.008;
  const gDriftX = Math.sin(w.breathPhase * 0.07) * 14 + Math.sin(w.breathPhase * 0.19) * 5;
  const gDriftY = Math.cos(w.breathPhase * 0.05) * 10 + Math.cos(w.breathPhase * 0.14) * 4;

  // Use video if available, otherwise fall back to static image
  const src = hasVideo ? galaxyBgVideo : galaxyBgImg;
  const gImgW = hasVideo ? galaxyBgVideo.videoWidth : galaxyBgImg.width;
  const gImgH = hasVideo ? galaxyBgVideo.videoHeight : galaxyBgImg.height;
  if (gImgW === 0 || gImgH === 0) { ctx.restore(); return; }

  const gCoverScale = Math.max(W / gImgW, H / gImgH) * 1.12 * gBreathe;
  const gDrawW = gImgW * gCoverScale;
  const gDrawH = gImgH * gCoverScale;
  const gDrawX = (W - gDrawW) / 2 + gDriftX;
  const gDrawY = (H - gDrawH) / 2 + gDriftY;

  ctx.globalAlpha = galaxyBgOpacity * loopFade;
  ctx.globalCompositeOperation = 'screen';
  ctx.drawImage(src, gDrawX, gDrawY, gDrawW, gDrawH);

  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// Galaxy stars — persistent twinkle field
const galaxyStars = [];
for (let gs = 0; gs < 80; gs++) {
  galaxyStars.push({
    x: Math.random(),
    y: Math.random(),
    size: 0.3 + Math.random() * 1.2,
    phase: Math.random() * Math.PI * 2,
    twinkleSpeed: 0.5 + Math.random() * 2.0,
    bright: 0.3 + Math.random() * 0.7,
    colorTint: Math.floor(Math.random() * 3) // 0=white, 1=blueish, 2=warmish
  });
}
// Cosmic dust — slow-drifting particles
const cosmicDust = [];
for (let cd = 0; cd < 30; cd++) {
  cosmicDust.push({
    x: Math.random(),
    y: Math.random(),
    size: 0.5 + Math.random() * 2.0,
    speedX: (Math.random() - 0.5) * 0.002,
    speedY: (Math.random() - 0.5) * 0.001,
    phase: Math.random() * Math.PI * 2,
    alpha: 0.02 + Math.random() * 0.04,
    colorIdx: Math.floor(Math.random() * 3)
  });
}

// Living star field — huge particle cloud, moves gently, pulled by black holes
// Non-interactive but visually responsive; saturation tied to madness
const fieldStars = [];
const FIELD_STAR_COUNT = 200;
for (let fs = 0; fs < FIELD_STAR_COUNT; fs++) {
  fieldStars.push({
    x: Math.random(), y: Math.random(), // 0-1 normalized
    vx: (Math.random() - 0.5) * 0.003,
    vy: (Math.random() - 0.5) * 0.002,
    size: 0.3 + Math.random() * 1.0,
    bright: 0.2 + Math.random() * 0.8,
    phase: Math.random() * Math.PI * 2,
    colorIdx: Math.floor(Math.random() * 4) // 0=white, 1=blue, 2=gold, 3=violet
  });
}

function updateFieldStars(dt, W, H) {
  const hasBH = G.blackHoles.length > 0;
  for (let i = 0; i < fieldStars.length; i++) {
    const s = fieldStars[i];
    // Gentle drift
    s.x += s.vx * dt;
    s.y += s.vy * dt;

    // Black hole gravity pull (world coords) — all black holes
    if (hasBH) {
      for (let bhi = 0; bhi < G.blackHoles.length; bhi++) {
      const bh = G.blackHoles[bhi];
      const sx = s.x * W, sy = s.y * H;
      const dx = bh.x - sx, dy = bh.y - sy;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < bh.gravityRadius && d > 5) {
        const pull = 0.15 * dt / Math.max(d / bh.gravityRadius, 0.1);
        s.vx += (dx / d) * pull / W;
        s.vy += (dy / d) * pull / H;
        // Tangential spin
        s.vx += (-dy / d) * pull * 0.3 / W;
        s.vy += (dx / d) * pull * 0.3 / H;
      }
      } // end for each black hole
    }

    // Supermassive black hole — stronger pull on stars
    if (G.superBlackHole) {
      const sbh = G.superBlackHole;
      const sx = s.x * W, sy = s.y * H;
      const dx = sbh.x - sx, dy = sbh.y - sy;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < sbh.gravityRadius && d > 5) {
        const pull = 0.4 * dt / Math.max(d / sbh.gravityRadius, 0.1);
        s.vx += (dx / d) * pull / W;
        s.vy += (dy / d) * pull / H;
        s.vx += (-dy / d) * pull * 0.25 / W;
        s.vy += (dx / d) * pull * 0.25 / H;
      }
    }

    // Dampen velocity gently (stars shouldn't accumulate wild speed)
    s.vx *= (1 - dt * 0.3);
    s.vy *= (1 - dt * 0.3);
    // Minimum drift so they don't freeze
    if (Math.abs(s.vx) < 0.0005) s.vx = (Math.random() - 0.5) * 0.002;
    if (Math.abs(s.vy) < 0.0005) s.vy = (Math.random() - 0.5) * 0.001;

    // Wrap around
    if (s.x < -0.02) s.x = 1.02;
    if (s.x > 1.02) s.x = -0.02;
    if (s.y < -0.02) s.y = 1.02;
    if (s.y > 1.02) s.y = -0.02;
  }
}

function renderFieldStars(ctx, W, H) {
  const madness = getMadnessAmount();
  const p = getCurrentPalette();
  const starColors = ['#ffffff', '#aaccff', '#ffd080', '#c0a0ff'];

  ctx.save();
  for (let i = 0; i < fieldStars.length; i++) {
    const s = fieldStars[i];
    const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(G.time * 1.2 + s.phase));
    let color = starColors[s.colorIdx];
    // Chromatic shift with madness (B1: intensify, ABYSS: inverse sat)
    if (madness > 0) {
      color = biomeColorShift(color, madness * 0.7);
    }
    ctx.globalAlpha = 0.06 * s.bright * twinkle * (1 - madness * 0.7); // stars consumed by void faster (was 0.4)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(s.x * W, s.y * H, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

// ==================================================
// VOID STARS — Thousands of stars from "the other side" bleeding through
// Visible at mid-high World Transparency (40%+), density scales with WT
// Gently pulled by black holes, NOT by cursor. Sits between BG and orbs.
// ==================================================
const VOID_STAR_COUNT = 2000;
const VOID_STAR_MIN_WT = 0.35;  // start appearing at 35% WT
const voidStars = [];
for (let vs = 0; vs < VOID_STAR_COUNT; vs++) {
  const layer = Math.random(); // 0=deep background, 1=closer
  voidStars.push({
    x: Math.random(),
    y: Math.random(),
    vx: (Math.random() - 0.5) * 0.0008 * (0.3 + layer * 0.7),
    vy: (Math.random() - 0.5) * 0.0005 * (0.3 + layer * 0.7),
    size: 0.3 + layer * 0.9 + Math.random() * 0.5,
    bright: 0.15 + Math.random() * 0.85,
    phase: Math.random() * Math.PI * 2,
    blinkSpeed: 0.4 + Math.random() * 2.5,   // how fast it twinkles
    blinkDepth: 0.15 + Math.random() * 0.6,   // how much brightness varies
    layer: layer,
    colorType: Math.floor(Math.random() * 6)   // 0=white, 1=cool blue, 2=warm gold, 3=pale violet, 4=ice, 5=rose
  });
}

function updateVoidStars(dt, W, H) {
  const madness = getMadnessAmount();
  if (madness < VOID_STAR_MIN_WT) return; // skip if not visible

  const hasBH = G.blackHoles && G.blackHoles.length > 0;
  const hasSBH = G.superBlackHole;

  for (let i = 0; i < VOID_STAR_COUNT; i++) {
    const s = voidStars[i];

    // Gentle drift
    s.x += s.vx * dt;
    s.y += s.vy * dt;

    // Black hole gravity — gentle pull, stronger for closer-layer stars
    if (hasBH) {
      for (let bhi = 0; bhi < G.blackHoles.length; bhi++) {
        const bh = G.blackHoles[bhi];
        const sx = s.x * W, sy = s.y * H;
        const dx = bh.x - sx, dy = bh.y - sy;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < bh.gravityRadius * 1.5 && d > 5) {
          const layerMult = 0.3 + s.layer * 0.7; // deep stars less affected
          const pull = 0.08 * layerMult * dt / Math.max(d / bh.gravityRadius, 0.15);
          s.vx += (dx / d) * pull / W;
          s.vy += (dy / d) * pull / H;
          // Gentle tangential swirl
          s.vx += (-dy / d) * pull * 0.2 / W;
          s.vy += (dx / d) * pull * 0.2 / H;
        }
      }
    }

    // Supermassive black hole — stronger
    if (hasSBH) {
      const sbh = G.superBlackHole;
      const sx = s.x * W, sy = s.y * H;
      const dx = sbh.x - sx, dy = sbh.y - sy;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < sbh.gravityRadius * 1.5 && d > 5) {
        const layerMult = 0.3 + s.layer * 0.7;
        const pull = 0.2 * layerMult * dt / Math.max(d / sbh.gravityRadius, 0.15);
        s.vx += (dx / d) * pull / W;
        s.vy += (dy / d) * pull / H;
        s.vx += (-dy / d) * pull * 0.15 / W;
        s.vy += (dx / d) * pull * 0.15 / H;
      }
    }

    // Dampen — void stars should be calm, not chaotic
    s.vx *= (1 - dt * 0.2);
    s.vy *= (1 - dt * 0.2);
    // Minimum drift
    if (Math.abs(s.vx) < 0.0002) s.vx = (Math.random() - 0.5) * 0.0006;
    if (Math.abs(s.vy) < 0.0002) s.vy = (Math.random() - 0.5) * 0.0004;

    // Wrap
    if (s.x < -0.03) s.x = 1.03;
    if (s.x > 1.03) s.x = -0.03;
    if (s.y < -0.03) s.y = 1.03;
    if (s.y > 1.03) s.y = -0.03;
  }
}

function renderVoidStars(ctx, W, H) {
  const madness = getMadnessAmount();
  if (madness < VOID_STAR_MIN_WT) return;

  // Visibility ramps from 0 at threshold to full at ~70% WT
  const visibility = Math.min(1, (madness - VOID_STAR_MIN_WT) / 0.35);
  const voidStarColors = [
    '#e8e8f0',  // 0: cool white
    '#a0c0e8',  // 1: pale blue
    '#e8d0a0',  // 2: warm gold
    '#c8b0e0',  // 3: pale violet
    '#b0d8e8',  // 4: ice blue
    '#e0b0c0'   // 5: dusty rose
  ];

  ctx.save();
  for (let i = 0; i < VOID_STAR_COUNT; i++) {
    const s = voidStars[i];

    // Twinkle — each star blinks at its own rate and depth
    const twinkle = 1 - s.blinkDepth + s.blinkDepth * Math.abs(Math.sin(G.time * s.blinkSpeed + s.phase));

    // Alpha: combines visibility ramp, star brightness, twinkle, and layer depth
    const layerAlpha = 0.3 + s.layer * 0.7; // deep stars dimmer
    const alpha = visibility * s.bright * twinkle * layerAlpha * 0.18;
    if (alpha < 0.005) continue; // skip invisible stars

    ctx.globalAlpha = alpha;
    ctx.fillStyle = voidStarColors[s.colorType];

    const sx = s.x * W, sy = s.y * H;
    const drawSize = s.size * (0.8 + visibility * 0.2);

    // Larger/brighter stars get a subtle cross-flare
    if (s.bright > 0.7 && drawSize > 1.0 && twinkle > 0.7) {
      const flareLen = drawSize * (1.5 + twinkle * 1.5);
      ctx.globalAlpha = alpha * 0.35;
      ctx.strokeStyle = voidStarColors[s.colorType];
      ctx.lineWidth = 0.4;
      ctx.beginPath();
      ctx.moveTo(sx - flareLen, sy);
      ctx.lineTo(sx + flareLen, sy);
      ctx.moveTo(sx, sy - flareLen);
      ctx.lineTo(sx, sy + flareLen);
      ctx.stroke();
      ctx.globalAlpha = alpha;
    }

    ctx.beginPath();
    ctx.arc(sx, sy, drawSize, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function renderBackground(ctx, W, H) {
  const p = getCurrentPalette();
  const madness = getMadnessAmount();
  const isAbyssBg = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const isExpanseBg = G.biomeOverride === 2;

  // At low madness, brighten the palette colors slightly for a more colorful start
  const brightBoost = (isAbyssBg || isExpanseBg) ? 0 : Math.max(0, 1 - madness * 2.5); // 1.0 at 0, 0 at 0.4+ madness
  let topColor = p.bgTop;
  let botColor = p.bgBot;

  if (G.biomeTransition < 1) {
    const prev = G.prevPalette || PALETTES[G.prevBiomeIndex] || PALETTES[0];
    topColor = lerpColor(prev.bgTop, p.bgTop, G.biomeTransition);
    botColor = lerpColor(prev.bgBot, p.bgBot, G.biomeTransition);
  }

  if (isAbyssBg) {
    // ABYSS: Inverse color journey — pitch black → deep saturated ocean
    const sat = getAbyssSaturation();
    // At sat=0: pure black void. At sat=1: deep rich ocean tones
    const abyssTopVivid = '#041828'; // dark midnight blue (never too bright)
    const abyssBotVivid = '#020e1c'; // even darker
    topColor = lerpColor('#010108', abyssTopVivid, sat);
    botColor = lerpColor('#000004', abyssBotVivid, sat);
  } else {
    // Brighten at low madness — make background more colorful
    if (brightBoost > 0) {
      topColor = lerpColor(topColor, p.accent || '#3a1860', brightBoost * 0.15);
      botColor = lerpColor(botColor, p.colors ? p.colors[0] : '#2a0848', brightBoost * 0.1);
    }

    // Background drains with madness — color bleeds away, void encroaches
    if (madness > 0) {
      topColor = horrorShift(topColor, madness * 0.7);  // faster BG desaturation (was 0.5)
      botColor = horrorShift(botColor, madness * 0.7);
      const darkenExtra = madness * 0.5;                 // stronger darkening (was 0.4)
      topColor = lerpColor(topColor, '#020004', darkenExtra); // near-black void
      botColor = lerpColor(botColor, '#010002', darkenExtra); // deeper void
      // At 80%+ madness: push aggressively toward pure black
      if (madness > 0.8) {
        const abyssStr = (madness - 0.8) / 0.2;  // 0→1 over 80-100%
        topColor = lerpColor(topColor, '#010001', abyssStr * 0.7);
        botColor = lerpColor(botColor, '#000000', abyssStr * 0.8);
      }
    }
  }

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, topColor);
  grad.addColorStop(1, botColor);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Galaxy stars — visible at all times, fade slightly with high madness
  // ABYSS: stars are dim/desaturated at low madness, blooming with saturation
  let starAlpha;
  if (isAbyssBg) {
    const sat = getAbyssSaturation();
    starAlpha = 0.015 + sat * 0.08; // barely visible → moderately visible
  } else {
    starAlpha = 0.08 + brightBoost * 0.12 - madness * 0.06; // stars fade faster as void consumes (was 0.03)
  }
  if (starAlpha > 0.01) {
    const abySat = isAbyssBg ? getAbyssSaturation() : 1;
    const starTints = isAbyssBg
      ? [abyssDesaturate('#ffffff', abySat), abyssDesaturate('#aaddff', abySat), abyssDesaturate('#80ffcc', abySat)]
      : ['#ffffff', '#aaccff', '#ffd8a0'];
    for (let i = 0; i < galaxyStars.length; i++) {
      const s = galaxyStars[i];
      const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(G.time * s.twinkleSpeed + s.phase));
      ctx.globalAlpha = starAlpha * s.bright * twinkle;
      ctx.fillStyle = starTints[s.colorTint];
      ctx.beginPath();
      ctx.arc(s.x * W, s.y * H, s.size, 0, Math.PI * 2);
      ctx.fill();
      // Larger stars get a tiny cross glint
      if (s.size > 1.0 && twinkle > 0.8) {
        ctx.globalAlpha *= 0.3;
        ctx.strokeStyle = starTints[s.colorTint];
        ctx.lineWidth = 0.5;
        const sx = s.x * W, sy = s.y * H;
        ctx.beginPath();
        ctx.moveTo(sx - s.size * 2, sy);
        ctx.lineTo(sx + s.size * 2, sy);
        ctx.moveTo(sx, sy - s.size * 2);
        ctx.lineTo(sx, sy + s.size * 2);
        ctx.stroke();
      }
    }
  }

  // Living star field — huge particle cloud, pulled by black holes
  renderFieldStars(ctx, W, H);

  // Cosmic dust — drifting colored wisps, stronger at low madness
  // ABYSS: dust is greyscale at low sat, colorful at high sat
  const dustAlpha = isAbyssBg ? (0.1 + getAbyssSaturation() * 0.5) : (brightBoost * 0.8 + 0.2);
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < cosmicDust.length; i++) {
    const d = cosmicDust[i];
    d.x += d.speedX * (G.dt || 0.016);
    d.y += d.speedY * (G.dt || 0.016);
    if (d.x < -0.05) d.x = 1.05;
    if (d.x > 1.05) d.x = -0.05;
    if (d.y < -0.05) d.y = 1.05;
    if (d.y > 1.05) d.y = -0.05;
    const pulse = 0.5 + 0.5 * Math.sin(G.time * 0.4 + d.phase);
    ctx.globalAlpha = d.alpha * dustAlpha * pulse;
    let dColor;
    if (isAbyssBg) {
      const abySat2 = getAbyssSaturation();
      dColor = abyssDesaturate(p.colors[d.colorIdx], abySat2);
    } else {
      dColor = madness > 0 ? horrorShift(p.colors[d.colorIdx], madness * 0.5) : p.colors[d.colorIdx];
    }
    ctx.fillStyle = dColor;
    ctx.beginPath();
    ctx.arc(d.x * W, d.y * H, d.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';

  // Madness particles — more floating spacey dust as madness rises
  if (madness > 0.1) {
    const madDustCount = Math.floor(madness * 60); // 0 at 10%, up to 60 at full madness
    ctx.globalCompositeOperation = 'lighter';
    for (let md = 0; md < madDustCount; md++) {
      // Deterministic position that slowly drifts using time + index
      const mHash = ((md * 173 + 91) & 0xffff) / 65535;
      const mHash2 = ((md * 257 + 43) & 0xffff) / 65535;
      const mHash3 = ((md * 311 + 67) & 0xffff) / 65535;
      const mx = ((mHash + G.time * (0.001 + mHash3 * 0.003)) % 1.1) - 0.05;
      const my = ((mHash2 + G.time * (0.0005 + mHash * 0.002)) % 1.1) - 0.05;
      const mSize = 0.3 + mHash3 * 1.5;
      const pulse = 0.4 + 0.6 * Math.sin(G.time * (0.3 + mHash * 0.5) + md * 2.1);
      const mAlpha = madness * 0.03 * pulse;
      // Desaturated with madness — sickly grey-green tones
      const madColors = ['#556655', '#445566', '#665544', '#554455', '#334455'];
      ctx.globalAlpha = mAlpha;
      ctx.fillStyle = madColors[md % madColors.length];
      ctx.beginPath();
      ctx.arc(mx * W, my * H, mSize, 0, Math.PI * 2);
      ctx.fill();
      // Some get wispy tails
      if (mSize > 1.0 && mHash > 0.6) {
        ctx.globalAlpha = mAlpha * 0.4;
        ctx.strokeStyle = madColors[md % madColors.length];
        ctx.lineWidth = 0.4;
        const tailA = G.time * 0.2 + md;
        ctx.beginPath();
        ctx.moveTo(mx * W, my * H);
        ctx.lineTo(mx * W + Math.cos(tailA) * mSize * 4, my * H + Math.sin(tailA) * mSize * 4);
        ctx.stroke();
      }
    }
    ctx.globalCompositeOperation = 'source-over';
  }

  ctx.globalAlpha = 1;
}

function renderGrid(ctx, W, H) {
  const biome = getCurrentBiome();
  ctx.strokeStyle = biome.gridTint;
  ctx.lineWidth = 1;

  const horizon = H * 0.35;
  const vanishX = W * 0.5;
  const gridLines = 15;
  const spacing = (H - horizon) / gridLines;
  const scrollOffset = (G.time * 30) % spacing;

  // Horizontal lines — closer spacing near horizon, wider at bottom
  for (let i = 0; i <= gridLines; i++) {
    const t = i / gridLines;
    const y = horizon + (H - horizon) * (t * t) + scrollOffset * t;
    if (y > H || y < horizon) continue;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }

  // Vertical converging lines
  const vertLines = 20;
  for (let i = -vertLines/2; i <= vertLines/2; i++) {
    const bottomX = vanishX + i * (W / vertLines) * 1.5;
    ctx.beginPath();
    ctx.moveTo(vanishX, horizon);
    ctx.lineTo(bottomX, H);
    ctx.stroke();
  }
}

function renderPaintSplats(ctx) {
  const splatMadness = getMadnessAmount();
  for (let i = 0; i < G.paintSplats.length; i++) {
    const s = G.paintSplats[i];
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = splatMadness > 0 ? biomeColorShift(s.color, splatMadness * 0.7) : s.color;
    for (let j = 0; j < 5; j++) {
      const angle = (s.seed + j * 73) % (Math.PI * 2);
      const d = s.size * 0.3 * (((s.seed + j * 37) % 10) / 10);
      const r = s.size * (0.3 + 0.5 * (((s.seed + j * 51) % 10) / 10));
      ctx.beginPath();
      ctx.arc(s.x + Math.cos(angle)*d, s.y + Math.sin(angle)*d, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

function renderAftershocks(ctx) {
  for (let i = 0; i < G.aftershocks.length; i++) {
    const as = G.aftershocks[i];
    const t = as.life / as.maxLife;
    ctx.globalAlpha = t * 0.15;
    const grad = ctx.createRadialGradient(as.x, as.y, 0, as.x, as.y, as.radius);
    grad.addColorStop(0, as.color);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(as.x, as.y, as.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function renderGravityWells(ctx) {
  for (let i = 0; i < G.gravityWells.length; i++) {
    const gw = G.gravityWells[i];
    const t = gw.life / gw.maxLife;
    const progress = 1 - t;
    ctx.save();
    // Contracting ring
    ctx.globalAlpha = t * 0.35;
    ctx.strokeStyle = gw.color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(gw.x, gw.y, gw.radius * (1 - progress * 0.7), 0, Math.PI * 2);
    ctx.stroke();
    // Inner dashed ring
    ctx.globalAlpha = t * 0.2;
    ctx.setLineDash([4, 6]);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(gw.x, gw.y, gw.radius * 0.4 * (1 - progress * 0.5), 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }
}

function renderChainLinks(ctx) {
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const linkMadness = getMadnessAmount();

  for (let i = 0; i < G.chainLinks.length; i++) {
    const link = G.chainLinks[i];
    const target = findCircleById(link.targetId);
    if (!target || target.popped) continue;
    const progress = Math.min(link.timer / link.duration, 1);

    // Bezier control point — gentle organic curve
    const mx = (link.srcX + target.x) / 2;
    const my = (link.srcY + target.y) / 2;
    const dx = target.x - link.srcX;
    const dy = target.y - link.srcY;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    const nx = -dy / len;
    const ny = dx / len;

    if (isAbyss) {
      // === TENTACLE-STYLE CONNECTORS — sinuous, segmented, organic ===
      const wave1 = Math.sin(link.timer * 4 + i * 2.3) * (20 + len * 0.15);
      const wave2 = Math.sin(link.timer * 6 + i * 1.7 + 1.5) * (10 + len * 0.08);
      const cpx1 = mx * 0.6 + link.srcX * 0.4 + nx * wave1;
      const cpy1 = my * 0.6 + link.srcY * 0.4 + ny * wave1;
      const cpx2 = mx * 0.4 + target.x * 0.6 + nx * wave2;
      const cpy2 = my * 0.4 + target.y * 0.6 + ny * wave2;

      ctx.save();
      const p = getCurrentPalette();

      // Main tentacle stroke — thick, tapered
      ctx.globalAlpha = 0.3 + progress * 0.5;
      ctx.strokeStyle = linkMadness > 0 ? biomeColorShift(p.colors[i % 3], linkMadness * 0.5) : p.colors[i % 3];
      ctx.lineWidth = (2 + progress * 4) * Math.min(1, len / 30);
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(link.srcX, link.srcY);
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, target.x, target.y);
      ctx.stroke();

      // Inner glow line — brighter, thinner
      ctx.globalAlpha = (0.2 + progress * 0.4);
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = (1 + progress * 2) * Math.min(1, len / 30);
      ctx.beginPath();
      ctx.moveTo(link.srcX, link.srcY);
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, target.x, target.y);
      ctx.stroke();

      // Suction cup dots along the tentacle
      ctx.globalAlpha = 0.15 + progress * 0.2;
      ctx.fillStyle = '#001520';
      const suckerCount = Math.floor(len / 18);
      for (let s = 1; s < suckerCount; s++) {
        const t = s / suckerCount;
        const inv = 1 - t;
        // Cubic bezier sample
        const bx = inv*inv*inv*link.srcX + 3*inv*inv*t*cpx1 + 3*inv*t*t*cpx2 + t*t*t*target.x;
        const by = inv*inv*inv*link.srcY + 3*inv*inv*t*cpy1 + 3*inv*t*t*cpy2 + t*t*t*target.y;
        const suckerR = (1 + progress * 1.5) * (0.5 + 0.5 * Math.sin(t * Math.PI));
        ctx.beginPath();
        ctx.arc(bx, by, suckerR, 0, Math.PI * 2);
        ctx.fill();
      }

      // Bioluminescent pulse traveling along
      const pulseT = (link.timer * 2.5) % 1;
      const pt = pulseT, inv = 1 - pt;
      const px = inv*inv*inv*link.srcX + 3*inv*inv*pt*cpx1 + 3*inv*pt*pt*cpx2 + pt*pt*pt*target.x;
      const py = inv*inv*inv*link.srcY + 3*inv*inv*pt*cpy1 + 3*inv*pt*pt*cpy2 + pt*pt*pt*target.y;
      ctx.globalAlpha = (0.3 + progress * 0.5);
      ctx.globalCompositeOperation = 'lighter';
      const pulseGrad = ctx.createRadialGradient(px, py, 0, px, py, 6 + progress * 4);
      pulseGrad.addColorStop(0, p.accent);
      pulseGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = pulseGrad;
      ctx.beginPath();
      ctx.arc(px, py, 6 + progress * 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.restore();
    } else {
      // === METABALL-STYLE BLOB CONNECTOR — original style ===
      const wave = Math.sin(link.timer * 5 + i * 2.3) * (15 + len * 0.1);
      const cpx = mx + nx * wave;
      const cpy = my + ny * wave;

      ctx.save();
      ctx.globalAlpha = 0.25 + progress * 0.55;
      const linkBaseColor = linkMadness > 0 ? biomeColorShift(link.color, linkMadness * 0.5) : link.color;
      ctx.fillStyle = fireShift(linkBaseColor, linkMadness);

      const srcR = (8 + progress * 6) * Math.min(1, len / 40);
      const tgtR = (7 + progress * 7) * Math.min(1, len / 40);

      const steps = 24;
      const leftPts = [], rightPts = [];
      for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const inv = 1 - t;
        const bx = inv * inv * link.srcX + 2 * inv * t * cpx + t * t * target.x;
        const by = inv * inv * link.srcY + 2 * inv * t * cpy + t * t * target.y;
        const tx2 = 2 * (inv * (cpx - link.srcX) + t * (target.x - cpx));
        const ty2 = 2 * (inv * (cpy - link.srcY) + t * (target.y - cpy));
        const tl = Math.sqrt(tx2 * tx2 + ty2 * ty2) || 1;
        const tnx = -ty2 / tl;
        const tny = tx2 / tl;
        const fromSrc = t;
        const fromTgt = 1 - t;
        const srcBlob = Math.exp(-fromSrc * fromSrc * 12) * srcR;
        const tgtBlob = Math.exp(-fromTgt * fromTgt * 12) * tgtR;
        const neckW = (1.5 + progress * 2.5) * (0.6 + 0.4 * Math.sin(t * Math.PI));
        const w = Math.max(srcBlob, tgtBlob, neckW) * 0.5;
        const wobble = Math.sin(link.timer * 6 + t * 12 + i) * 0.8 * progress;
        leftPts.push([bx + tnx * (w + wobble), by + tny * (w + wobble)]);
        rightPts.push([bx - tnx * (w + wobble), by - tny * (w + wobble)]);
      }

      ctx.beginPath();
      ctx.moveTo(leftPts[0][0], leftPts[0][1]);
      for (let s = 1; s <= steps; s++) {
        if (s < steps) {
          const cx2 = (leftPts[s][0] + leftPts[s+1 > steps ? s : s+1][0]) / 2;
          const cy2 = (leftPts[s][1] + leftPts[s+1 > steps ? s : s+1][1]) / 2;
          ctx.quadraticCurveTo(leftPts[s][0], leftPts[s][1], cx2, cy2);
        } else {
          ctx.lineTo(leftPts[s][0], leftPts[s][1]);
        }
      }
      for (let s = steps; s >= 0; s--) {
        if (s > 0) {
          const cx2 = (rightPts[s][0] + rightPts[s-1][0]) / 2;
          const cy2 = (rightPts[s][1] + rightPts[s-1][1]) / 2;
          ctx.quadraticCurveTo(rightPts[s][0], rightPts[s][1], cx2, cy2);
        } else {
          ctx.lineTo(rightPts[s][0], rightPts[s][1]);
        }
      }
      ctx.closePath();
      ctx.fill();

      // Small blob pulse traveling along
      const pulseT = (link.timer * 2) % 1;
      const pt = pulseT;
      const invPt = 1 - pt;
      const px = invPt * invPt * link.srcX + 2 * invPt * pt * cpx + pt * pt * target.x;
      const py = invPt * invPt * link.srcY + 2 * invPt * pt * cpy + pt * pt * target.y;
      ctx.globalAlpha = (0.4 + progress * 0.4) * ctx.globalAlpha;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(px, py, 1.5 + progress * 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }
}

// === DEFAULT SC: Amorphous eye-cluster entity — at high madness becomes grotesque mass ===
// Low madness: pulsating organic blob with eyes
// High madness: disfigured horror — extra wings, arms, rib cage, more eyes, all desaturated
function renderDefaultSC(ctx, c, drawR) {
  const scAlpha = c.scFade !== undefined ? c.scFade : 1;
  const arms = c.spikeCount;
  const idSeed = c.id * 3.17;
  const phase = c.pulsePhase;
  const madness = getMadnessAmount();
  // Grotesque factor: 0 below 60%, ramps to 1.0 at 100%
  const grotesque = Math.max(0, Math.min(1, (madness - 0.6) / 0.4));
  // Desaturate SC color at high madness
  const scColor = madness > 0.5 ? horrorShift(c.color, madness * 1.2) : c.color;

  // Layer 0: Eerie radiance — dims and greys out at high madness
  ctx.globalAlpha = scAlpha * (0.06 - grotesque * 0.03);
  const glowR = drawR * (2.2 + grotesque * 0.8);
  const glowGrad = ctx.createRadialGradient(c.x, c.y, drawR * 0.2, c.x, c.y, glowR);
  const glowCenter = grotesque > 0.5 ? '#a09080' : '#ffe0a0';
  const glowMid = grotesque > 0.5 ? '#605040' : '#a06030';
  glowGrad.addColorStop(0, glowCenter);
  glowGrad.addColorStop(0.5, glowMid);
  glowGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = glowGrad;
  ctx.beginPath();
  ctx.arc(c.x, c.y, glowR, 0, Math.PI * 2);
  ctx.fill();

  // Layer 0b: WINGS — torn membrane wings at high madness, flapping irregularly
  if (grotesque > 0.1) {
    const wingCount = 2 + Math.floor(grotesque * 3); // 2-5 wings
    for (let w = 0; w < wingCount; w++) {
      const wSeed = w * 11.3 + idSeed;
      const side = (w % 2 === 0) ? 1 : -1;
      const wingBase = (Math.PI * 0.5 * side) + (w * 0.6 + Math.sin(wSeed) * 0.4);
      const flapAngle = wingBase + Math.sin(phase * (2.5 + w * 0.4) + wSeed) * 0.35 * grotesque;
      const wingLen = drawR * (0.8 + grotesque * 1.2 + Math.sin(phase * 1.8 + wSeed) * 0.3);
      const wingW = drawR * (0.15 + grotesque * 0.15);
      // Torn membrane shape
      ctx.globalAlpha = scAlpha * 0.3 * grotesque;
      ctx.fillStyle = scColor;
      ctx.beginPath();
      const wsx = c.x + Math.cos(flapAngle - 0.15) * drawR * 0.3;
      const wsy = c.y + Math.sin(flapAngle - 0.15) * drawR * 0.3;
      ctx.moveTo(wsx, wsy);
      // Wing membrane with jagged tears
      const wingSegs = 6;
      for (let ws = 1; ws <= wingSegs; ws++) {
        const wt = ws / wingSegs;
        const tearOff = Math.sin(wSeed * 3 + ws * 2.7 + phase * 1.5) * wingW * 0.5 * grotesque;
        const wx = c.x + Math.cos(flapAngle + Math.sin(wt * 2 + phase) * 0.1) * wingLen * wt;
        const wy = c.y + Math.sin(flapAngle + Math.sin(wt * 2 + phase) * 0.1) * wingLen * wt + tearOff;
        ctx.lineTo(wx, wy);
      }
      // Return path with tears
      for (let ws = wingSegs; ws >= 1; ws--) {
        const wt = ws / wingSegs;
        const tearOff = Math.sin(wSeed * 5 + ws * 1.9 + phase) * wingW * 0.3 * grotesque;
        const wx = c.x + Math.cos(flapAngle + 0.08 + Math.sin(wt * 2 + phase) * 0.08) * wingLen * wt * 0.85;
        const wy = c.y + Math.sin(flapAngle + 0.08 + Math.sin(wt * 2 + phase) * 0.08) * wingLen * wt * 0.85 + tearOff;
        ctx.lineTo(wx, wy);
      }
      ctx.closePath();
      ctx.fill();
      // Wing veins/bones
      ctx.globalAlpha = scAlpha * 0.15 * grotesque;
      ctx.strokeStyle = '#8a7a6a';
      ctx.lineWidth = 0.6;
      const boneSegs = 3 + Math.floor(grotesque * 2);
      for (let bn = 0; bn < boneSegs; bn++) {
        const bAngle = flapAngle + (bn - boneSegs / 2) * 0.12;
        ctx.beginPath();
        ctx.moveTo(c.x + Math.cos(bAngle) * drawR * 0.25, c.y + Math.sin(bAngle) * drawR * 0.25);
        ctx.lineTo(c.x + Math.cos(bAngle) * wingLen * 0.7, c.y + Math.sin(bAngle) * wingLen * 0.7);
        ctx.stroke();
      }
    }
  }

  // Layer 1: Pulsating organic pseudopods/arms — MORE at high madness
  const podCount = arms + 2 + Math.floor(grotesque * 5); // extra disfigured limbs
  for (let p = 0; p < podCount; p++) {
    const pSeed = p * 5.71 + idSeed;
    const baseAngle = (p / podCount) * Math.PI * 2 + Math.sin(pSeed) * 0.5;
    const waveAngle = baseAngle + Math.sin(phase * (1.5 + p * 0.3) + pSeed) * (0.25 + grotesque * 0.3);
    const podLen = drawR * (0.6 + 0.5 * Math.sin(phase * 1.2 + pSeed * 2) + grotesque * 0.4);
    const podW = drawR * (0.12 + 0.06 * Math.sin(pSeed * 3) + grotesque * 0.05);

    ctx.globalAlpha = scAlpha * 0.45;
    ctx.fillStyle = scColor;
    const startR = drawR * 0.35;
    const sx = c.x + Math.cos(waveAngle) * startR;
    const sy = c.y + Math.sin(waveAngle) * startR;
    const ex = c.x + Math.cos(waveAngle) * podLen;
    const ey = c.y + Math.sin(waveAngle) * podLen;
    const cpOff = Math.sin(phase * 2 + pSeed) * drawR * (0.15 + grotesque * 0.1);
    const perpX = -Math.sin(waveAngle);
    const perpY = Math.cos(waveAngle);

    ctx.beginPath();
    ctx.moveTo(sx + perpX * podW, sy + perpY * podW);
    ctx.quadraticCurveTo(
      (sx + ex) / 2 + perpX * (podW * 0.6 + cpOff),
      (sy + ey) / 2 + perpY * (podW * 0.6 + cpOff),
      ex, ey
    );
    ctx.quadraticCurveTo(
      (sx + ex) / 2 - perpX * (podW * 0.6 - cpOff),
      (sy + ey) / 2 - perpY * (podW * 0.6 - cpOff),
      sx - perpX * podW, sy - perpY * podW
    );
    ctx.closePath();
    ctx.fill();

    // At high grotesque: knobby joints along the arm
    if (grotesque > 0.4 && p < podCount * 0.6) {
      const joints = 1 + Math.floor(grotesque * 2);
      for (let j = 1; j <= joints; j++) {
        const jt = j / (joints + 1);
        const jx = sx + (ex - sx) * jt + Math.sin(phase * 3 + pSeed + j) * 2;
        const jy = sy + (ey - sy) * jt + Math.cos(phase * 3 + pSeed + j) * 2;
        ctx.globalAlpha = scAlpha * 0.25 * grotesque;
        ctx.fillStyle = '#9a8a7a';
        ctx.beginPath();
        ctx.arc(jx, jy, podW * 1.3 + Math.sin(phase + j) * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Layer 1b: RIB CAGE — curved bone arcs visible through body at high madness
  if (grotesque > 0.3) {
    const ribCount = 3 + Math.floor(grotesque * 4); // 3-7 ribs
    ctx.globalAlpha = scAlpha * 0.2 * grotesque;
    ctx.strokeStyle = '#b0a090';
    ctx.lineWidth = 0.8 + grotesque * 0.4;
    for (let r = 0; r < ribCount; r++) {
      const ribY = c.y + (r - ribCount / 2) * drawR * 0.12;
      const ribW = drawR * (0.35 + 0.1 * Math.sin(r * 1.7 + idSeed));
      const ribBend = Math.sin(phase * 1.5 + r * 0.8) * drawR * 0.04 * grotesque;
      ctx.beginPath();
      ctx.moveTo(c.x - ribW, ribY);
      ctx.quadraticCurveTo(c.x, ribY - ribW * 0.3 + ribBend, c.x + ribW, ribY);
      ctx.stroke();
    }
  }

  // Layer 2: Central body — blobby mass, desaturated at high madness
  ctx.globalAlpha = scAlpha * 0.75;
  const bodyCenterColor = grotesque > 0.5 ? 'rgba(180, 165, 150, 0.85)' : 'rgba(232, 208, 184, 0.85)';
  const bodyGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR * 0.55);
  bodyGrad.addColorStop(0, bodyCenterColor);
  bodyGrad.addColorStop(0.45, scColor);
  bodyGrad.addColorStop(0.75, scColor);
  bodyGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  const bodyPts = 24;
  for (let b = 0; b <= bodyPts; b++) {
    const t = (b / bodyPts) * Math.PI * 2;
    const wobble = 1 + (0.08 + grotesque * 0.06) * Math.sin(t * 5 + phase * 3 + idSeed)
                     + (0.05 + grotesque * 0.04) * Math.sin(t * 3 + phase * 2);
    const bR = drawR * 0.45 * wobble;
    const bx = c.x + Math.cos(t) * bR;
    const by = c.y + Math.sin(t) * bR;
    if (b === 0) ctx.moveTo(bx, by);
    else ctx.lineTo(bx, by);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 3: Multiple eyes — MORE at high madness, scattered everywhere including arms
  const eyeCount = 4 + Math.floor(arms * 0.8) + Math.floor(grotesque * 8);
  for (let e = 0; e < eyeCount; e++) {
    const eSeed = e * 7.13 + idSeed;
    const eAngle = (e / eyeCount) * Math.PI * 2 + Math.sin(eSeed) * 0.8;
    // Extra eyes extend further out along arms
    const maxDist = 0.45 + grotesque * 0.3;
    const eDist = drawR * (0.1 + (e / eyeCount) * maxDist + Math.sin(eSeed * 2) * 0.1);
    const ex = c.x + Math.cos(eAngle + Math.sin(phase * 0.8 + eSeed) * 0.15) * eDist;
    const ey = c.y + Math.sin(eAngle + Math.sin(phase * 0.8 + eSeed) * 0.15) * eDist;

    const blink = Math.max(0, Math.sin(phase * 1.3 + eSeed * 2.7));
    if (blink < 0.1) continue;

    const eyeR = (drawR * (0.07 + grotesque * 0.02) + 1.5) * blink;

    // Fleshy surround — greyer at high madness
    ctx.globalAlpha = scAlpha * 0.4 * blink;
    ctx.fillStyle = grotesque > 0.5 ? '#a09888' : '#c8a890';
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR * 1.4, 0, Math.PI * 2);
    ctx.fill();

    // Sclera — duller/yellowed at high madness
    ctx.globalAlpha = scAlpha * 0.85 * blink;
    ctx.fillStyle = grotesque > 0.5 ? '#d8d0c0' : '#f0e8d8';
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR, 0, Math.PI * 2);
    ctx.fill();

    // Iris — looks toward cursor, desaturated at high madness
    const lookStr = eyeR * 0.25;
    const ldx = G.cursorX - ex, ldy = G.cursorY - ey;
    const lDist = Math.sqrt(ldx * ldx + ldy * ldy) + 1;
    const iOx = (ldx / lDist) * lookStr;
    const iOy = (ldy / lDist) * lookStr;
    const irisInner = grotesque > 0.5 ? '#8a8070' : '#c89540';
    const irisMid = grotesque > 0.5 ? '#6a6058' : '#8b6028';
    const irisOuter = grotesque > 0.5 ? '#4a4038' : '#5a3818';
    const irisGrad = ctx.createRadialGradient(ex + iOx, ey + iOy, eyeR * 0.08, ex + iOx, ey + iOy, eyeR * 0.6);
    irisGrad.addColorStop(0, irisInner);
    irisGrad.addColorStop(0.5, irisMid);
    irisGrad.addColorStop(1, irisOuter);
    ctx.fillStyle = irisGrad;
    ctx.beginPath();
    ctx.arc(ex + iOx, ey + iOy, eyeR * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Pupil — dilated at high madness
    const pupilSize = eyeR * (0.25 + grotesque * 0.15);
    ctx.fillStyle = '#0a0505';
    ctx.beginPath();
    ctx.arc(ex + iOx, ey + iOy, pupilSize, 0, Math.PI * 2);
    ctx.fill();

    // Specular — dimmer at high madness
    ctx.globalAlpha = scAlpha * (0.6 - grotesque * 0.3) * blink;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(ex + iOx - eyeR * 0.15, ey + iOy - eyeR * 0.15, eyeR * 0.12, 0, Math.PI * 2);
    ctx.fill();
  }

  // Layer 4: Orbiting motes — eerie energy, dimmer at high madness
  ctx.globalAlpha = scAlpha * (0.3 - grotesque * 0.15);
  const moteCount = 4 + arms;
  for (let s = 0; s < moteCount; s++) {
    const sSeed = s * 3.91 + idSeed;
    const sAngle = (s / moteCount) * Math.PI * 2 + phase * 2.5;
    const sR = drawR * (0.55 + 0.25 * Math.sin(sSeed + phase * 1.5));
    const sx = c.x + Math.cos(sAngle) * sR;
    const sy = c.y + Math.sin(sAngle) * sR;
    ctx.fillStyle = grotesque > 0.5 ? '#a09880' : (Math.sin(sSeed) > 0 ? '#ffe880' : scColor);
    ctx.beginPath();
    ctx.arc(sx, sy, 0.6 + Math.sin(sSeed * 5 + phase * 3) * 0.3, 0, Math.PI * 2);
    ctx.fill();
  }
}

// === ABYSS SC: Deep sea horror — writhing tentacle mass with bioluminescent eyes ===
function renderAbyssSC(ctx, c, drawR) {
  const scAlpha = c.scFade !== undefined ? c.scFade : 1;
  const arms = c.spikeCount;
  const idSeed = c.id * 3.17;
  const phase = c.pulsePhase;
  const p = getCurrentPalette();
  const scSat = getAbyssSaturation();
  const scSatColor = (hex) => abyssDesaturate(hex, scSat);

  // Layer 0: Bioluminescent glow
  ctx.globalAlpha = scAlpha * (0.03 + 0.08 * scSat); // dimmer in void
  const glowR = drawR * 2.5;
  const bioGrad = ctx.createRadialGradient(c.x, c.y, drawR * 0.1, c.x, c.y, glowR);
  bioGrad.addColorStop(0, scSatColor(p.accent));
  bioGrad.addColorStop(0.4, scSatColor(p.colors[0]));
  bioGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = bioGrad;
  ctx.beginPath();
  ctx.arc(c.x, c.y, glowR, 0, Math.PI * 2);
  ctx.fill();

  // Layer 1: Tentacles — long, sinuous, curling appendages
  const tentCount = arms + 3;
  for (let t = 0; t < tentCount; t++) {
    const tSeed = t * 4.31 + idSeed;
    const baseAngle = (t / tentCount) * Math.PI * 2 + Math.sin(tSeed) * 0.3;
    const tentLen = drawR * (0.8 + 0.6 * Math.sin(phase * 0.8 + tSeed));

    ctx.globalAlpha = scAlpha * 0.5;
    ctx.strokeStyle = scSatColor(p.colors[t % 3]);
    ctx.lineWidth = (3 + Math.sin(tSeed) * 1.5) * (drawR / 30);
    ctx.lineCap = 'round';

    // Multi-segment tentacle with increasing curl
    const segments = 6;
    ctx.beginPath();
    let tx = c.x, ty = c.y;
    let tAngle = baseAngle;
    ctx.moveTo(tx, ty);
    for (let s = 0; s < segments; s++) {
      const segLen = tentLen / segments;
      const curl = Math.sin(phase * (2 + t * 0.3) + s * 1.2 + tSeed) * (0.3 + s * 0.15);
      tAngle += curl;
      const nx = tx + Math.cos(tAngle) * segLen;
      const ny = ty + Math.sin(tAngle) * segLen;
      ctx.lineTo(nx, ny);
      tx = nx; ty = ny;
    }
    ctx.stroke();

    // Suction cups along tentacle
    ctx.globalAlpha = scAlpha * 0.2;
    ctx.fillStyle = '#001820';
    let sx2 = c.x, sy2 = c.y;
    let sAngle = baseAngle;
    for (let s = 1; s < segments; s++) {
      const segLen = tentLen / segments;
      const curl = Math.sin(phase * (2 + t * 0.3) + s * 1.2 + tSeed) * (0.3 + s * 0.15);
      sAngle += curl;
      sx2 += Math.cos(sAngle) * segLen;
      sy2 += Math.sin(sAngle) * segLen;
      if (s % 2 === 0) {
        ctx.beginPath();
        ctx.arc(sx2, sy2, 1.5 * (drawR / 30), 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Layer 2: Central mantle — dark, bulbous
  ctx.globalAlpha = scAlpha * 0.7;
  const mantleGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR * 0.5);
  mantleGrad.addColorStop(0, scSatColor('#002030'));
  mantleGrad.addColorStop(0.5, scSatColor('#001520'));
  mantleGrad.addColorStop(1, scSatColor(p.colors[0]));
  ctx.fillStyle = mantleGrad;
  ctx.beginPath();
  const mPts = 20;
  for (let m = 0; m <= mPts; m++) {
    const mA = (m / mPts) * Math.PI * 2;
    const wobble = 1 + 0.1 * Math.sin(mA * 4 + phase * 2 + idSeed);
    const mR = drawR * 0.4 * wobble;
    const mx = c.x + Math.cos(mA) * mR;
    const my = c.y + Math.sin(mA) * mR;
    if (m === 0) ctx.moveTo(mx, my);
    else ctx.lineTo(mx, my);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 3: Bioluminescent eyes — glowing, alien
  const eyeCount = 3 + Math.floor(arms * 0.6);
  for (let e = 0; e < eyeCount; e++) {
    const eSeed = e * 9.17 + idSeed;
    const eAngle = (e / eyeCount) * Math.PI * 2 + Math.sin(eSeed) * 0.4;
    const eDist = drawR * (0.08 + (e / eyeCount) * 0.35);
    const ex = c.x + Math.cos(eAngle) * eDist;
    const ey = c.y + Math.sin(eAngle) * eDist;

    const blink = Math.max(0, Math.sin(phase * 1.1 + eSeed * 3.1));
    if (blink < 0.15) continue;

    const eyeR = (drawR * 0.06 + 1.5) * blink;

    // Glowing sclera
    ctx.globalAlpha = scAlpha * 0.7 * blink;
    ctx.fillStyle = scSatColor(p.accent);
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR * 1.3, 0, Math.PI * 2);
    ctx.fill();

    // Dark pupil slit (vertical)
    ctx.globalAlpha = scAlpha * 0.9 * blink;
    ctx.fillStyle = '#000508';
    ctx.beginPath();
    ctx.ellipse(ex, ey, eyeR * 0.15, eyeR * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Glow halo
    ctx.globalAlpha = scAlpha * 0.15 * blink;
    ctx.globalCompositeOperation = 'lighter';
    const eyeGlow = ctx.createRadialGradient(ex, ey, 0, ex, ey, eyeR * 3);
    eyeGlow.addColorStop(0, scSatColor(p.accent));
    eyeGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = eyeGlow;
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR * 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
}

function renderCircles(ctx) {
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;

    let pulse = 1 + Math.sin(c.pulsePhase) * (c.superCell ? 0.15 : 0.08);
    // 100 BPM beat pulse — subtle spike on selected orbs at high madness
    if (G.beatPulseOrbs.length > 0 && G.beatPulseOrbs.indexOf(c.id) !== -1) {
      const beatT = G.beatPhase; // 0-1 per beat
      const beatPulse = beatT < 0.12 ? Math.sin(beatT / 0.12 * Math.PI) * 0.10 : 0;
      pulse += beatPulse;
    }
    const r = c.radius * pulse;
    const spawnScale = c.spawnAnim > 0 ? (1 - c.spawnAnim) : 1;
    const drawR = r * spawnScale;
    if (drawR < 1) continue;

    // === LOD (Level of Detail) — scale rendering complexity by screen pixel size ===
    // screenR = how big the orb actually appears on screen (accounting for zoom)
    const screenR = drawR * (G.zoomLevel || 1);
    // LOD 0: Full detail (screenR >= 12px)
    // LOD 1: Medium — skip veins, extra eyes, speculars, tentacle ridges (screenR >= 6px)
    // LOD 2: Simple — base fill + basic eye, no gradients, no trails (screenR >= 3px)
    // LOD 3: Dot — just a colored fill, no save/restore (screenR < 3px)
    const lod = screenR >= 12 ? 0 : screenR >= 6 ? 1 : screenR >= 3 ? 2 : 3;

    // Brighten orb color at WT <80% — keeps field vivid longer
    let orbColor = orbBrighten(c.color, getMadnessAmount());

    // LT: Saturation shift by light proximity — near light: +15%, far: -30%
    if (G.biomeOverride === 1 && G._ltR) {
      const _cs = _w2s(c.x, c.y);
      const ldx = _cs.x - G._ltLx, ldy = _cs.y - G._ltLy;
      const lDist = Math.sqrt(ldx * ldx + ldy * ldy);
      const ll = Math.max(0, 1 - lDist / G._ltR); // 1.0 at center, 0.0 at edge
      // Gradual: near light (ll>0.3) boost up to +0.25, far (ll<0.3) desaturate down to -0.30
      const satShift = ll > 0.3 ? (ll - 0.3) * 0.357 : -(1 - ll / 0.3) * 0.30;
      orbColor = adjustSaturationHex(orbColor, satShift);
    }

    // LOD 3: minimal dot — skip save/restore entirely
    if (lod === 3) {
      ctx.fillStyle = orbColor;
      ctx.beginPath();
      ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
      ctx.fill();
      continue;
    }

    ctx.save();

    // Merge animation: being absorbed into another orb — smooth stretch + gooey bridge + fade
    if (c.mergeTarget !== null && c.mergeTarget !== undefined) {
      const mProgress = Math.min(1, c.mergeAnimProgress);
      const target = findCircleById(c.mergeTarget);
      // Smooth ease for rendering
      const mEase = mProgress < 0.5 ? 2 * mProgress * mProgress : 1 - Math.pow(-2 * mProgress + 2, 2) / 2;
      const mColor = c.color; // already blending gradually in updateMergeAnimations
      // Gentle alpha fade — stays visible longer, fades smoothly at end
      ctx.globalAlpha = Math.max(0.02, 1 - mEase * mEase * 0.95);

      if (target && target.alive) {
        const dx = target.x - c.x;
        const dy = target.y - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        // Gooey bridge — smooth tapered bezier connecting absorbed orb to target
        if (dist > 2 && drawR > 1) {
          const bridgeAlpha = (1 - mEase) * (1 - mEase) * 0.5;
          ctx.globalAlpha = bridgeAlpha;
          const bridgeColor = lerpColor(c.color, target.color, mEase);
          ctx.fillStyle = bridgeColor;
          ctx.beginPath();
          // Tapered shape: width narrows smoothly
          const srcW = drawR * 0.6 * (1 - mEase * 0.6);
          const dstW = drawR * 0.3 * (1 - mEase * 0.4);
          const perpX = -Math.sin(angle);
          const perpY = Math.cos(angle);
          ctx.moveTo(c.x + perpX * srcW, c.y + perpY * srcW);
          // Bezier control point — organic bulge
          const bulge = srcW * (0.4 - mEase * 0.2);
          const cpx = (c.x + target.x) * 0.5 + perpX * bulge;
          const cpy = (c.y + target.y) * 0.5 + perpY * bulge;
          ctx.quadraticCurveTo(cpx, cpy, target.x + perpX * dstW, target.y + perpY * dstW);
          ctx.lineTo(target.x - perpX * dstW, target.y - perpY * dstW);
          const cpx2 = (c.x + target.x) * 0.5 - perpX * bulge;
          const cpy2 = (c.y + target.y) * 0.5 - perpY * bulge;
          ctx.quadraticCurveTo(cpx2, cpy2, c.x - perpX * srcW, c.y - perpY * srcW);
          ctx.closePath();
          ctx.fill();
        }

        // Stretched ellipse — smooth elongation toward target
        ctx.globalAlpha = Math.max(0.02, 1 - mEase * mEase * 0.95);
        ctx.fillStyle = mColor;
        const stretch = 1 + (c.mergeStretch || 0) * 1.2; // gentler max elongation
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(angle);
        ctx.scale(stretch, 1 / Math.sqrt(stretch));
        ctx.beginPath();
        ctx.arc(0, 0, drawR, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else {
        // No target — simple circle fallback
        ctx.fillStyle = mColor;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      continue;
    }

    // Fade-in alpha for orbs materializing from darkness
    if (c.fadeIn > 0) {
      const fadeAlpha = (1 - c.fadeIn);
      ctx.globalAlpha = fadeAlpha * fadeAlpha;
    }

    // Depth-of-field: at high madness, smaller/later-gen orbs appear further away
    // They get slightly more transparent and have a softer appearance
    const madnessDoF = getMadnessAmount();
    if (madnessDoF > 0.2 && c.generation > 0) {
      const depthFade = (c.generation / 3) * (madnessDoF - 0.2) * 0.6;
      ctx.globalAlpha = Math.max(0.2, (ctx.globalAlpha || 1) * (1 - depthFade));
    }

    // Motion blur trail — very subtle, only at high speed (LOD 0-1 only)
    if (lod <= 1 && c.trail && c.trail.length > 1) {
      const baseAlpha = ctx.globalAlpha || 1;
      const trailAlpha = baseAlpha * 0.07;
      // Connecting streak line from oldest trail to current position
      ctx.globalAlpha = trailAlpha * 0.3;
      ctx.strokeStyle = c.color;
      ctx.lineWidth = drawR * 0.2;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(c.trail[0].x, c.trail[0].y);
      for (let t = 1; t < c.trail.length; t++) {
        ctx.lineTo(c.trail[t].x, c.trail[t].y);
      }
      ctx.lineTo(c.x, c.y);
      ctx.stroke();
      // Ghost copies along trail — barely visible
      for (let t = 0; t < c.trail.length; t++) {
        const tp = c.trail[t];
        const tFade = (t + 1) / c.trail.length;
        ctx.globalAlpha = trailAlpha * tFade;
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(tp.x, tp.y, drawR * (0.2 + tFade * 0.3), 0, Math.PI * 2);
        ctx.fill();
      }
      // Restore alpha
      if (c.fadeIn > 0) {
        const fadeAlpha = (1 - c.fadeIn);
        ctx.globalAlpha = fadeAlpha * fadeAlpha;
      } else {
        ctx.globalAlpha = 1;
      }
    }

    // Spaghettification — MBH tidal stretch overrides velocity deformation when active
    if (c.stretchX && c.stretchX > 1.05) {
      ctx.translate(c.x, c.y);
      ctx.rotate(c.stretchAngle || 0);
      ctx.scale(c.stretchX, c.stretchY);
      ctx.rotate(-(c.stretchAngle || 0));
      ctx.translate(-c.x, -c.y);
    } else {
      // Velocity-based deformation — fluid stretch along movement direction (LOD 0-1 only)
      const speed = Math.sqrt(c.vx * c.vx + c.vy * c.vy);
      const deformThreshold = 20; // lower threshold — stretch starts at modest speeds
      if (lod <= 1 && speed > deformThreshold && (c.mergeTarget === null || c.mergeTarget === undefined)) {
        const deformAmount = Math.min(0.35, (speed - deformThreshold) / 400); // more visible, max 35%
        const velAngle = Math.atan2(c.vy, c.vx);
        ctx.translate(c.x, c.y);
        ctx.rotate(velAngle);
        ctx.scale(1 + deformAmount, 1 / (1 + deformAmount * 0.7)); // stretch + squash (area-preserving)
        ctx.rotate(-velAngle);
        ctx.translate(-c.x, -c.y);
      }
    }

    if (c.superCell) {
      const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';

      if (isAbyss) {
        // === ABYSS SC: TENTACLE HORROR — writhing mass with eyes ===
        renderAbyssSC(ctx, c, drawR);
      } else {
        // === DEFAULT SC: AMORPHOUS EYE-CLUSTER ENTITY ===
        renderDefaultSC(ctx, c, drawR);
      }
      // Phase 5: Render Archon tethers — pulsing energy lines to tethered orbs
      if (c.scTethers && c.scTethers.length > 0) {
        const tetheredPositions = []; // collect positions for inter-tether web
        for (let t = 0; t < c.scTethers.length; t++) {
          const teth = c.scTethers[t];
          const orb = findCircleById(teth.orbId);
          if (!orb || !orb.alive || orb.popped) continue;

          tetheredPositions.push({ x: orb.x, y: orb.y, r: orb.radius, pulse: teth.pulsePhase });
          const pulse = 0.5 + 0.5 * Math.sin(teth.pulsePhase);
          const scColor = c.color || '#ffcc00';

          // Outer energy beam
          ctx.globalAlpha = 0.15 + pulse * 0.2;
          ctx.strokeStyle = scColor;
          ctx.lineWidth = 2 + pulse * 1.5;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(c.x, c.y);
          ctx.lineTo(orb.x, orb.y);
          ctx.stroke();

          // Inner bright core
          ctx.globalAlpha = 0.25 + pulse * 0.35;
          ctx.strokeStyle = '#ffe080';
          ctx.lineWidth = 0.6 + pulse * 0.6;
          ctx.beginPath();
          ctx.moveTo(c.x, c.y);
          ctx.lineTo(orb.x, orb.y);
          ctx.stroke();

          // Glow ring on tethered orb — pulses in sync
          ctx.globalAlpha = 0.2 + pulse * 0.25;
          ctx.strokeStyle = scColor;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(orb.x, orb.y, orb.radius + 3 + pulse * 3, 0, Math.PI * 2);
          ctx.stroke();

          // Small energy node at midpoint
          const mx = (c.x + orb.x) / 2, my = (c.y + orb.y) / 2;
          ctx.globalAlpha = 0.3 + pulse * 0.3;
          ctx.fillStyle = '#ffe080';
          ctx.beginPath();
          ctx.arc(mx, my, 1.5 + pulse, 0, Math.PI * 2);
          ctx.fill();
        }

        // Inter-tether web — connect tethered orbs to each other (sigil-like geometry)
        if (tetheredPositions.length >= 2) {
          const scColor = c.color || '#ffcc00';
          for (let a = 0; a < tetheredPositions.length; a++) {
            for (let bb = a + 1; bb < tetheredPositions.length; bb++) {
              const pa = tetheredPositions[a], pb = tetheredPositions[bb];
              const interDist = Math.sqrt((pa.x - pb.x) * (pa.x - pb.x) + (pa.y - pb.y) * (pa.y - pb.y));
              if (interDist > 300) continue; // skip very distant pairs
              const interPulse = 0.5 + 0.5 * Math.sin(pa.pulse + pb.pulse + G.time * 2);
              // Thin connecting line between tethered orbs
              ctx.globalAlpha = 0.08 + interPulse * 0.08;
              ctx.strokeStyle = scColor;
              ctx.lineWidth = 0.6 + interPulse * 0.5;
              ctx.beginPath();
              ctx.moveTo(pa.x, pa.y);
              // Slight curve through midpoint for organic feel
              const midX = (pa.x + pb.x) / 2 + Math.sin(pa.pulse * 0.7 + G.time) * 8;
              const midY = (pa.y + pb.y) / 2 + Math.cos(pb.pulse * 0.5 + G.time) * 8;
              ctx.quadraticCurveTo(midX, midY, pb.x, pb.y);
              ctx.stroke();
              // Tiny glyph node at midpoint — Enochian-style mark
              const gx = midX, gy = midY;
              ctx.globalAlpha = 0.15 + interPulse * 0.15;
              ctx.fillStyle = '#ffe080';
              // Glyph shape: small diamond
              const gs = 2 + interPulse;
              ctx.beginPath();
              ctx.moveTo(gx, gy - gs);
              ctx.lineTo(gx + gs * 0.7, gy);
              ctx.lineTo(gx, gy + gs);
              ctx.lineTo(gx - gs * 0.7, gy);
              ctx.closePath();
              ctx.fill();
            }
          }
        }

        // Sigil tethers — Enochian-style connections to nearby bombs
        if (c.scSigilTethers && c.scSigilTethers.length > 0) {
          for (let t = c.scSigilTethers.length - 1; t >= 0; t--) {
            const st = c.scSigilTethers[t];
            if (st.bombIdx >= G.bombs.length) { c.scSigilTethers.splice(t, 1); continue; }
            const bomb = G.bombs[st.bombIdx];
            if (!bomb) { c.scSigilTethers.splice(t, 1); continue; }
            st.pulsePhase += 0.016 * 4.0;
            const sp = 0.5 + 0.5 * Math.sin(st.pulsePhase);
            const bdx = bomb.x - c.x, bdy = bomb.y - c.y;
            const bd = Math.sqrt(bdx * bdx + bdy * bdy) + 1;

            // Sigil tether beam — angular, rune-like path with sharp bends
            ctx.globalAlpha = 0.2 + sp * 0.25;
            ctx.strokeStyle = '#c0a0ff';
            ctx.lineWidth = 1.0 + sp * 0.8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(c.x, c.y);
            // 3 angular waypoints — creates angular/rune-like geometry
            const perpX = -bdy / bd, perpY = bdx / bd;
            const seg = bd / 4;
            const bendAmt = 12 + Math.sin(st.glyphSeed * 3.7) * 8;
            const wx1x = c.x + bdx * 0.25 + perpX * bendAmt * Math.sin(st.glyphSeed);
            const wx1y = c.y + bdy * 0.25 + perpY * bendAmt * Math.sin(st.glyphSeed);
            const wx2x = c.x + bdx * 0.5 + perpX * bendAmt * Math.cos(st.glyphSeed * 1.7);
            const wx2y = c.y + bdy * 0.5 + perpY * bendAmt * Math.cos(st.glyphSeed * 1.7);
            const wx3x = c.x + bdx * 0.75 - perpX * bendAmt * Math.sin(st.glyphSeed * 2.3);
            const wx3y = c.y + bdy * 0.75 - perpY * bendAmt * Math.sin(st.glyphSeed * 2.3);
            ctx.lineTo(wx1x, wx1y);
            ctx.lineTo(wx2x, wx2y);
            ctx.lineTo(wx3x, wx3y);
            ctx.lineTo(bomb.x, bomb.y);
            ctx.stroke();
            // Inner core line
            ctx.globalAlpha = 0.3 + sp * 0.3;
            ctx.strokeStyle = '#e0c0ff';
            ctx.lineWidth = 0.4 + sp * 0.4;
            ctx.beginPath();
            ctx.moveTo(c.x, c.y);
            ctx.lineTo(wx1x, wx1y); ctx.lineTo(wx2x, wx2y); ctx.lineTo(wx3x, wx3y);
            ctx.lineTo(bomb.x, bomb.y);
            ctx.stroke();
            // Glyph marks at each waypoint — small angular symbols
            const glyphs = [{x: wx1x, y: wx1y}, {x: wx2x, y: wx2y}, {x: wx3x, y: wx3y}];
            for (let g = 0; g < glyphs.length; g++) {
              const gp = glyphs[g];
              const gs = 3 + sp * 2;
              const ga = st.glyphSeed * (g + 1) * 2.1 + G.time * 0.5;
              ctx.globalAlpha = 0.25 + sp * 0.2;
              ctx.strokeStyle = '#d0b0ff';
              ctx.lineWidth = 0.6;
              // Angular glyph: cross + angle marks
              ctx.beginPath();
              ctx.moveTo(gp.x - gs, gp.y); ctx.lineTo(gp.x + gs, gp.y);
              ctx.moveTo(gp.x, gp.y - gs); ctx.lineTo(gp.x, gp.y + gs);
              // Diagonal tick marks
              const tick = gs * 0.6;
              ctx.moveTo(gp.x + Math.cos(ga) * tick, gp.y + Math.sin(ga) * tick);
              ctx.lineTo(gp.x + Math.cos(ga + Math.PI) * tick, gp.y + Math.sin(ga + Math.PI) * tick);
              ctx.stroke();
              // Dot at center
              ctx.fillStyle = '#e0c0ff';
              ctx.globalAlpha = 0.4 + sp * 0.3;
              ctx.beginPath();
              ctx.arc(gp.x, gp.y, 1.2 + sp * 0.5, 0, Math.PI * 2);
              ctx.fill();
            }
            // Hexagonal glow ring around sigil target
            ctx.globalAlpha = 0.15 + sp * 0.2;
            ctx.strokeStyle = '#c0a0ff';
            ctx.lineWidth = 1.0;
            ctx.beginPath();
            for (let h = 0; h <= 6; h++) {
              const ha = (h / 6) * Math.PI * 2 - Math.PI / 6;
              const hx = bomb.x + Math.cos(ha) * (14 + sp * 4);
              const hy = bomb.y + Math.sin(ha) * (14 + sp * 4);
              if (h === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
            }
            ctx.stroke();
          }
        }

        ctx.globalAlpha = 1;
      }
    } else {
      // Check if special biome — render unique orb shapes
      const isAbyssOrb = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
      const isExpanseOrb = G.biomeOverride === 2;

      if (isAbyssOrb && drawR > 2) {
        // === ABYSS ORB: Progressive mutation — normal ball → warped medusa ===
        // Tied to madness: 0% = normal circle, 50% = warped body, 100% = full tentacle horror
        // Colors follow Abyss saturation: greyscale in void → vivid bioluminescence
        const abyssPal = getCurrentPalette();
        const savedAlpha = ctx.globalAlpha || 1;
        const seed = c.id * 7.31;
        const madness = getMadnessAmount();
        const abyssSat = getAbyssSaturation();
        const satAccent = abyssDesaturate(abyssPal.accent, abyssSat);

        // Mutation factor: 0.0 (normal ball) → 1.0 (full horror)
        const mutT = madness;
        // Body warp doesn't start until 10% madness, fully warped by 60%
        const bodyWarp = Math.max(0, Math.min(1, (mutT - 0.1) / 0.5));
        // Tentacles don't appear until 30% madness, fully grown by 100%
        const tentGrowth = Math.max(0, Math.min(1, (mutT - 0.3) / 0.7));

        const sides = 5 + (c.id % 4);
        const warpFreq = 1.5 + (c.id % 7) * 0.4;
        const warpAmt = (0.12 + ((c.id * 3) % 11) * 0.015) * bodyWarp; // scales with mutation
        const baseRot = G.time * (0.15 + (c.id % 5) * 0.06) * ((c.id % 2) ? 1 : -1) * bodyWarp;

        // Draw the body — lerps from clean circle to warped polygon
        // === ABYSS SYNTHESIS — flat fill + linear gradient layers (performance-optimized) ===
        const _aor = parseInt(c.color.slice(1,3),16);
        const _aog = parseInt(c.color.slice(3,5),16);
        const _aob = parseInt(c.color.slice(5,7),16);
        // Bioluminescent hue shift
        const _abyssHue = `rgb(${Math.min(255, _aob + 50)},${Math.min(255, _aor + 30)},${Math.min(255, _aog + 60)})`;

        // Build the body path as a function we can call multiple times
        const buildAbyssBodyPath = () => {
          ctx.beginPath();
          if (bodyWarp < 0.01) {
            ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
          } else {
            const pts = sides * 3;
            for (let p = 0; p <= pts; p++) {
              const baseAngle = (p / pts) * Math.PI * 2 + baseRot;
              const warp1 = Math.sin(baseAngle * sides * 0.5 + G.time * warpFreq + seed) * warpAmt;
              const warp2 = Math.sin(baseAngle * (sides + 1) + G.time * warpFreq * 0.7 + seed * 2.1) * warpAmt * 0.6;
              const warp3 = Math.sin(G.time * 1.2 + seed * 0.5) * 0.04 * bodyWarp;
              const bR = 0.95 - 0.15 * bodyWarp;
              const r = drawR * (bR + warp1 + warp2 + warp3);
              const ax = c.x + Math.cos(baseAngle) * r;
              const ay = c.y + Math.sin(baseAngle) * r;
              if (p === 0) ctx.moveTo(ax, ay); else ctx.lineTo(ax, ay);
            }
            ctx.closePath();
          }
        };

        if (drawR > 5) {
          // Flat fill clipped to warped body shape
          ctx.globalAlpha = savedAlpha * 0.85;
          ctx.fillStyle = c.color;
          buildAbyssBodyPath();
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
          ctx.globalAlpha = savedAlpha * 0.85;
        } else {
          // Tiny abyss orbs — simple flat fill
          ctx.globalAlpha = savedAlpha * 0.85;
          ctx.fillStyle = c.color;
          buildAbyssBodyPath();
          ctx.fill();
        }

        // Inner void — flat dark center, appears from 30% bodyWarp (LOD 0-1)
        if (lod <= 1 && bodyWarp > 0.3) {
          const voidAlpha = (bodyWarp - 0.3) / 0.7;
          ctx.globalAlpha = savedAlpha * 0.3 * voidAlpha;
          const voidR = drawR * (0.2 + Math.sin(G.time * 1.5 + seed) * 0.06);
          ctx.fillStyle = '#081018';
          ctx.beginPath();
          ctx.arc(c.x, c.y, voidR, 0, Math.PI * 2);
          ctx.fill();
        }

        // Bioluminescent edge glow — flat ring stroke, fades in with bodyWarp (LOD 0 only)
        if (lod === 0 && bodyWarp > 0.2) {
          const glowAlpha = (bodyWarp - 0.2) / 0.8;
          ctx.globalAlpha = savedAlpha * 0.3 * glowAlpha;
          ctx.globalCompositeOperation = 'lighter';
          ctx.strokeStyle = satAccent;
          ctx.lineWidth = drawR * 0.15;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR * 0.92, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalCompositeOperation = 'source-over';
        }

        // Stress lines — appear from 40% bodyWarp (LOD 0 only)
        if (lod === 0 && drawR > 6 && bodyWarp > 0.4) {
          const lineAlpha = (bodyWarp - 0.4) / 0.6;
          ctx.globalAlpha = savedAlpha * 0.15 * lineAlpha;
          ctx.strokeStyle = satAccent;
          ctx.lineWidth = 0.5;
          const lineCount = 2 + (c.id % 3);
          for (let li = 0; li < lineCount; li++) {
            const la = baseRot + (li / lineCount) * Math.PI * 2 + seed * 0.3;
            const innerR = drawR * (0.15 + Math.sin(G.time * 0.8 + li * 2.1 + seed) * 0.1);
            const outerR = drawR * (0.55 + Math.sin(G.time * 1.1 + li * 1.7 + seed) * 0.15);
            ctx.beginPath();
            ctx.moveTo(c.x + Math.cos(la) * innerR, c.y + Math.sin(la) * innerR);
            const cpAngle = la + Math.sin(G.time * 0.6 + seed + li) * 0.3;
            const cpR = (innerR + outerR) * 0.5;
            ctx.quadraticCurveTo(
              c.x + Math.cos(cpAngle) * cpR,
              c.y + Math.sin(cpAngle) * cpR,
              c.x + Math.cos(la + Math.sin(G.time * 0.4 + li) * 0.15) * outerR,
              c.y + Math.sin(la + Math.sin(G.time * 0.4 + li) * 0.15) * outerR
            );
            ctx.stroke();
          }
        }

        // === WRITHING TENTACLES — sprout gradually with tentGrowth === (LOD 0-1 only)
        if (lod <= 1 && drawR > 4 && tentGrowth > 0) {
          // Number of tentacles grows: 1 at first, up to 3-6 at full madness
          const maxTents = 3 + (c.id % 4);
          const visibleTents = Math.max(1, Math.ceil(maxTents * tentGrowth));
          const tentSeed = c.id * 13.37;
          ctx.globalCompositeOperation = 'source-over';

          for (let ti = 0; ti < visibleTents; ti++) {
            const tentAngle = (ti / maxTents) * Math.PI * 2 + baseRot * 0.3 + tentSeed * 0.1;
            const isThick = ((c.id + ti) % 3) === 0;
            // Tentacle length scales with tentGrowth — starts as tiny nubs
            const fullBaseWidth = isThick ? drawR * 0.28 : drawR * 0.10;
            const baseWidth = fullBaseWidth * tentGrowth;
            const fullTentLen = drawR * (isThick ? (1.1 + ((ti * 7 + c.id) % 5) * 0.15) : (1.4 + ((ti * 11 + c.id) % 7) * 0.12));
            const tentLen = fullTentLen * tentGrowth;

            // Writhing — amplitude scales with growth
            const writhe1 = Math.sin(G.time * (1.8 + ti * 0.4) + tentSeed + ti * 2.3) * 0.35 * tentGrowth;
            const writhe2 = Math.sin(G.time * (2.7 + ti * 0.3) + tentSeed * 1.7 + ti) * 0.2 * tentGrowth;
            const writhe3 = Math.sin(G.time * (0.9 + ti * 0.15) + tentSeed * 0.5) * 0.15 * tentGrowth;

            const segments = isThick ? 8 : 6;
            const tentPts = [];
            for (let si = 0; si <= segments; si++) {
              const t = si / segments;
              const wrinkle = t * t * (writhe1 + writhe2 * t + writhe3 * (1 - t));
              const perpAngle = tentAngle + Math.PI * 0.5;
              const segAngle = tentAngle + wrinkle;
              const segDist = drawR * 0.7 + tentLen * t;
              const sx = c.x + Math.cos(segAngle) * segDist + Math.cos(perpAngle) * wrinkle * drawR * 0.2;
              const sy = c.y + Math.sin(segAngle) * segDist + Math.sin(perpAngle) * wrinkle * drawR * 0.2;
              tentPts.push({ x: sx, y: sy, t: t });
            }

            // Draw tentacle body
            ctx.globalAlpha = savedAlpha * (isThick ? 0.7 : 0.5) * tentGrowth;
            if (lod === 0) {
              const tentGrad2 = ctx.createLinearGradient(
                c.x + Math.cos(tentAngle) * drawR * 0.7,
                c.y + Math.sin(tentAngle) * drawR * 0.7,
                tentPts[segments].x, tentPts[segments].y
              );
              tentGrad2.addColorStop(0, c.color);
              tentGrad2.addColorStop(0.4, satAccent);
              tentGrad2.addColorStop(1, '#0a0a18');
              ctx.strokeStyle = tentGrad2;
            } else {
              ctx.strokeStyle = c.color; // LOD 1: flat color tentacles
            }
            ctx.lineCap = 'round';

            for (let si = 0; si < segments; si++) {
              const t = si / segments;
              const taper = baseWidth * (1 - t * 0.85);
              const wrinkleBump = isThick ? Math.sin(G.time * 3.5 + si * 1.8 + tentSeed) * taper * 0.3 : 0;
              ctx.lineWidth = Math.max(0.5, taper + wrinkleBump);
              ctx.globalAlpha = savedAlpha * (isThick ? 0.7 : 0.45) * (1 - t * 0.4) * tentGrowth;
              ctx.beginPath();
              ctx.moveTo(tentPts[si].x, tentPts[si].y);
              if (si + 2 <= segments) {
                const cpx = (tentPts[si].x + tentPts[si + 1].x) * 0.5 +
                  Math.sin(G.time * 2.1 + si * 3.1 + tentSeed) * drawR * 0.06 * tentGrowth;
                const cpy = (tentPts[si].y + tentPts[si + 1].y) * 0.5 +
                  Math.cos(G.time * 1.9 + si * 2.7 + tentSeed) * drawR * 0.06 * tentGrowth;
                ctx.quadraticCurveTo(cpx, cpy, tentPts[si + 1].x, tentPts[si + 1].y);
              } else {
                ctx.lineTo(tentPts[si + 1].x, tentPts[si + 1].y);
              }
              ctx.stroke();
            }

            // Thick tentacles: wrinkling ridges (only at high growth, LOD 0 only)
            if (lod === 0 && isThick && drawR > 8 && tentGrowth > 0.6) {
              ctx.globalAlpha = savedAlpha * 0.25 * tentGrowth;
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 0.5;
              for (let ri = 1; ri < segments - 1; ri += 2) {
                const ridgeT = ri / segments;
                const ridgeW = baseWidth * (1 - ridgeT * 0.85) * 0.6;
                const perpA = tentAngle + Math.PI * 0.5 + (writhe1 + writhe2) * ridgeT;
                const rx = tentPts[ri].x, ry = tentPts[ri].y;
                ctx.beginPath();
                ctx.moveTo(rx - Math.cos(perpA) * ridgeW, ry - Math.sin(perpA) * ridgeW);
                ctx.lineTo(rx + Math.cos(perpA) * ridgeW, ry + Math.sin(perpA) * ridgeW);
                ctx.stroke();
              }
            }

            // Thin tentacles: wispy curling tip (only at high growth, LOD 0 only)
            if (lod === 0 && !isThick && drawR > 6 && tentGrowth > 0.5) {
              const tipPt = tentPts[segments];
              const tipAngle2 = tentAngle + writhe1 * 1.5 + writhe2;
              const curlLen = drawR * 0.3 * tentGrowth;
              ctx.globalAlpha = savedAlpha * 0.3 * tentGrowth;
              ctx.strokeStyle = satAccent;
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(tipPt.x, tipPt.y);
              ctx.quadraticCurveTo(
                tipPt.x + Math.cos(tipAngle2 + 0.8) * curlLen,
                tipPt.y + Math.sin(tipAngle2 + 0.8) * curlLen,
                tipPt.x + Math.cos(tipAngle2 + 1.5) * curlLen * 0.6,
                tipPt.y + Math.sin(tipAngle2 + 1.5) * curlLen * 0.6
              );
              ctx.stroke();
            }
          }
        }

        ctx.globalAlpha = savedAlpha;
      } else if (isAbyssOrb) {
        // Tiny ABYSS orbs at low madness — normal colored dot
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();
      } else if (isExpanseOrb && drawR > 2) {
        // === EXPANSE ORB: Weathered stone-like ancient orbs ===
        const savedAlpha = ctx.globalAlpha || 1;
        const seed = c.id * 5.17;

        // Rough-edged polygon — ancient/eroded, not perfectly round
        const sides = 8 + (c.id % 5); // 8-12 sides per orb, seeded
        const buildExpansePath = () => {
          ctx.beginPath();
          for (let p = 0; p <= sides; p++) {
            const angle = (p / sides) * Math.PI * 2;
            // Subtle radial variation seeded by orb ID — looks weathered
            const wobble = 1.0
              - 0.04 * Math.sin(angle * 3 + seed)
              - 0.03 * Math.sin(angle * 5 + seed * 2.3)
              - 0.02 * Math.sin(angle * 7 + seed * 0.7);
            const r = drawR * wobble;
            const ax = c.x + Math.cos(angle) * r;
            const ay = c.y + Math.sin(angle) * r;
            if (p === 0) ctx.moveTo(ax, ay); else ctx.lineTo(ax, ay);
          }
          ctx.closePath();
        };

        // Base fill — warm ancient color
        ctx.globalAlpha = savedAlpha;
        ctx.fillStyle = orbColor;
        buildExpansePath();
        ctx.fill();

        // Inner shadow — dark center for depth/weight (LOD 0-1)
        if (lod <= 1 && drawR > 6) {
          const innerGrad = ctx.createRadialGradient(c.x, c.y, drawR * 0.15, c.x, c.y, drawR * 0.85);
          innerGrad.addColorStop(0, 'rgba(13,6,4,0.25)');
          innerGrad.addColorStop(0.5, 'rgba(13,6,4,0.10)');
          innerGrad.addColorStop(1, 'transparent');
          ctx.globalAlpha = savedAlpha * 0.6;
          ctx.fillStyle = innerGrad;
          buildExpansePath();
          ctx.fill();
        }

        // Edge highlight — faint warm rim light on one side (LOD 0 only)
        if (lod === 0 && drawR > 8) {
          const rimAngle = seed * 0.3; // consistent per-orb rim direction
          const rimX = c.x + Math.cos(rimAngle) * drawR * 0.25;
          const rimY = c.y + Math.sin(rimAngle) * drawR * 0.25;
          const rimGrad = ctx.createRadialGradient(rimX, rimY, drawR * 0.3, c.x, c.y, drawR);
          rimGrad.addColorStop(0, 'rgba(255,200,100,0.12)');
          rimGrad.addColorStop(0.5, 'rgba(255,180,80,0.04)');
          rimGrad.addColorStop(1, 'transparent');
          ctx.globalAlpha = savedAlpha * 0.5;
          ctx.fillStyle = rimGrad;
          buildExpansePath();
          ctx.fill();
        }

        // Surface cracks — faint dark lines suggesting age (LOD 0, large orbs only)
        if (lod === 0 && drawR > 15) {
          ctx.globalAlpha = savedAlpha * 0.12;
          ctx.strokeStyle = '#1a0a00';
          ctx.lineWidth = 0.6;
          const crackCount = 2 + (c.id % 3);
          for (let ci = 0; ci < crackCount; ci++) {
            const cAngle = (ci / crackCount) * Math.PI * 2 + seed * 0.5;
            const innerR = drawR * (0.1 + ((ci * 7 + c.id) % 5) * 0.08);
            const outerR = drawR * (0.5 + ((ci * 3 + c.id) % 4) * 0.1);
            ctx.beginPath();
            ctx.moveTo(c.x + Math.cos(cAngle) * innerR, c.y + Math.sin(cAngle) * innerR);
            const cpA = cAngle + ((c.id + ci) % 2 ? 0.3 : -0.3);
            const cpR = (innerR + outerR) * 0.55;
            ctx.quadraticCurveTo(
              c.x + Math.cos(cpA) * cpR, c.y + Math.sin(cpA) * cpR,
              c.x + Math.cos(cAngle + 0.15) * outerR, c.y + Math.sin(cAngle + 0.15) * outerR
            );
            ctx.stroke();
          }
        }

        ctx.globalAlpha = savedAlpha;
      }

      if (!isAbyssOrb && !isExpanseOrb) {
      // Eyeball intensity driven by madness (0-100% scale)
      // 4 vector eye variants per orb, seeded by ID (matches boss eye system):
      //   V0: PALE — light grey iris, round pupil, minimal
      //   V1: STRIATED — mid-grey iris with radial line pattern, round pupil
      //   V2: SLIT — light grey iris, vertical slit pupil
      //   V3: CRACKED — dark grey iris with crack lines, horizontal slit pupil
      // At 85%+ madness: extra eyes appear — 2x per 7.5% (2 at 85%, 4 at 92.5%, 6 at 100%)
      const madnessEye = getMadnessAmount();
      const eyeIntensity = madnessEye < 0.1 ? 0 : Math.min(1, (madnessEye - 0.1) / 0.9);
      // Extra eyes at 85%+ — how many total eyes this orb has
      const extraEyeCount = madnessEye >= 0.85 ? Math.floor(((madnessEye - 0.85) / 0.075) * 2) + 2 : 1;

      if (eyeIntensity > 0 && drawR > 5) {
        const savedAlpha = ctx.globalAlpha || 1;
        const ei = eyeIntensity;
        const eyeVariant = c.id % 4; // 0-3: four distinct vector eye styles

        // Draw base colored orb first
        ctx.globalAlpha = savedAlpha;
        ctx.fillStyle = orbColor;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();

        // === MUTATION PHASE 1: Void Seed — subtle dark center forming ===
        // Shape hints at the eye variant this orb will grow into:
        //   V0/V1: round pupil → circle, V2: vertical slit → vertical ellipse, V3: horizontal slit → horizontal ellipse
        if (lod <= 1) {
          const voidT = Math.min(1, ei / 0.3);
          const voidPulse = 1 + Math.sin(G.time * 1.2 + c.id * 2.7) * 0.08 * voidT;
          const voidR = drawR * (0.04 + voidT * 0.14) * voidPulse;
          ctx.globalAlpha = savedAlpha * voidT * voidT * 0.35;
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          if (eyeVariant === 2) {
            // V2: Slit — vertical ellipse hint
            ctx.ellipse(c.x, c.y, voidR * 0.4, voidR, 0, 0, Math.PI * 2);
          } else if (eyeVariant === 3) {
            // V3: Cracked — horizontal ellipse hint
            ctx.ellipse(c.x, c.y, voidR, voidR * 0.5, 0, 0, Math.PI * 2);
          } else {
            // V0, V1: Round pupil — keep circle
            ctx.arc(c.x, c.y, voidR, 0, Math.PI * 2);
          }
          ctx.fill();
        }

        // Blink system — each orb has its own cycle
        const blinkSeed = c.id * 7.31;
        const blinkCycle = 6 + (blinkSeed % 8);
        const blinkT = (G.time + blinkSeed) % blinkCycle;
        let blinkScale = 1;
        if (blinkT < 0.12) blinkScale = 1 - (blinkT / 0.12);
        else if (blinkT < 0.3) blinkScale = (blinkT - 0.12) / 0.18;
        // V0 (pale) eyes blink less at high intensity — they stare
        if (eyeVariant === 0 && ei > 0.6) blinkScale = 1;

        // Look direction — all eyes track cursor
        const lookDx = G.cursorX - c.x, lookDy = G.cursorY - c.y;
        const lookDist = Math.sqrt(lookDx * lookDx + lookDy * lookDy) + 1;
        const lookStr = ei * drawR * 0.12;
        const irisOffX = (lookDx / lookDist) * lookStr;
        const irisOffY = (lookDy / lookDist) * lookStr;

        // === SCLERA — flat off-white fill ===
        if (ei > 0.3) {
          const scleraT = Math.min(1, (ei - 0.3) / 0.35) * blinkScale;
          const scR = drawR * (eyeVariant === 0 ? 1.0 : eyeVariant === 1 ? 0.98 : eyeVariant === 2 ? 0.97 : 0.96);
          const scleraShade = eyeVariant === 0 ? '#d8d8d5' : eyeVariant === 1 ? '#ccccc8' : eyeVariant === 2 ? '#d2d2d6' : '#c8c5c2';
          ctx.fillStyle = scleraShade;
          ctx.globalAlpha = savedAlpha * scleraT * 0.88;
          ctx.beginPath();
          ctx.arc(c.x, c.y, scR, 0, Math.PI * 2);
          ctx.fill();

        }

        // === VEINS — thin vector lines === (LOD 0 only)
        if (lod === 0 && ei > 0.45) {
          const veinT = Math.min(1, (ei - 0.45) / 0.35);
          const veinCount = eyeVariant === 1 ? 6 : eyeVariant === 3 ? 7 : 4;
          ctx.strokeStyle = '#555';
          ctx.lineWidth = 0.4 + veinT * 0.4;
          for (let v = 0; v < veinCount; v++) {
            const vSeed = c.id * 3.7 + v * 5.13;
            const vAngle = (v / veinCount) * Math.PI * 2 + Math.sin(vSeed) * 0.5;
            const startR = drawR * 0.35;
            const endR = drawR * (0.65 + 0.2 * Math.sin(vSeed * 2.3));
            const vsx = c.x + Math.cos(vAngle) * startR;
            const vsy = c.y + Math.sin(vAngle) * startR;
            const vex = c.x + Math.cos(vAngle + Math.sin(vSeed) * 0.15) * endR;
            const vey = c.y + Math.sin(vAngle + Math.sin(vSeed) * 0.15) * endR;
            ctx.globalAlpha = savedAlpha * veinT * 0.25;
            ctx.beginPath();
            ctx.moveTo(vsx, vsy);
            const cpx = (vsx + vex) / 2 + Math.cos(vSeed * 4) * drawR * 0.06;
            const cpy = (vsy + vey) / 2 + Math.sin(vSeed * 4) * drawR * 0.06;
            ctx.quadraticCurveTo(cpx, cpy, vex, vey);
            ctx.stroke();
          }
        }

        // === IRIS + PUPIL — 4 vector variants (matches boss eye system) ===
        if (ei > 0.25) {
          const irisT = Math.min(1, (ei - 0.25) / 0.45) * blinkScale;
          const irisCx = c.x + irisOffX, irisCy = c.y + irisOffY;

          if (eyeVariant === 0) {
            // --- V0: PALE — light grey iris, round pupil, minimal ---
            const iR = drawR * (0.42 + irisT * 0.15);
            ctx.fillStyle = '#8a8a88';
            ctx.globalAlpha = savedAlpha * irisT * 0.75;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, iR, 0, Math.PI * 2);
            ctx.fill();
            // Pupil — dilates during chains
            const pupilDilate = 1.0 + (G.chainActive ? 0.25 : 0) + Math.sin(G.time * 0.5 + blinkSeed) * 0.05;
            ctx.fillStyle = '#0a0a0a';
            ctx.globalAlpha = savedAlpha * irisT;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, iR * 0.42 * pupilDilate, 0, Math.PI * 2);
            ctx.fill();
            // Specular highlight
            if (lod === 0 && irisT > 0.4) {
              ctx.fillStyle = '#ffffff';
              ctx.globalAlpha = savedAlpha * (irisT - 0.4) * 1.0;
              ctx.beginPath();
              ctx.arc(irisCx - iR * 0.22, irisCy - iR * 0.24, iR * 0.09, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = savedAlpha * (irisT - 0.4) * 0.35;
              ctx.beginPath();
              ctx.arc(irisCx + iR * 0.16, irisCy + iR * 0.1, iR * 0.04, 0, Math.PI * 2);
              ctx.fill();
            }

          } else if (eyeVariant === 1) {
            // --- V1: STRIATED — mid-grey iris with radial lines, round pupil ---
            const iR = drawR * (0.44 + irisT * 0.12);
            ctx.fillStyle = '#787878';
            ctx.globalAlpha = savedAlpha * irisT * 0.85;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, iR, 0, Math.PI * 2);
            ctx.fill();
            // Radial striations (thin internal lines)
            if (lod === 0) {
              ctx.strokeStyle = '#a0a0a0';
              ctx.lineWidth = 0.5;
              ctx.globalAlpha = savedAlpha * irisT * 0.35;
              for (let s = 0; s < 18; s++) {
                const sa = (s / 18) * Math.PI * 2 + blinkSeed * 0.01;
                ctx.beginPath();
                ctx.moveTo(irisCx + Math.cos(sa) * iR * 0.28, irisCy + Math.sin(sa) * iR * 0.28);
                ctx.lineTo(irisCx + Math.cos(sa) * iR * 0.85, irisCy + Math.sin(sa) * iR * 0.85);
                ctx.stroke();
              }
            }
            // Pupil
            ctx.fillStyle = '#060606';
            ctx.globalAlpha = savedAlpha * irisT;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, iR * 0.35, 0, Math.PI * 2);
            ctx.fill();
            // Specular
            if (lod === 0 && irisT > 0.4) {
              ctx.fillStyle = '#ffffff';
              ctx.globalAlpha = savedAlpha * (irisT - 0.4) * 0.9;
              ctx.beginPath();
              ctx.arc(irisCx - iR * 0.2, irisCy - iR * 0.22, iR * 0.08, 0, Math.PI * 2);
              ctx.fill();
            }

          } else if (eyeVariant === 2) {
            // --- V2: SLIT — light grey iris, vertical slit pupil ---
            const iR = drawR * (0.42 + irisT * 0.14);
            ctx.fillStyle = '#909094';
            ctx.globalAlpha = savedAlpha * irisT * 0.85;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, iR, 0, Math.PI * 2);
            ctx.fill();
            // Vertical slit pupil
            ctx.fillStyle = '#080808';
            ctx.globalAlpha = savedAlpha * irisT;
            ctx.beginPath();
            ctx.ellipse(irisCx, irisCy, iR * 0.1, iR * 0.68, 0, 0, Math.PI * 2);
            ctx.fill();
            // Specular
            if (lod === 0 && irisT > 0.4) {
              ctx.fillStyle = '#ffffff';
              ctx.globalAlpha = savedAlpha * (irisT - 0.4) * 0.8;
              ctx.beginPath();
              ctx.arc(irisCx - iR * 0.2, irisCy - iR * 0.24, iR * 0.07, 0, Math.PI * 2);
              ctx.fill();
            }

          } else {
            // --- V3: CRACKED — dark grey iris with crack lines, horizontal slit pupil ---
            const iR = drawR * (0.40 + irisT * 0.12);
            ctx.fillStyle = '#606060';
            ctx.globalAlpha = savedAlpha * irisT * 0.85;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, iR, 0, Math.PI * 2);
            ctx.fill();
            // Crack lines (thin internal detail)
            if (lod === 0) {
              ctx.strokeStyle = '#2a2a2a';
              ctx.lineWidth = 0.6;
              ctx.globalAlpha = savedAlpha * irisT * 0.4;
              for (let s = 0; s < 12; s++) {
                const sa = (s / 12) * Math.PI * 2 + blinkSeed * 0.015;
                const jag = Math.sin(s * 3.7) * iR * 0.08;
                ctx.beginPath();
                ctx.moveTo(irisCx + Math.cos(sa) * iR * 0.2, irisCy + Math.sin(sa) * iR * 0.2);
                ctx.lineTo(irisCx + Math.cos(sa + 0.1) * iR * 0.55 + jag, irisCy + Math.sin(sa - 0.08) * iR * 0.55);
                ctx.lineTo(irisCx + Math.cos(sa) * iR * 0.85, irisCy + Math.sin(sa) * iR * 0.85);
                ctx.stroke();
              }
            }
            // Horizontal slit pupil
            ctx.fillStyle = '#050505';
            ctx.globalAlpha = savedAlpha * irisT;
            ctx.beginPath();
            ctx.ellipse(irisCx, irisCy, iR * 0.55, iR * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Specular
            if (lod === 0 && irisT > 0.4) {
              ctx.fillStyle = '#ffffff';
              ctx.globalAlpha = savedAlpha * (irisT - 0.4) * 0.7;
              ctx.beginPath();
              ctx.arc(irisCx - iR * 0.18, irisCy - iR * 0.2, iR * 0.07, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        // === EXTRA EYES at 85%+ madness — 4-variant vector sprouting eyes === (LOD 0 only)
        if (lod === 0 && extraEyeCount > 1 && ei > 0.4 && drawR > 7) {
          for (let xe = 1; xe < extraEyeCount && xe < 7; xe++) {
            const xeSeed = c.id * 13.7 + xe * 9.31;
            const xeAngle = (xe / extraEyeCount) * Math.PI * 2 + Math.sin(xeSeed) * 0.8;
            const xeDist = drawR * (0.3 + 0.15 * Math.sin(xeSeed * 2));
            const xeX = c.x + Math.cos(xeAngle) * xeDist;
            const xeY = c.y + Math.sin(xeAngle) * xeDist;
            const xeR = drawR * (0.15 + 0.05 * Math.sin(xeSeed * 3));
            const xeBlink = Math.max(0, Math.sin(G.time * 1.1 + xeSeed * 2.3));
            if (xeBlink < 0.15) continue;
            const xeRb = xeR * xeBlink;
            const xeVar = (c.id + xe) % 4;
            // Sclera
            const xeScleraShade = xeVar === 0 ? '#d8d8d5' : xeVar === 1 ? '#ccccc8' : xeVar === 2 ? '#d2d2d6' : '#c8c5c2';
            ctx.globalAlpha = savedAlpha * xeBlink * 0.5 * ei;
            ctx.fillStyle = xeScleraShade;
            ctx.beginPath();
            ctx.arc(xeX, xeY, xeRb, 0, Math.PI * 2);
            ctx.fill();
            // Iris tracking
            const xLookStr = xeR * 0.2;
            const xLdx = G.cursorX - xeX, xLdy = G.cursorY - xeY;
            const xLd = Math.sqrt(xLdx * xLdx + xLdy * xLdy) + 1;
            const xiOx = (xLdx / xLd) * xLookStr;
            const xiOy = (xLdy / xLd) * xLookStr;
            const xiCx = xeX + xiOx, xiCy = xeY + xiOy;
            ctx.globalAlpha = savedAlpha * xeBlink * 0.6 * ei;
            // Per-variant mini iris+pupil
            if (xeVar === 0) {
              ctx.fillStyle = '#8a8a88';
              ctx.beginPath(); ctx.arc(xiCx, xiCy, xeRb * 0.5, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#0a0a0a';
              ctx.beginPath(); ctx.arc(xiCx, xiCy, xeRb * 0.22, 0, Math.PI * 2); ctx.fill();
            } else if (xeVar === 1) {
              ctx.fillStyle = '#787878';
              ctx.beginPath(); ctx.arc(xiCx, xiCy, xeRb * 0.5, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#060606';
              ctx.beginPath(); ctx.arc(xiCx, xiCy, xeRb * 0.2, 0, Math.PI * 2); ctx.fill();
            } else if (xeVar === 2) {
              ctx.fillStyle = '#909094';
              ctx.beginPath(); ctx.arc(xiCx, xiCy, xeRb * 0.5, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#080808';
              ctx.beginPath(); ctx.ellipse(xiCx, xiCy, xeRb * 0.06, xeRb * 0.38, 0, 0, Math.PI * 2); ctx.fill();
            } else {
              ctx.fillStyle = '#606060';
              ctx.beginPath(); ctx.arc(xiCx, xiCy, xeRb * 0.5, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#050505';
              ctx.beginPath(); ctx.ellipse(xiCx, xiCy, xeRb * 0.32, xeRb * 0.07, 0, 0, Math.PI * 2); ctx.fill();
            }
          }
        }

        ctx.globalAlpha = savedAlpha;
      } else {
        // === COLOR SYNTHESIS — flat fill + linear gradient layers (performance-optimized) ===
        const orbAlpha = ctx.globalAlpha || 1;

        // Parse orb color for synthesis
        const _or = parseInt(c.color.slice(1,3),16);
        const _og = parseInt(c.color.slice(3,5),16);
        const _ob = parseInt(c.color.slice(5,7),16);
        // Derive shifted hue for accent
        const _hueShift = `rgb(${Math.min(255, _og + 40)},${Math.min(255, _ob + 30)},${Math.min(255, _or + 50)})`;

        if (drawR > 5) {
          // Flat color fill — clean, no blend layers
          ctx.globalAlpha = orbAlpha;
          ctx.fillStyle = orbColor;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
          ctx.fill();

        } else {
          // Tiny orbs: simple fill
          ctx.fillStyle = orbColor;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // === VOID CRACK ORB OVERLAY — purple void energy === (LOD 0-1 only)
      if (lod <= 1 && c.armored && c.armorHP > 0 && drawR > 3) {
        const armorAlpha = (ctx.globalAlpha || 1);
        // Swirling void tendrils radiating from center
        ctx.globalAlpha = armorAlpha * 0.45;
        const facetCount = 5 + (c.id % 3);
        for (let f = 0; f < facetCount; f++) {
          const fAngle = (f / facetCount) * Math.PI * 2 + c.id * 0.7 + G.time * (c.armorHP === 1 ? 2.5 : 0.8);
          const innerR = drawR * 0.1;
          const outerR = drawR * (c.armorHP === 1 ? 1.15 : 0.85);
          // Wavy tendrils
          const midAngle = fAngle + Math.sin(G.time * 3 + f * 1.5) * 0.3;
          const midR = (innerR + outerR) * 0.5;
          ctx.strokeStyle = c.armorHP === 2 ? '#9060ff' : '#ff60ff';
          ctx.lineWidth = c.armorHP === 1 ? 2 : 1.5;
          ctx.beginPath();
          ctx.moveTo(c.x + Math.cos(fAngle) * innerR, c.y + Math.sin(fAngle) * innerR);
          ctx.quadraticCurveTo(
            c.x + Math.cos(midAngle) * midR,
            c.y + Math.sin(midAngle) * midR,
            c.x + Math.cos(fAngle) * outerR,
            c.y + Math.sin(fAngle) * outerR
          );
          ctx.stroke();
        }
        // Void ring — pulsing purple/magenta
        const ringPulse = 0.3 + Math.sin(G.time * 4) * 0.15;
        ctx.globalAlpha = armorAlpha * ringPulse;
        ctx.strokeStyle = c.armorHP === 2 ? '#8040ff' : '#ff40c0';
        ctx.lineWidth = c.armorHP === 1 ? 3 : 2;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR * 0.95, 0, Math.PI * 2);
        ctx.stroke();
        // Inner void glow — flat tinted fill
        if (c.armorHP === 1) {
          ctx.globalAlpha = armorAlpha * 0.15;
          ctx.fillStyle = '#8030ff';
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = armorAlpha;
      }

      // === COMBO-BUBBLE RINGS — merged orb indicator === (LOD 0-1 only)
      if (lod <= 1 && c.mergeCount > 1 && drawR > 4) {
        const mergeAlpha = (ctx.globalAlpha || 1) * 0.3;
        ctx.lineWidth = 1.5;
        const ringCount = Math.min(c.mergeCount - 1, 3);
        for (let ri = 0; ri < ringCount; ri++) {
          ctx.globalAlpha = mergeAlpha * (1 - ri * 0.2);
          ctx.strokeStyle = c.color;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR * (0.65 + ri * 0.12), 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      } // close else if (!isAbyssOrb && !isExpanseOrb)

      // Fade-in glow: flat lighter circle (LOD 0-1 only)
      if (lod <= 1 && c.fadeIn > 0) {
        const fadeT = 1 - c.fadeIn;
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = (1 - fadeT) * 0.2;
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.baseRadius * 1.5 * (1 - fadeT * fadeT), 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }

      // Merge glow: flash + expanding ring (LOD 0-1 only)
      if (lod <= 1 && c.mergeGlow > 0) {
        ctx.globalCompositeOperation = 'lighter';
        // Flash fill
        ctx.globalAlpha = c.mergeGlow * 0.25;
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR * 1.2, 0, Math.PI * 2);
        ctx.fill();
        // Expanding ring
        ctx.globalAlpha = c.mergeGlow * 0.5;
        ctx.strokeStyle = c.color;
        ctx.lineWidth = 2;
        const ringR = drawR * (1 + (1 - c.mergeGlow) * 0.6);
        ctx.beginPath();
        ctx.arc(c.x, c.y, ringR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      }
    }

    ctx.restore();
  }
}

function renderHoverProximity(ctx) {
  if (G.cursorX < 0 || G.cursorY < 0) return;

  // Find orb under cursor
  let hoverOrb = null, hoverDist = Infinity;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    const d = dist(G.cursorX, G.cursorY, c.x, c.y);
    if (d < c.radius * 1.5 && d < hoverDist) {
      hoverDist = d;
      hoverOrb = c;
    }
  }
  if (!hoverOrb) return;

  // Find nearest OTHER orb to the hovered orb
  let nearOrb = null, nearDist = Infinity;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped || c.id === hoverOrb.id) continue;
    const d = dist(hoverOrb.x, hoverOrb.y, c.x, c.y);
    if (d < nearDist) {
      nearDist = d;
      nearOrb = c;
    }
  }
  if (!nearOrb) return;

  // Draw fading line from hovered orb to nearest orb
  const grad = ctx.createLinearGradient(hoverOrb.x, hoverOrb.y, nearOrb.x, nearOrb.y);
  grad.addColorStop(0, hoverOrb.color + '45'); // ~27% alpha at start
  grad.addColorStop(0.5, hoverOrb.color + '1a'); // ~10% alpha mid
  grad.addColorStop(0.85, hoverOrb.color + '08'); // ~3% alpha
  grad.addColorStop(1, hoverOrb.color + '00'); // 0% alpha at end
  ctx.strokeStyle = grad;
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(hoverOrb.x, hoverOrb.y);
  ctx.lineTo(nearOrb.x, nearOrb.y);
  ctx.stroke();

  // Soft bloom at the hovered orb end — blends line into the orb
  const bloomR = hoverOrb.radius * 1.2;
  const bloom = ctx.createRadialGradient(hoverOrb.x, hoverOrb.y, hoverOrb.radius * 0.5, hoverOrb.x, hoverOrb.y, bloomR);
  bloom.addColorStop(0, hoverOrb.color + '00');
  bloom.addColorStop(0.5, hoverOrb.color + '18');
  bloom.addColorStop(1, hoverOrb.color + '00');
  ctx.fillStyle = bloom;
  ctx.beginPath();
  ctx.arc(hoverOrb.x, hoverOrb.y, bloomR, 0, Math.PI * 2);
  ctx.fill();
}

function renderExplosions(ctx) {
  const madness = getMadnessAmount();
  for (let i = 0; i < G.explosions.length; i++) {
    const e = G.explosions[i];
    ctx.save();

    // Desaturate explosion color with madness (ABYSS: inverse saturation)
    const eColor = madness > 0 ? biomeColorShift(e.color, madness) : e.color;

    // Layer 1: Bright core flash (decays fast)
    if (e.flashAlpha > 0.05 && !e.isEcho) {
      ctx.globalAlpha = e.flashAlpha * 0.4;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Layer 2: Inner glow fill (white core → color → transparent)
    if (e.life > 0.4) {
      ctx.globalAlpha = (e.life - 0.4) * 0.2;
      const ig = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius);
      ig.addColorStop(0, '#ffffff');
      ig.addColorStop(0.2, eColor);
      ig.addColorStop(1, 'transparent');
      ctx.fillStyle = ig;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Layer 3: Primary expanding ring (thick when fresh, thins out)
    ctx.globalAlpha = e.life * 0.7;
    ctx.strokeStyle = eColor;
    ctx.lineWidth = e.isEcho ? 1.5 : (3 + e.life * 3);
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    ctx.stroke();

    // Layer 4: Secondary shockwave ring (trailing, thinner)
    if (!e.isEcho && e.life > 0.3) {
      ctx.globalAlpha = (e.life - 0.3) * 0.3;
      ctx.strokeStyle = madness > 0 ? biomeColorShift('#ffffff', madness * 0.5) : '#ffffff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius * 0.85, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Layer 5: Distortion rays (subtle radial pressure lines)
    if (!e.isEcho && e.life > 0.5) {
      ctx.globalAlpha = (e.life - 0.5) * 0.15;
      ctx.strokeStyle = eColor;
      ctx.lineWidth = 0.5;
      const rayCount = 12;
      for (let r = 0; r < rayCount; r++) {
        const angle = (r / rayCount) * Math.PI * 2 + e.radius * 0.02;
        const innerR = e.radius * 0.7;
        const outerR = e.radius * 1.1;
        ctx.beginPath();
        ctx.moveTo(e.x + Math.cos(angle) * innerR, e.y + Math.sin(angle) * innerR);
        ctx.lineTo(e.x + Math.cos(angle) * outerR, e.y + Math.sin(angle) * outerR);
        ctx.stroke();
      }
    }

    // Layer 6: Shockwave distortion — warp nearby orbs positionally (Geometry Wars style)
    if (!e.isEcho && e.life > 0.3) {
      const shockMadPhys = getMadnessPhysicsScale();
      const warpStr = e.life * 4 * shockMadPhys;
      const warpR = e.radius * 1.3 * shockMadPhys;
      for (let ci = 0; ci < G.circles.length; ci++) {
        const c = G.circles[ci];
        if (c.popped || !c.alive) continue;
        const d = dist(e.x, e.y, c.x, c.y);
        if (d < warpR && d > 5) {
          // Push orbs slightly away from blast center (visual-only wobble)
          const dx = c.x - e.x, dy = c.y - e.y;
          const falloff = (1 - d / warpR) * warpStr;
          c.x += (dx / d) * falloff * 0.3;
          c.y += (dy / d) * falloff * 0.3;
        }
      }
    }

    // Wobble ring — distorted shockwave perimeter (sine-warped radius)
    if (!e.isEcho && e.life > 0.2 && e.life < 0.8) {
      ctx.globalAlpha = (e.life - 0.2) * 0.25;
      ctx.strokeStyle = eColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      const wobbleSegs = 64;
      for (let w = 0; w <= wobbleSegs; w++) {
        const wAngle = (w / wobbleSegs) * Math.PI * 2;
        const wobble = Math.sin(wAngle * 6 + e.radius * 0.1) * e.radius * 0.04 * e.life;
        const wr = e.radius * 1.05 + wobble;
        const wx = e.x + Math.cos(wAngle) * wr;
        const wy = e.y + Math.sin(wAngle) * wr;
        if (w === 0) ctx.moveTo(wx, wy); else ctx.lineTo(wx, wy);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Layer 7: Cosmic dust cloud — space-bending debris field
    if (!e.isEcho && e.life > 0.1) {
      ctx.globalCompositeOperation = 'lighter';
      const dustCount = 16;
      const dustSeed = (e.x * 7.1 + e.y * 13.3) | 0;
      for (let di = 0; di < dustCount; di++) {
        // Deterministic pseudo-random per dust mote
        const hash = ((dustSeed + di * 97 + di * di * 31) & 0xffff) / 65535;
        const hash2 = ((dustSeed + di * 53 + di * 17) & 0xffff) / 65535;
        const hash3 = ((dustSeed + di * 137 + di * 41) & 0xffff) / 65535;
        const dAngle = (di / dustCount) * Math.PI * 2 + hash * 0.8;
        // Dust expands outward, then curves — space distortion
        const expandT = 1 - e.life;
        const dDist = e.radius * (0.5 + expandT * 0.7) * (0.6 + hash2 * 0.6);
        // Spiral distortion — dust curves as if space is bending
        const spiralAngle = dAngle + expandT * (hash - 0.5) * 2.5;
        const dx = e.x + Math.cos(spiralAngle) * dDist;
        const dy = e.y + Math.sin(spiralAngle) * dDist;
        // Size pulsates
        const dSize = (1.5 + hash3 * 3.0) * (0.5 + e.life * 0.5);
        // Colors: mix of whites, blues, golds, violets
        const dustColors = ['#ffffff', '#aaccff', '#ffd080', '#c090ff', '#80ffcc'];
        const dColor = dustColors[di % dustColors.length];
        ctx.globalAlpha = e.life * (0.12 + hash3 * 0.1);
        ctx.fillStyle = madness > 0 ? biomeColorShift(dColor, madness * 0.6) : dColor;
        ctx.beginPath();
        ctx.arc(dx, dy, dSize, 0, Math.PI * 2);
        ctx.fill();
        // Some motes get a streaky tail (bent light)
        if (dSize > 2 && e.life > 0.3) {
          ctx.globalAlpha = e.life * 0.06;
          ctx.strokeStyle = dColor;
          ctx.lineWidth = 0.8;
          const tailAngle = spiralAngle + Math.PI + (hash - 0.5) * 0.5;
          const tailLen = dSize * 3 * e.life;
          ctx.beginPath();
          ctx.moveTo(dx, dy);
          ctx.quadraticCurveTo(
            dx + Math.cos(tailAngle + 0.3) * tailLen * 0.6,
            dy + Math.sin(tailAngle + 0.3) * tailLen * 0.6,
            dx + Math.cos(tailAngle) * tailLen,
            dy + Math.sin(tailAngle) * tailLen
          );
          ctx.stroke();
        }
      }
      ctx.globalCompositeOperation = 'source-over';
    }

    // Layer 8: Space warp ripple — gravitational lens distortion ring
    if (!e.isEcho && e.life > 0.15 && e.life < 0.7) {
      const warpT = (e.life - 0.15) / 0.55;
      ctx.globalAlpha = warpT * 0.08;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = e.radius * 0.06 * warpT;
      ctx.beginPath();
      const lensSegs = 48;
      for (let li = 0; li <= lensSegs; li++) {
        const la = (li / lensSegs) * Math.PI * 2;
        // Double-frequency wobble simulates gravitational lensing
        const lensWarp = Math.sin(la * 3 + e.radius * 0.05) * e.radius * 0.06 * warpT
          + Math.sin(la * 7 - e.radius * 0.03) * e.radius * 0.03 * warpT;
        const lr = e.radius * (1.15 + 0.1 * warpT) + lensWarp;
        const lx = e.x + Math.cos(la) * lr;
        const ly = e.y + Math.sin(la) * lr;
        if (li === 0) ctx.moveTo(lx, ly); else ctx.lineTo(lx, ly);
      }
      ctx.closePath();
      ctx.stroke();
    }

    ctx.restore();
  }
}

function renderParticleLayer(ctx, layer) {
  const particleMadness = getMadnessAmount();
  for (let i = 0; i < particlePool.length; i++) {
    const p = particlePool[i];
    if (!p.active || p.layer !== layer) continue;

    ctx.save();
    ctx.globalAlpha = Math.max(0, p.alpha);

    // Apply madness desaturation to particle colors
    const pColorBase = particleMadness > 0 ? biomeColorShift(p.color, particleMadness * 0.6) : p.color;
    const pColor = fireShift(pColorBase, particleMadness);

    switch(p.type) {
      case 'spark':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'ripple':
        ctx.strokeStyle = pColor;
        ctx.lineWidth = 2 * p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
        break;

      case 'ember':
        const eg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
        eg.addColorStop(0, pColor);
        eg.addColorStop(1, 'transparent');
        ctx.fillStyle = eg;
        ctx.fillRect(p.x - p.size*2, p.y - p.size*2, p.size*4, p.size*4);
        break;

      case 'ribbon':
        if (p.trail && p.trail.length > 1) {
          ctx.strokeStyle = pColor;
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let j = 1; j < p.trail.length; j++) {
            ctx.lineTo(p.trail[j].x, p.trail[j].y);
          }
          ctx.stroke();
        }
        break;

      case 'hex':
        ctx.strokeStyle = pColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let s = 0; s < 6; s++) {
          const a = (Math.PI / 3) * s + p.rotation;
          const hx = p.x + p.size * Math.cos(a);
          const hy = p.y + p.size * Math.sin(a);
          if (s === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
        }
        ctx.closePath();
        ctx.stroke();
        break;

      case 'glitch':
        ctx.fillStyle = pColor;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        break;

      case 'splat':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'star':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        const spikes = 4;
        for (let s = 0; s < spikes * 2; s++) {
          const a = (Math.PI / spikes) * s + p.rotation;
          const sr = s % 2 === 0 ? p.size : p.size * 0.3;
          const sx = p.x + Math.cos(a) * sr;
          const sy = p.y + Math.sin(a) * sr;
          if (s === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        ctx.fill();
        break;

      case 'mote':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        break;
    }

    ctx.restore();
  }
}

function renderFloatingTexts(ctx) {
  const madness = getMadnessAmount();
  // Gameplay text corruption starts at 20% madness, numbers preserved
  const gameTextCorrupt = madness < 0.2 ? 0 : Math.min(1, (madness - 0.2) / 0.6);

  for (let i = 0; i < G.floatingTexts.length; i++) {
    const ft = G.floatingTexts[i];
    const t = ft.life / ft.maxLife;
    const scale = 0.8 + t * 0.7;
    ctx.save();
    // Lore texts: compensate for zoom so they remain readable at any zoom level
    if (ft.lore && G.zoomLevel !== 1) {
      const zoomComp = 1 / G.zoomLevel;
      ctx.translate(ft.x, ft.y);
      ctx.scale(zoomComp, zoomComp);
      ctx.translate(-ft.x, -ft.y);
    }
    const baseFontSize = ft.fontSize || (ft.lore ? 18 : 24);
    // Lore texts: smooth fade in/out with plateau in the middle
    const loreAlpha = ft.lore ? (t > 0.85 ? (1 - t) / 0.15 : t < 0.3 ? t / 0.3 : 1.0) : Math.min(1, t * 2);
    ctx.globalAlpha = loreAlpha;
    ctx.font = `${ft.lore ? 'italic' : 'bold'} ${Math.round(baseFontSize * scale)}px 'Orbitron', 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = madness > 0 ? biomeColorShift(ft.color, madness * 0.5) : ft.color;
    // Apply Enochian corruption to gameplay text (preserve numbers)
    const displayText = gameTextCorrupt > 0 ? corruptTextPreserveNumbers(ft.text, gameTextCorrupt) : ft.text;
    if (ft.lore) {
      // Add subtle text shadow for readability
      ctx.shadowColor = 'rgba(0,0,0,0.7)';
      ctx.shadowBlur = 8;
    }
    ctx.fillText(displayText, ft.x, ft.y);
    ctx.restore();
  }
}

function renderWhiteGlow(ctx, W, H) {
  ctx.save();
  ctx.globalAlpha = G.whiteGlow;
  // Transform game-space coords to screen-space (since this renders outside zoom transform)
  const cx = W / 2, cy = H / 2;
  const screenX = cx + (G.chainOriginX - cx) * G.zoomLevel;
  const screenY = cy + (G.chainOriginY - cy) * G.zoomLevel;
  const glowRadius = Math.max(W, H) * 0.8; // larger radius to always cover full screen
  const grad = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowRadius);
  grad.addColorStop(0, '#ffffff');
  grad.addColorStop(1, 'transparent');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
}

function renderDelayedBlastBuildup(ctx, W, H) {
  const db = G.delayedBlast;
  if (!db) return;
  const progress = Math.min(db.timer / db.duration, 1);
  ctx.save();

  // Darkening overlay — expand to cover full visible area regardless of zoom
  ctx.globalAlpha = db.darkness || 0;
  ctx.fillStyle = '#000000';
  const zInv = G.zoomLevel !== 1 ? 1 / G.zoomLevel : 1;
  const darkW = W * zInv * 1.2, darkH = H * zInv * 1.2;
  const darkX = (W - darkW) * 0.5, darkY = (H - darkH) * 0.5;
  ctx.fillRect(darkX, darkY, darkW, darkH);

  // Convergence glow at center — pulses and grows
  const glowSize = 30 + progress * (db.tier === 3 ? 180 : db.tier === 2 ? 120 : 60);
  const pulse = 1 + Math.sin(db.timer * 12) * 0.2;
  ctx.globalAlpha = 0.3 + progress * 0.6;
  const grad = ctx.createRadialGradient(db.centerX, db.centerY, 0, db.centerX, db.centerY, glowSize * pulse);
  const p = getCurrentPalette();
  grad.addColorStop(0, '#ffffff');
  grad.addColorStop(0.3, p.accent);
  grad.addColorStop(1, 'transparent');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(db.centerX, db.centerY, glowSize * pulse, 0, Math.PI * 2);
  ctx.fill();

  // Converging ring lines
  if (db.tier >= 2) {
    const rings = db.tier === 3 ? 3 : 2;
    for (let r = 0; r < rings; r++) {
      const ringProgress = ((db.timer * 2 + r * 0.4) % 1);
      const ringRadius = (1 - ringProgress) * 300;
      ctx.globalAlpha = ringProgress * 0.4;
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(db.centerX, db.centerY, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ==================================================
// SECTION 13: POST-PROCESSING EFFECTS
// ==================================================
function createScanlinePattern() {
  const sc = document.createElement('canvas');
  sc.width = 4;
  sc.height = 6;
  const sctx = sc.getContext('2d');
  sctx.fillStyle = 'rgba(0,0,0,0.04)';
  sctx.fillRect(0, 0, 4, 2);
  G.scanlinePattern = G.ctx.createPattern(sc, 'repeat');
}

// Nebula clouds — slow-drifting ambient color blobs
const nebulaClouds = [];
for (let i = 0; i < 10; i++) {
  nebulaClouds.push({
    x: Math.random(), y: Math.random(), // 0-1 normalized
    size: 0.12 + Math.random() * 0.28,  // varied sizes, some very large
    speedX: (Math.random() - 0.5) * 0.002,
    speedY: (Math.random() - 0.5) * 0.0015,
    phase: Math.random() * Math.PI * 2,
    breathSpeed: 0.15 + Math.random() * 0.3,  // each cloud breathes at different rate
    colorIdx: Math.floor(Math.random() * 3),
    eccentricity: 0.6 + Math.random() * 0.8   // elongation factor for non-circular shapes
  });
}

function renderNebulaClouds(ctx, W, H) {
  const p = getCurrentPalette();
  const madness = getMadnessAmount();

  // Nebulae fade in at 15%, peak at 40-55%, vanish into the void at 70%+
  let nebulaAlpha;
  if (madness < 0.15) {
    nebulaAlpha = 0;
  } else if (madness < 0.30) {
    nebulaAlpha = (madness - 0.15) / 0.15; // 0→1 from 15% to 30% (faster peak)
  } else if (madness < 0.40) {
    nebulaAlpha = 1.0; // peak (shorter)
  } else if (madness < 0.55) {
    nebulaAlpha = 1.0 - (madness - 0.40) / 0.15; // 1→0 from 40% to 55% (fades earlier)
  } else {
    nebulaAlpha = 0; // consumed by void — the Watchers drink all color
  }
  if (nebulaAlpha < 0.005) return;

  // Don't show in ABYSS or EXPANSE biome
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (isAbyss || G.biomeOverride === 2) return;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < nebulaClouds.length; i++) {
    const nc = nebulaClouds[i];
    // Drift — very slow, majestic movement
    nc.x += nc.speedX * G.dt;
    nc.y += nc.speedY * G.dt;
    // Wrap
    if (nc.x < -0.3) nc.x = 1.3;
    if (nc.x > 1.3) nc.x = -0.3;
    if (nc.y < -0.3) nc.y = 1.3;
    if (nc.y > 1.3) nc.y = -0.3;

    const cx = nc.x * W;
    const cy = nc.y * H;
    const breathe = 1 + Math.sin(G.time * nc.breathSpeed + nc.phase) * 0.2;
    const r = nc.size * Math.min(W, H) * breathe;
    const ry = r * nc.eccentricity; // elongated for organic shapes
    // Brighter during chains
    const chainGlow = G.chainActive ? 0.015 + G.chainCount * 0.0005 : 0;
    // Very faint base — these are extremely blurred, barely-there color washes
    ctx.globalAlpha = (0.03 + chainGlow) * nebulaAlpha;
    const horror = getHorrorAmount();
    const nc1 = horror > 0 ? horrorShift(p.colors[nc.colorIdx], horror) : p.colors[nc.colorIdx];
    const nc2 = horror > 0 ? horrorShift(p.colors[(nc.colorIdx + 1) % 3], horror) : p.colors[(nc.colorIdx + 1) % 3];
    // Very soft, extremely blurred gradient — color concentrated in inner 30%
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    grad.addColorStop(0, nc1);
    grad.addColorStop(0.3, nc2);
    grad.addColorStop(0.6, 'rgba(0,0,0,0.02)');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    // Draw as ellipse for organic, non-circular nebula shapes
    ctx.beginPath();
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(nc.phase + G.time * 0.01); // very slow rotation
    ctx.scale(1, nc.eccentricity);
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.restore();
    ctx.fill();
  }
  ctx.restore();
}

// ABYSS-specific background: deep-sea particles, bioluminescent haze, caustics, marine snow
const abyssParticles = [];
for (let i = 0; i < 25; i++) {
  abyssParticles.push({
    x: Math.random(), y: Math.random(),
    size: 0.5 + Math.random() * 1.5,
    speedY: -(0.002 + Math.random() * 0.005), // slowly rising
    speedX: (Math.random() - 0.5) * 0.002,
    phase: Math.random() * Math.PI * 2,
    bright: Math.random()
  });
}
// Marine snow — tiny sinking particles
const abyssSnow = [];
for (let i = 0; i < 15; i++) {
  abyssSnow.push({
    x: Math.random(), y: Math.random(),
    size: 0.3 + Math.random() * 0.8,
    speedY: 0.003 + Math.random() * 0.004,   // sinking down
    speedX: (Math.random() - 0.5) * 0.001,
    phase: Math.random() * Math.PI * 2,
    bright: 0.3 + Math.random() * 0.7
  });
}

// Oceanic dust — thousands of tiny particles that swirl with gravity, currents, and pressure waves
const ABYSS_DUST_COUNT = 1500;
const abyssDust = [];
for (let i = 0; i < ABYSS_DUST_COUNT; i++) {
  abyssDust.push({
    x: Math.random(),       // 0-1 normalized position
    y: Math.random(),
    vx: (Math.random() - 0.5) * 0.01,  // velocity (normalized)
    vy: (Math.random() - 0.5) * 0.01,
    size: 0.2 + Math.random() * 0.9,   // tiny specks, 0.2-1.1px base
    phase: Math.random() * Math.PI * 2,
    bright: 0.15 + Math.random() * 0.85,
    // Variation in color: 0=teal, 1=pale blue, 2=white, 3=green
    colorType: Math.floor(Math.random() * 4),
    drag: 0.92 + Math.random() * 0.06  // slight drag variation per particle
  });
}
const ABYSS_DUST_COLORS = ['#40ccaa', '#88bbdd', '#ccddee', '#55eebb'];

// Midground twinkling particles — A LOT of them, bloom with bioluminescence
const ABYSS_TWINKLE_COUNT = 600;
const abyssTwinkles = [];
// Extended crazy color palette for twinkling particles
const ABYSS_TWINKLE_COLORS = [
  '#00e5ff', '#00bfa5', '#76ff03', '#e040fb', '#ff4081', '#ffd740', '#7c4dff',
  '#00fff5', '#ff6ec7', '#b0ff00', '#40c4ff', '#ea80fc', '#ffab40', '#69f0ae',
  '#ff80ab', '#b388ff', '#84ffff', '#ccff90'
];
for (let i = 0; i < ABYSS_TWINKLE_COUNT; i++) {
  abyssTwinkles.push({
    x: Math.random(),
    y: Math.random(),
    vx: (Math.random() - 0.5) * 0.004,
    vy: (Math.random() - 0.5) * 0.003 - 0.001, // slight upward drift
    size: 0.4 + Math.random() * 1.8,
    phase: Math.random() * Math.PI * 2,
    twinkleSpeed: 1.5 + Math.random() * 4.0,  // fast twinkling
    bright: 0.2 + Math.random() * 0.8,
    colorIdx: Math.floor(Math.random() * 18),
    pulseOffset: Math.random() * Math.PI * 2
  });
}

function renderAbyssBackground(ctx, W, H) {
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (!isAbyss) return;

  ctx.save();
  const p = getCurrentPalette();
  const sat = getAbyssSaturation(); // 0 = B&W void, 1 = vivid bioluminescence
  const vivid = p.vividColors || p.colors;

  // Compute visible area in game-space (compensates for zoom transform)
  const zInv = G.zoomLevel !== 1 ? 1 / G.zoomLevel : 1;
  const visW = W * zInv;
  const visH = H * zInv;
  const visL = (W - visW) * 0.5;
  const visT = (H - visH) * 0.5;

  // Helper: get a saturated Abyss color (desaturated at low madness, vivid at high)
  const satColor = (hex) => abyssDesaturate(hex, sat);
  // At high saturation, pick from extended vivid palette for variety
  const vividIdx = (i) => vivid[i % vivid.length];

  // Bioluminescent haze blobs — soft glowing patches
  // Invisible in the void (sat=0), bloom to life with saturation
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < 5; i++) {
    const hx = visL + visW * (0.15 + i * 0.18) + Math.sin(G.time * 0.08 + i * 2) * visW * 0.08;
    const hy = visT + visH * (0.25 + i * 0.12) + Math.cos(G.time * 0.06 + i * 3) * visH * 0.07;
    const hr = Math.min(visW, visH) * (0.18 + 0.07 * Math.sin(G.time * 0.12 + i));
    const breathe = 0.6 + 0.4 * Math.sin(G.time * 0.2 + i * 1.5);
    // Alpha scales with saturation: barely visible in void, blooming with color
    ctx.globalAlpha = (0.005 + 0.025 * sat) * breathe;
    const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, hr);
    hGrad.addColorStop(0, satColor(vividIdx(i)));
    hGrad.addColorStop(0.4, satColor(p.accent));
    hGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = hGrad;
    ctx.beginPath();
    ctx.arc(hx, hy, hr, 0, Math.PI * 2);
    ctx.fill();
  }

  // Volumetric light shafts — wide, blurred beams from surface
  // In the void: faint grey shafts. With saturation: colored bioluminescent beams
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < 6; i++) {
    const cx = visL + visW * (0.1 + i * 0.15) + Math.sin(G.time * 0.2 + i * 1.7) * visW * 0.1;
    const topY = visT;
    const botY = visT + visH * (0.55 + Math.sin(G.time * 0.15 + i * 2.3) * 0.12);
    const beamW = (50 + Math.sin(G.time * 0.3 + i * 3.1) * 25) * zInv;
    const shimmer = 0.5 + 0.5 * Math.sin(G.time * 0.6 + i * 2.1);
    // Light shafts dimmer in void, brighter with saturation
    const shaftAlpha = 0.008 + 0.022 * sat;
    // Outer soft glow cone
    ctx.globalAlpha = shaftAlpha * shimmer;
    const glowGrad = ctx.createLinearGradient(cx, topY, cx + beamW * 0.2, botY);
    glowGrad.addColorStop(0, satColor(vividIdx(i)));
    glowGrad.addColorStop(0.2, satColor(p.colors[0]));
    glowGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.moveTo(cx - beamW * 1.5, topY);
    ctx.lineTo(cx + beamW * 1.5, topY);
    ctx.lineTo(cx + beamW * 0.4, botY);
    ctx.lineTo(cx - beamW * 0.4, botY);
    ctx.closePath();
    ctx.fill();
    // Inner bright core beam
    ctx.globalAlpha = (0.01 + 0.035 * sat) * shimmer;
    const coreGrad = ctx.createLinearGradient(cx, topY, cx + beamW * 0.1, topY + (botY - topY) * 0.8);
    coreGrad.addColorStop(0, satColor('#ffffff'));
    coreGrad.addColorStop(0.15, satColor(p.accent));
    coreGrad.addColorStop(0.5, satColor(p.colors[0]));
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.moveTo(cx - beamW * 0.6, topY);
    ctx.lineTo(cx + beamW * 0.6, topY);
    ctx.lineTo(cx + beamW * 0.15, topY + (botY - topY) * 0.8);
    ctx.lineTo(cx - beamW * 0.15, topY + (botY - topY) * 0.8);
    ctx.closePath();
    ctx.fill();
  }

  // Drifting deep-sea particles — tiny rising motes (bioluminescence)
  // Barely visible grey specks in void, glowing colored motes with saturation
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < abyssParticles.length; i++) {
    const ap = abyssParticles[i];
    ap.x += ap.speedX * G.dt;
    ap.y += ap.speedY * G.dt;
    if (ap.y < -0.05) { ap.y = 1.05; ap.x = Math.random(); }
    if (ap.x < -0.05) ap.x = 1.05;
    if (ap.x > 1.05) ap.x = -0.05;

    const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(G.time * 0.5 + ap.phase));
    ctx.globalAlpha = (0.02 + 0.07 * sat) * twinkle * ap.bright;
    ctx.fillStyle = satColor(vividIdx(i + 2)); // varied vivid colors at high sat
    ctx.beginPath();
    ctx.arc(visL + ap.x * visW, visT + ap.y * visH, ap.size * zInv, 0, Math.PI * 2);
    ctx.fill();
  }

  // Marine snow — tiny white particles sinking downward
  // Always somewhat visible (even in void — they're the first hint of something)
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < abyssSnow.length; i++) {
    const ms = abyssSnow[i];
    ms.x += ms.speedX * G.dt;
    ms.y += ms.speedY * G.dt;
    if (ms.y > 1.05) { ms.y = -0.05; ms.x = Math.random(); }
    if (ms.x < -0.05) ms.x = 1.05;
    if (ms.x > 1.05) ms.x = -0.05;

    const drift = Math.sin(G.time * 0.3 + ms.phase) * 0.5 + 0.5;
    ctx.globalAlpha = (0.03 + 0.04 * sat) * drift * ms.bright;
    ctx.fillStyle = satColor('#aaccdd');
    ctx.beginPath();
    ctx.arc(visL + ms.x * visW, visT + ms.y * visH, ms.size * zInv, 0, Math.PI * 2);
    ctx.fill();
  }

  // Oceanic dust — 1500 tiny particles swirling with gravity, currents, pressure waves
  ctx.globalCompositeOperation = 'lighter';
  {
    const dt = G.dt;
    // Get field center in normalized coords
    const gcx = 0.5;
    const gcy = 0.5;
    // Get black hole positions in normalized coords (if any)
    const bhNormX = G.blackHole ? (G.blackHole.x - visL) / visW : -1;
    const bhNormY = G.blackHole ? (G.blackHole.y - visT) / visH : -1;
    const bhActive = G.blackHole && bhNormX > -0.2 && bhNormX < 1.2 && bhNormY > -0.2 && bhNormY < 1.2;
    const sbhNormX = G.superBlackHole ? (G.superBlackHole.x - visL) / visW : -1;
    const sbhNormY = G.superBlackHole ? (G.superBlackHole.y - visT) / visH : -1;
    const sbhActive = G.superBlackHole && sbhNormX > -0.2 && sbhNormX < 1.2 && sbhNormY > -0.2 && sbhNormY < 1.2;
    // Pressure wave influence
    const pressureActive = abyssPressureWave > 0;
    const pressureStr = pressureActive ? Math.sin((1.5 - abyssPressureWave) / 1.5 * Math.PI) : 0;
    // Underwater current angle
    const currentAngleBase = Math.sin(G.time * 0.1) * 0.3;
    const madScale = getMadnessPhysicsScale();

    for (let i = 0; i < ABYSS_DUST_COUNT; i++) {
      const dp = abyssDust[i];

      // Apply drag
      dp.vx *= dp.drag;
      dp.vy *= dp.drag;

      // Gentle underwater current (same as orb current but weaker)
      const localCurrent = Math.sin(G.time * 0.1 + dp.y * 3) * 0.3;
      dp.vx += Math.cos(localCurrent) * 0.003 * dt * madScale;
      dp.vy += Math.sin(localCurrent) * 0.001 * dt * madScale;

      // Gentle upward float (deep-sea convection)
      dp.vy -= 0.0005 * dt;

      // Brownian motion — tiny random jitter
      dp.vx += (Math.random() - 0.5) * 0.002 * dt;
      dp.vy += (Math.random() - 0.5) * 0.002 * dt;

      // Pressure wave — push toward center
      if (pressureActive) {
        const pdx = gcx - dp.x, pdy = gcy - dp.y;
        const pd = Math.sqrt(pdx * pdx + pdy * pdy) + 0.01;
        const pStr = pressureStr * 0.04 * madScale * dt * Math.min(1, pd * 2);
        dp.vx += (pdx / pd) * pStr;
        dp.vy += (pdy / pd) * pStr;
      }

      // Black hole gravity pull (normalized space)
      if (bhActive) {
        const bdx = bhNormX - dp.x, bdy = bhNormY - dp.y;
        const bd = Math.sqrt(bdx * bdx + bdy * bdy) + 0.01;
        if (bd < 0.5) {
          const bStr = 0.03 * dt / (bd * bd + 0.01);
          // Radial pull + tangential spin
          dp.vx += (bdx / bd) * bStr + (-bdy / bd) * bStr * 0.4;
          dp.vy += (bdy / bd) * bStr + (bdx / bd) * bStr * 0.4;
        }
      }

      // Supermassive black hole — massive gravity, wider range
      if (sbhActive) {
        const sdx = sbhNormX - dp.x, sdy = sbhNormY - dp.y;
        const sd = Math.sqrt(sdx * sdx + sdy * sdy) + 0.01;
        if (sd < 0.8) {
          const sStr = 0.08 * dt / (Math.sqrt(sd) + 0.02);
          dp.vx += (sdx / sd) * sStr + (-sdy / sd) * sStr * 0.5;
          dp.vy += (sdy / sd) * sStr + (sdx / sd) * sStr * 0.5;
        }
      }

      // Clamp velocity
      const vMag = Math.sqrt(dp.vx * dp.vx + dp.vy * dp.vy);
      if (vMag > 0.08) { dp.vx *= 0.08 / vMag; dp.vy *= 0.08 / vMag; }

      // Integrate position
      dp.x += dp.vx;
      dp.y += dp.vy;

      // Wrap around edges
      if (dp.x < -0.05) dp.x += 1.1;
      if (dp.x > 1.05) dp.x -= 1.1;
      if (dp.y < -0.05) dp.y += 1.1;
      if (dp.y > 1.05) dp.y -= 1.1;

      // Render — tiny glowing speck (desaturated in void, vivid with madness)
      const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(G.time * 0.8 + dp.phase));
      ctx.globalAlpha = (0.01 + 0.035 * sat) * twinkle * dp.bright;
      ctx.fillStyle = satColor(ABYSS_DUST_COLORS[dp.colorType]);
      const px = visL + dp.x * visW;
      const py = visT + dp.y * visH;
      const pSize = dp.size * zInv;
      // For performance, use fillRect for most particles (cheaper than arc)
      if (pSize < 1.2) {
        ctx.fillRect(px - pSize * 0.5, py - pSize * 0.5, pSize, pSize);
      } else {
        ctx.beginPath();
        ctx.arc(px, py, pSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Depth fog — darkness gradient at bottom (deep pressure)
  // Stronger in void (heavier darkness), lighter as colors bloom
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 0.25 - sat * 0.12; // 0.25 in void → 0.13 at full saturation
  const depthGrad = ctx.createLinearGradient(visL, visT + visH * 0.5, visL, visT + visH);
  depthGrad.addColorStop(0, 'transparent');
  depthGrad.addColorStop(1, '#000408');
  ctx.fillStyle = depthGrad;
  ctx.fillRect(visL, visT, visW, visH);

  // === MID-GROUND TWINKLING PARTICLES — hundreds of colored sparks ===
  // Invisible in void, explode with color in bioluminescent phase
  if (sat > 0.12) {
    ctx.globalCompositeOperation = 'lighter';
    const twinkleBase = (sat - 0.12) / 0.88; // 0→1
    const twinkleAlpha = twinkleBase * twinkleBase * 0.18; // quadratic ramp, max 0.18

    for (let i = 0; i < ABYSS_TWINKLE_COUNT; i++) {
      const tp = abyssTwinkles[i];

      // Gentle drift
      tp.x += tp.vx * G.dt * 0.5;
      tp.y += tp.vy * G.dt * 0.5;
      // Wrap
      if (tp.x < -0.02) tp.x += 1.04;
      if (tp.x > 1.02) tp.x -= 1.04;
      if (tp.y < -0.02) tp.y += 1.04;
      if (tp.y > 1.02) tp.y -= 1.04;

      // Fast twinkling — each particle blinks at its own rate
      const twinkle = Math.abs(Math.sin(G.time * tp.twinkleSpeed + tp.phase));
      // Sharp cutoff: only visible when twinkle > 0.4 (creates blinking effect)
      if (twinkle < 0.4) continue;
      const twinkleStr = (twinkle - 0.4) / 0.6; // 0→1 over the visible range

      ctx.globalAlpha = twinkleAlpha * tp.bright * twinkleStr;
      // At high saturation, use crazy colors directly. At lower sat, desaturate them
      const rawColor = ABYSS_TWINKLE_COLORS[tp.colorIdx];
      ctx.fillStyle = sat > 0.7 ? rawColor : satColor(rawColor);

      const px = visL + tp.x * visW;
      const py = visT + tp.y * visH;
      const pSize = tp.size * zInv * (0.5 + twinkleStr * 0.5);

      // Small particles: fast fillRect. Larger ones: glowing circle
      if (pSize < 1.0) {
        ctx.fillRect(px - pSize * 0.5, py - pSize * 0.5, pSize, pSize);
      } else {
        ctx.beginPath();
        ctx.arc(px, py, pSize, 0, Math.PI * 2);
        ctx.fill();
        // Larger particles get a glow halo at high saturation
        if (pSize > 1.5 && sat > 0.5) {
          ctx.globalAlpha *= 0.3;
          ctx.beginPath();
          ctx.arc(px, py, pSize * 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // === MID-GROUND NEBULA SPHERES — ambient color washes that bloom with saturation ===
  // Large, very blurred radial gradients that float between background and foreground
  // Invisible in void, gradually appearing as bizarre deep-sea ambient light
  if (sat > 0.08) {
    ctx.globalCompositeOperation = 'lighter';
    const nebulaCount = 8;
    const nebulaAlpha = Math.pow(sat, 1.5) * 0.045; // very subtle, cubic ramp
    for (let i = 0; i < nebulaCount; i++) {
      // Slow, independent orbits — each nebula drifts on its own path
      const seed = i * 2.71 + 0.5;
      const nx = visL + visW * (0.1 + 0.8 * ((Math.sin(G.time * 0.025 + seed) * 0.5 + 0.5)));
      const ny = visT + visH * (0.1 + 0.8 * ((Math.cos(G.time * 0.019 + seed * 1.7) * 0.5 + 0.5)));
      const breathe2 = 0.7 + 0.3 * Math.sin(G.time * 0.15 + seed * 3.1);
      const nr = Math.min(visW, visH) * (0.12 + 0.08 * Math.sin(G.time * 0.08 + i * 1.4)) * breathe2;

      ctx.globalAlpha = nebulaAlpha * breathe2;
      const nGrad = ctx.createRadialGradient(nx, ny, 0, nx, ny, nr);
      // Use extended vivid palette for rich variety
      const nc1 = satColor(vividIdx(i));
      const nc2 = satColor(vividIdx(i + 3));
      nGrad.addColorStop(0, nc1);
      nGrad.addColorStop(0.35, nc2);
      nGrad.addColorStop(0.7, 'rgba(0,0,0,0.01)');
      nGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = nGrad;
      ctx.beginPath();
      ctx.arc(nx, ny, nr, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// ========== EXPANSE BACKGROUND (B3) ==========
// Sand particles — fine amber/bone dust drifting horizontally with desert wind
const EXPANSE_SAND_COUNT = 200;
const expanseSand = [];
for (let i = 0; i < EXPANSE_SAND_COUNT; i++) {
  expanseSand.push({
    x: Math.random(), y: Math.random(),
    size: 0.3 + Math.random() * 1.0,
    speedX: 0.003 + Math.random() * 0.008, // rightward wind
    speedY: (Math.random() - 0.5) * 0.001, // tiny vertical drift
    phase: Math.random() * Math.PI * 2,
    bright: 0.2 + Math.random() * 0.8
  });
}
const EXPANSE_SAND_COLORS = ['#d4920a', '#b87333', '#e8d5b0', '#8b6914', '#daa520'];

// Red eye pairs — slow drifters at screen edges
const EXPANSE_EYES_COUNT = 4;
const expanseEyes = [];
for (let i = 0; i < EXPANSE_EYES_COUNT; i++) {
  expanseEyes.push({
    x: Math.random() < 0.5 ? Math.random() * 0.08 : 0.92 + Math.random() * 0.08,
    y: 0.2 + Math.random() * 0.6,
    speedX: (Math.random() - 0.5) * 0.0005,
    speedY: (Math.random() - 0.5) * 0.0008,
    blinkPhase: Math.random() * Math.PI * 2,
    blinkSpeed: 0.3 + Math.random() * 0.4,
    separation: 8 + Math.random() * 6, // pixels between pair
    size: 1.5 + Math.random() * 1.0
  });
}

function renderExpanseBackground(ctx, W, H) {
  if (G.biomeOverride !== 2) return;

  ctx.save();
  const p = getCurrentPalette();

  // Compute visible area (compensates for zoom transform)
  const zInv = G.zoomLevel !== 1 ? 1 / G.zoomLevel : 1;
  const visW = W * zInv;
  const visH = H * zInv;
  const visL = (W - visW) * 0.5;
  const visT = (H - visH) * 0.5;

  // --- Horizon glow: warm orange haze at bottom third ---
  ctx.globalCompositeOperation = 'lighter';
  const hzGrad = ctx.createLinearGradient(W * 0.5, visT + visH * 0.6, W * 0.5, visT + visH);
  hzGrad.addColorStop(0, 'transparent');
  hzGrad.addColorStop(0.4, 'rgba(212,146,10,0.015)');
  hzGrad.addColorStop(0.8, 'rgba(184,115,51,0.025)');
  hzGrad.addColorStop(1.0, 'rgba(139,69,19,0.02)');
  ctx.globalAlpha = 0.8 + 0.2 * Math.sin(G.time * 0.1);
  ctx.fillStyle = hzGrad;
  ctx.fillRect(visL, visT, visW, visH);

  // --- Heat haze blobs: subtle warm patches that breathe ---
  for (let i = 0; i < 3; i++) {
    const hx = visL + visW * (0.2 + i * 0.3) + Math.sin(G.time * 0.06 + i * 2.1) * visW * 0.06;
    const hy = visT + visH * (0.65 + i * 0.08) + Math.cos(G.time * 0.04 + i * 1.7) * visH * 0.03;
    const hr = Math.min(visW, visH) * (0.15 + 0.05 * Math.sin(G.time * 0.08 + i));
    const breathe = 0.6 + 0.4 * Math.sin(G.time * 0.15 + i * 1.5);
    ctx.globalAlpha = 0.012 * breathe;
    const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, hr);
    hGrad.addColorStop(0, p.accent);
    hGrad.addColorStop(0.5, p.colors[0]);
    hGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = hGrad;
    ctx.beginPath();
    ctx.arc(hx, hy, hr, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Sand particles: drifting horizontally with wind ---
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < expanseSand.length; i++) {
    const sp = expanseSand[i];
    sp.x += sp.speedX * G.dt;
    sp.y += sp.speedY * G.dt;
    // Wind gusts — subtle acceleration
    sp.speedX += Math.sin(G.time * 0.3 + sp.phase) * 0.00002;
    sp.speedX = Math.max(0.002, Math.min(0.012, sp.speedX)); // clamp wind speed
    // Wrap
    if (sp.x > 1.05) { sp.x = -0.05; sp.y = Math.random(); }
    if (sp.y < -0.02) sp.y = 1.02;
    if (sp.y > 1.02) sp.y = -0.02;

    const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(G.time * 0.4 + sp.phase));
    ctx.globalAlpha = 0.04 * twinkle * sp.bright;
    ctx.fillStyle = EXPANSE_SAND_COLORS[i % EXPANSE_SAND_COLORS.length];
    ctx.beginPath();
    ctx.arc(visL + sp.x * visW, visT + sp.y * visH, sp.size * zInv, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Red eye pairs: dim watchers at screen edges ---
  ctx.globalCompositeOperation = 'source-over';
  for (let i = 0; i < expanseEyes.length; i++) {
    const eye = expanseEyes[i];
    eye.x += eye.speedX * G.dt;
    eye.y += eye.speedY * G.dt;
    // Gentle wandering — stay near edges
    if (eye.x < 0.0) eye.speedX = Math.abs(eye.speedX);
    if (eye.x > 0.15 && eye.x < 0.85) {
      // Drifted too far from edge — push back
      eye.speedX = eye.x < 0.5 ? -Math.abs(eye.speedX) : Math.abs(eye.speedX);
    }
    if (eye.x > 1.0) eye.speedX = -Math.abs(eye.speedX);
    if (eye.y < 0.1) eye.speedY = Math.abs(eye.speedY);
    if (eye.y > 0.9) eye.speedY = -Math.abs(eye.speedY);

    // Blink: independent per eye-pair
    const blinkCycle = Math.sin(G.time * eye.blinkSpeed + eye.blinkPhase);
    // Eyes visible most of the time, blink closed briefly
    const eyeAlpha = blinkCycle < -0.85 ? 0 : // blink closed
                     blinkCycle < -0.7 ? (blinkCycle + 0.85) / 0.15 : // opening
                     0.6 + 0.4 * Math.sin(G.time * 0.8 + i * 2.3); // gentle pulse

    if (eyeAlpha > 0.01) {
      const ex = visL + eye.x * visW;
      const ey = visT + eye.y * visH;
      const sep = eye.separation * zInv;
      const sz = eye.size * zInv;

      // Draw both eyes of the pair
      for (let e = -1; e <= 1; e += 2) {
        const px = ex + e * sep * 0.5;
        ctx.globalAlpha = eyeAlpha * 0.35;
        // Outer glow
        const glow = ctx.createRadialGradient(px, ey, 0, px, ey, sz * 3);
        glow.addColorStop(0, 'rgba(200,30,30,0.3)');
        glow.addColorStop(0.5, 'rgba(200,30,30,0.05)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(px, ey, sz * 3, 0, Math.PI * 2);
        ctx.fill();
        // Core dot
        ctx.globalAlpha = eyeAlpha * 0.7;
        ctx.fillStyle = '#cc2020';
        ctx.beginPath();
        ctx.arc(px, ey, sz, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// Bloom glow behind orbs — soft radial gradient halo
function renderOrbBloom(ctx) {
  ctx.save();
  // Apply hardware-accelerated blur to the bloom layer for truly soft glow
  // The orbs themselves (renderCircles) are drawn AFTER this — they stay crisp
  ctx.filter = 'blur(6px)';
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    if (c.fadeIn > 0.5) continue; // don't bloom while barely visible

    const pulse = 1 + Math.sin(c.pulsePhase) * 0.12;
    const r = c.radius * pulse * 2.2;
    const spawnScale = c.spawnAnim > 0 ? (1 - c.spawnAnim) : 1;
    const drawR = r * spawnScale;
    if (drawR < 3) continue;

    // Volatile orbs glow brighter, larger bloom
    const bloomAlpha = c.volatile ? 0.16 : (c.superCell ? 0.12 : 0.06);
    ctx.globalAlpha = bloomAlpha;

    // Flat bloom: single color circle (blur filter handles the softness)
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.arc(c.x, c.y, drawR * 0.8, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.filter = 'none';
  ctx.restore();
}

// Light rays emanating from active explosions
function renderLightRays(ctx, W, H) {
  if (G.explosions.length === 0) return;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < G.explosions.length; i++) {
    const e = G.explosions[i];
    if (e.life < 0.3) continue; // only fresh explosions emit rays

    const rayCount = 8;
    const rayLen = e.maxRadius * 1.5 * e.life;
    ctx.globalAlpha = e.life * 0.06;
    ctx.strokeStyle = fireShift(e.color, getMadnessAmount());
    ctx.lineWidth = 1 + e.life * 2;
    for (let r = 0; r < rayCount; r++) {
      const angle = (r / rayCount) * Math.PI * 2 + G.time * 0.5 + i * 1.7;
      const endX = e.x + Math.cos(angle) * rayLen;
      const endY = e.y + Math.sin(angle) * rayLen;
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    }
  }
  ctx.restore();
}

// Energy distortion pulse rings during active chain
function renderChainEnergyField(ctx, W, H) {
  if (!G.chainActive || G.chainCount < 3) return;
  ctx.save();
  const cx = G.chainOriginX;
  const cy = G.chainOriginY;
  const intensity = Math.min(1, G.chainCount / 30);

  // Pulsing distortion rings
  const ringCount = Math.min(4, Math.floor(G.chainCount / 6));
  for (let r = 0; r < ringCount; r++) {
    const phase = (G.time * 3 + r * 1.5) % 3;
    const radius = phase * 120;
    const alpha = Math.max(0, (1 - phase / 3)) * intensity * 0.12;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = fireShift(getCurrentPalette().accent, getMadnessAmount());
    ctx.lineWidth = 1.5 - phase * 0.3;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.stroke();
  }
  ctx.restore();
}

function renderVignette(ctx, W, H) {
  const grad = ctx.createRadialGradient(W/2, H/2, W*0.25, W/2, H/2, W*0.8);
  grad.addColorStop(0, 'transparent');
  grad.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function renderChromaticAb(ctx, W, H) {
  const offset = G.chromaticAb * 1.5;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 0.08;
  ctx.drawImage(G.canvas, -offset, 0);
  ctx.drawImage(G.canvas, offset, 0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// ==================================================
// SECTION 14: INPUT HANDLING
// ==================================================

// Convert screen coordinates to game world coordinates (accounting for zoom)
function screenToWorld(sx, sy) {
  const cx = G.W / 2, cy = G.H / 2;
  return {
    x: (sx - cx) / G.zoomLevel + cx,
    y: (sy - cy) / G.zoomLevel + cy
  };
}

function handleTap(x, y) {
  initAudio();

  // Don't start game while splash screens are active
  if (splashPhase !== 'done' && G.state === 'title') {
    advanceSplash();
    return;
  }

  if (G.state === 'title') {
    resetGame();
    return;
  }

  if (G.state === 'game_over') {
    resetGame();
    return;
  }

  if (G.state !== 'playing') return;
  if (G.taps <= 0) return;
  if (G.pendingLevelUp) return;

  // Reset tap timer on every click
  G.tapTimer = G.tapTimerMax;

  // Black hole tap: triggers collapse for free (doesn't cost a tap)
  if (tryTapSuperBlackHole(x, y)) return;
  if (tryTapBlackHole(x, y)) return;

  // Normal tap — startChain (mines now launched via long press)
  G.bombsPlacedThisRound = 0;
  startChain(x, y);
}

function handleLongPress(x, y) {
  // Long press places mine if charges available
  if (G.state !== 'playing') return;
  const charges = G.upgrades.bombCharges;
  if (charges <= 0) return;
  if (G.bombsPlacedThisRound >= charges) return;

  placeBomb(x, y);
  G.bombsPlacedThisRound++;
  updateHUD();
  // Visual feedback
  spawnFloatingText(x, y - 20, 'SIGIL PLACED', '#ff8800');
}

function setupInput() {
  const c = G.canvas;
  const LONG_PRESS_MS = 350; // 350ms hold = long press → mine
  let pressTimer = null;
  let pressPos = null;
  let didLongPress = false;

  function startPress(wx, wy) {
    pressPos = { x: wx, y: wy };
    didLongPress = false;
    clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      didLongPress = true;
      handleLongPress(pressPos.x, pressPos.y);
    }, LONG_PRESS_MS);
  }

  function endPress(wx, wy) {
    clearTimeout(pressTimer);
    if (!didLongPress) {
      // Short tap — normal action
      handleTap(wx, wy);
    }
    pressTimer = null;
    pressPos = null;
    didLongPress = false;
  }

  function cancelPress() {
    clearTimeout(pressTimer);
    pressTimer = null;
    pressPos = null;
    didLongPress = false;
  }

  c.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = c.getBoundingClientRect();
    const sx = touch.clientX - rect.left;
    const sy = touch.clientY - rect.top;
    const w = screenToWorld(sx, sy);
    G.cursorX = w.x; G.cursorY = w.y;
    initAudio();
    startPress(w.x, w.y);
  }, { passive: false });

  c.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (pressPos) {
      endPress(pressPos.x, pressPos.y);
    }
  }, { passive: false });

  c.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
      const rect = c.getBoundingClientRect();
      const w = screenToWorld(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      G.cursorX = w.x; G.cursorY = w.y;
      // Update press position if dragging during long press
      if (pressPos) {
        pressPos.x = w.x;
        pressPos.y = w.y;
      }
    }
  }, { passive: false });

  c.addEventListener('mousedown', (e) => {
    const rect = c.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const w = screenToWorld(sx, sy);
    G.cursorX = w.x; G.cursorY = w.y;
    initAudio();
    startPress(w.x, w.y);
  });

  c.addEventListener('mouseup', (e) => {
    const rect = c.getBoundingClientRect();
    const w = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
    if (pressPos) {
      endPress(w.x, w.y);
    }
  });

  c.addEventListener('mousemove', (e) => {
    const rect = c.getBoundingClientRect();
    const w = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
    G.cursorX = w.x; G.cursorY = w.y;
  });

  c.addEventListener('mouseleave', () => {
    G.cursorX = -1000; G.cursorY = -1000;
    cancelPress();
  });

  // Keyboard: B toggles biome, X toggles Expanse
  document.addEventListener('keydown', (e) => {
    if (e.key === 'b' || e.key === 'B') {
      toggleBiome();
    } else if (e.key === 'x' || e.key === 'X') {
      toggleExpanse();
    }
  });

  // Biome button
  document.getElementById('biome-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleBiome();
  });

  // Dev: Madness toggle button
  document.getElementById('madness-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    if (devMadnessOverride >= 0) {
      devMadnessOverride = -1; // off — restore normal
      document.getElementById('madness-btn').classList.remove('active');
      // Restore score-based zoom
      G.zoomTarget = Math.max(0.5, 2.0 - G.score * (1.5 / 400000));
      // Snap watcher opacity to 0 immediately
      G.watcher.opacity = 0;
    } else {
      devMadnessOverride = 1.0; // full madness
      document.getElementById('madness-btn').classList.add('active');
    }
  });

  // Dev: Auto level-up toggle button
  document.getElementById('autolvl-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    autoLevelUp = !autoLevelUp;
    document.getElementById('autolvl-btn').classList.toggle('active', autoLevelUp);
  });

  // Dev: Infinite taps toggle button
  document.getElementById('inftaps-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    infiniteTaps = !infiniteTaps;
    document.getElementById('inftaps-btn').classList.toggle('active', infiniteTaps);
  });

  // Dev: Test level toggle button (TESTLEVEL — copy of Biome 1 for experimentation)
  document.getElementById('testlvl-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleTestLevel();
  });

  // Dev: Expanse biome toggle button
  document.getElementById('expanse-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleExpanse();
  });

  // Dev: Spawn mini black hole
  document.getElementById('spawnmbh-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    if (G.state !== 'playing') return;
    const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
    const mbh = {
      x: gcx, y: gcy,
      radius: MINI_BH_VISUAL_RADIUS,
      gravityRadius: MINI_BH_GRAV_RADIUS,
      strength: MINI_BH_STRENGTH,
      life: MINI_BH_LIFETIME_MIN + Math.random() * (MINI_BH_LIFETIME_MAX - MINI_BH_LIFETIME_MIN),
      maxLife: 0, fadeIn: 0,
      phase: Math.random() * Math.PI * 2,
      dust: []
    };
    mbh.maxLife = mbh.life;
    for (let di = 0; di < 8; di++) {
      mbh.dust.push({ angle: Math.random() * Math.PI * 2, dist: 0.3 + Math.random() * 0.5, size: 0.3 + Math.random() * 0.6, speed: 0.8 + Math.random() * 1.5 });
    }
    if (!G.miniBlackHoles) G.miniBlackHoles = [];
    G.miniBlackHoles.push(mbh);
    spawnFloatingText(mbh.x, mbh.y - 20, 'GRAVITATIONAL NEEDLE', '#60e0ff', 1.5, { fontSize: 11 });
  });

  // Prevent default behaviors
  document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
}

function toggleBiome() {
  // Snapshot current palette before switching
  G.prevPalette = getCurrentPalette();
  if (G.biomeOverride === 0) {
    G.biomeOverride = -1;
    document.getElementById('biome-btn').classList.remove('active');
  } else {
    G.biomeOverride = 0;
    document.getElementById('biome-btn').classList.add('active');
    // Deactivate other biome buttons
    document.getElementById('testlvl-btn').classList.remove('active');
    document.getElementById('expanse-btn').classList.remove('active');
  }
  // Trigger smooth palette transition
  G.biomeTransition = 0;
  // Re-color all existing orbs
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.popped && c.alive) {
      const clr = getClusterColor(c.x, c.y);
      c.color = clr.color;
      c.colorIdx = clr.colorIdx;
      c.colorEdge = c.color;
    }
  }
  // Show biome lore text
  const togglePalette = getCurrentPalette();
  const toggleLoreArr = BIOME_LORE[togglePalette.name] || [];
  const toggleLore = toggleLoreArr.length ? toggleLoreArr[Math.floor(Math.random() * toggleLoreArr.length)] : '';
  if (toggleLore) {
    const lx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const ly = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.3;
    setTimeout(() => spawnFloatingText(lx, ly, toggleLore, togglePalette.accent, 3.5, { lore: true }), 800);
  }
}

function toggleTestLevel() {
  // Toggle TESTLEVEL biome (index 1 in SPECIAL_BIOMES)
  G.prevPalette = getCurrentPalette();
  if (G.biomeOverride === 1) {
    G.biomeOverride = -1;
    document.getElementById('testlvl-btn').classList.remove('active');
  } else {
    G.biomeOverride = 1;
    document.getElementById('testlvl-btn').classList.add('active');
    // Deactivate other biome buttons
    document.getElementById('biome-btn').classList.remove('active');
    document.getElementById('expanse-btn').classList.remove('active');
  }
  G.biomeTransition = 0;
  // Re-color all existing orbs
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.popped && c.alive) {
      const clr = getClusterColor(c.x, c.y);
      c.color = clr.color;
      c.colorIdx = clr.colorIdx;
      c.colorEdge = c.color;
    }
  }
}

function toggleExpanse() {
  // Toggle EXPANSE biome (index 2 in SPECIAL_BIOMES)
  G.prevPalette = getCurrentPalette();
  if (G.biomeOverride === 2) {
    G.biomeOverride = -1;
    document.getElementById('expanse-btn').classList.remove('active');
  } else {
    G.biomeOverride = 2;
    document.getElementById('expanse-btn').classList.add('active');
    // Deactivate other biome buttons
    document.getElementById('biome-btn').classList.remove('active');
    document.getElementById('testlvl-btn').classList.remove('active');
  }
  G.biomeTransition = 0;
  // Re-color all existing orbs
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.popped && c.alive) {
      const clr = getClusterColor(c.x, c.y);
      c.color = clr.color;
      c.colorIdx = clr.colorIdx;
      c.colorEdge = c.color;
    }
  }
  // Show biome lore text
  const togglePalette = getCurrentPalette();
  const toggleLoreArr = BIOME_LORE[togglePalette.name] || [];
  const toggleLore = toggleLoreArr.length ? toggleLoreArr[Math.floor(Math.random() * toggleLoreArr.length)] : '';
  if (toggleLore) {
    const lx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const ly = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.3;
    setTimeout(() => spawnFloatingText(lx, ly, toggleLore, togglePalette.accent, 3.5, { lore: true }), 800);
  }
}

// Advance to the next biome (called when field is cleared)
function advanceBiome() {
  G.prevPalette = getCurrentPalette();
  if (G.biomeOverride >= 0) {
    // Currently in a special biome — cycle back to level-based
    G.biomeOverride = -1;
    document.getElementById('biome-btn').classList.remove('active');
  } else {
    // Level-based: force advance to next palette index
    const curIdx = Math.min(Math.floor((G.level - 1) / PALETTE_LEVELS), PALETTES.length - 1);
    const nextIdx = (curIdx + 1) % PALETTES.length;
    // Bump level to match the next palette
    G.level = nextIdx * PALETTE_LEVELS + 1;
    G.xpToNext = XP_BASE * Math.pow(XP_SCALE, G.level - 1);
  }
  G.biomeTransition = 0;
  // Re-color existing orbs
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.popped && c.alive) {
      const clr = getClusterColor(c.x, c.y);
      c.color = clr.color;
      c.colorIdx = clr.colorIdx;
      c.colorEdge = c.color;
    }
  }
  // Show biome lore text
  const advPalette = getCurrentPalette();
  const advLoreArr = BIOME_LORE[advPalette.name] || [];
  const advLore = advLoreArr.length ? advLoreArr[Math.floor(Math.random() * advLoreArr.length)] : '';
  if (advLore) {
    const lx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const ly = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.3;
    setTimeout(() => spawnFloatingText(lx, ly, advLore, advPalette.accent, 3.5, { lore: true }), 800);
  }
}

// ==================================================
// SECTION 15: UI / HUD & FLOATING TEXT
// ==================================================
function spawnFloatingText(x, y, text, color, duration, opts) {
  if (G.floatingTexts.length >= MAX_FLOATING_TEXTS) G.floatingTexts.shift();
  const life = duration || 1.2; // 25% faster default (was 1.5)
  const ft = { x, y, text, color, life: life, maxLife: life, vy: -70 };
  if (opts) {
    if (opts.lore) { ft.lore = true; ft.vy = -25; } // lore texts drift slower
    if (opts.fontSize) ft.fontSize = opts.fontSize;
  }
  G.floatingTexts.push(ft);
}

function updateFloatingTexts(dt) {
  for (let i = G.floatingTexts.length - 1; i >= 0; i--) {
    const ft = G.floatingTexts[i];
    ft.y += ft.vy * dt;
    ft.life -= dt;
    if (ft.life <= 0) G.floatingTexts.splice(i, 1);
  }
}

// Enochian / occult glyphs — arcane symbols for text corruption
// Mix of Runic (Elder Futhark), Baybayin, Ethiopic, and other esoteric Unicode blocks
const ENOCHIAN_CHARS = 'ᚠᚢᚦᚨᚱᚲᚷᚹᚺᚻᚾᛁᛃᛇᛈᛉᛊᛏᛒᛖᛗᛚᛝᛞᛟᜀᜁᜂᜃᜄᜅᜆᜇᜈᜉᜊᜋᜌᜍᜎᜏ';

// Deterministic corruption: each character position has a fixed "corruption threshold"
// based on its position hash. When madness exceeds that threshold, it flips permanently.
// This creates the "one letter at a time" effect — no flickering, just steady creep.
function corruptText(text, madness) {
  if (madness <= 0) return text;
  let result = '';
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    // Preserve spacing/punctuation
    if (ch === ' ' || ch === ':' || ch === '—' || ch === '\n') {
      result += ch;
      continue;
    }
    // Each position has a deterministic threshold based on char code + position
    // Using a simple hash so the same text always corrupts the same way
    const hash = ((ch.charCodeAt(0) * 31 + i * 137 + text.length * 7) % 997) / 997;
    // The threshold determines when THIS specific letter corrupts
    // Letters with low hashes corrupt first (at low madness), high hashes last
    if (madness > hash) {
      // This letter is corrupted — pick a deterministic Enochian replacement
      const glyphIdx = (ch.charCodeAt(0) * 13 + i * 47) % ENOCHIAN_CHARS.length;
      result += ENOCHIAN_CHARS[glyphIdx];
    } else {
      result += ch;
    }
  }
  return result;
}

// Like corruptText but preserves digits, +, -, spaces, punctuation
function corruptTextPreserveNumbers(text, madness) {
  if (madness <= 0) return text;
  let result = '';
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (/[\d+\-\s:!.,]/.test(ch)) { result += ch; continue; }
    const hash = ((ch.charCodeAt(0) * 31 + i * 137 + text.length * 7) % 997) / 997;
    if (madness > hash) {
      const glyphIdx = (ch.charCodeAt(0) * 13 + i * 47) % ENOCHIAN_CHARS.length;
      result += ENOCHIAN_CHARS[glyphIdx];
    } else {
      result += ch;
    }
  }
  return result;
}

function updateHUD() {
  // Show mine charges remaining if mine layer is active
  const charges = G.upgrades.bombCharges;
  const minesLeft = charges > 0 ? charges - G.bombsPlacedThisRound : 0;
  const tapsDisplay = minesLeft > 0 ? `${G.taps} (${minesLeft}m)` : `${G.taps}`;

  const madness = getMadnessAmount();

  // Numbers always readable — only labels corrupt with madness
  const labelCorrupt = madness < 0.4 ? 0 : Math.min(1, (madness - 0.4) / 0.6);

  document.getElementById('hud-taps').textContent = tapsDisplay;
  document.getElementById('hud-level').textContent = `${G.level}`;
  document.getElementById('hud-score').textContent = `${G.score}`;

  // Chain count — show during active chain, linger 2s after
  const chainWrap = document.getElementById('hud-chain-wrap');
  if (chainWrap) {
    if (G.chainActive && G.chainCount > 1) {
      chainWrap.style.opacity = '1';
      document.getElementById('hud-chain').textContent = `${G.chainCount}`;
      G._chainDisplayTimer = 2.0; // linger after chain ends
    } else if (G._chainDisplayTimer > 0) {
      G._chainDisplayTimer -= G.dt || 0.016;
      chainWrap.style.opacity = String(Math.min(1, G._chainDisplayTimer / 0.5));
    } else {
      chainWrap.style.opacity = '0';
    }
  }

  // Corrupt labels at higher madness
  if (labelCorrupt > 0) {
    const hudEl = document.getElementById('hud');
    if (hudEl) {
      const labels = hudEl.querySelectorAll('div');
      const origLabels = ['Taps', 'Level', 'Score'];
      labels.forEach((el, idx) => {
        if (idx < origLabels.length) {
          const textNode = el.childNodes[0];
          if (textNode && textNode.nodeType === 3) {
            textNode.textContent = corruptText(origLabels[idx], labelCorrupt);
          }
        }
      });
    }
  }

  const pct = Math.min(100, (G.xp / G.xpToNext) * 100);
  document.getElementById('xp-bar-fill').style.width = pct + '%';
}

function showGameOver() {
  document.getElementById('hud').style.display = 'none';
  document.getElementById('xp-bar-wrap').style.display = 'none';
  document.getElementById('go-score').textContent = `Score: ${G.score}`;
  document.getElementById('go-level').textContent = `Level: ${G.level}`;
  document.getElementById('go-chain').textContent = `Best Chain: ${G.bestChain}`;
  document.getElementById('gameover-screen').style.display = 'flex';
}

// ==================================================
// SECTION 16: GAME LOOP & LIFECYCLE
// ==================================================
function update(dt) {
  // Cursor velocity — track mouse/touch speed for brush force
  if (G.cursorX > 0 && G.prevCursorX > 0) {
    G.cursorVx = (G.cursorX - G.prevCursorX) / Math.max(dt, 0.001);
    G.cursorVy = (G.cursorY - G.prevCursorY) / Math.max(dt, 0.001);
  } else {
    G.cursorVx = 0; G.cursorVy = 0;
  }
  G.prevCursorX = G.cursorX;
  G.prevCursorY = G.cursorY;

  // Biome transition
  if (G.biomeTransition < 1) {
    G.biomeTransition = Math.min(1, G.biomeTransition + dt * 0.5);
  }

  // Dev madness override affects zoom — full madness = fully zoomed out
  if (devMadnessOverride >= 0) {
    // Lerp zoom toward madness-scaled target: 0.5 at full madness
    G.zoomTarget = Math.max(0.5, 2.0 - devMadnessOverride * 1.5);
  }

  // Smooth zoom transition
  if (Math.abs(G.zoomLevel - G.zoomTarget) > 0.001) {
    G.zoomLevel = lerp(G.zoomLevel, G.zoomTarget, dt * 3.5);  // faster zoom lerp (was dt*2)
  }

  // Update visible game boundaries based on zoom (centered on screen)
  const halfW = G.W / (2 * G.zoomLevel);
  const halfH = G.H / (2 * G.zoomLevel);
  const cx = G.W / 2, cy = G.H / 2;
  G.gameLeft = cx - halfW;
  G.gameTop = cy - halfH;
  G.gameRight = cx + halfW;
  G.gameBottom = cy + halfH;
  G.gameW = G.gameRight - G.gameLeft;
  G.gameH = G.gameBottom - G.gameTop;

  if (G.state === 'title' || G.state === 'game_over') {
    updateParticles(dt);
    // Silence BPGE ambient when not playing
    if (G.bpgeAmbient) {
      const now = G.audioCtx.currentTime;
      G.bpgeAmbient.masterGain.gain.setTargetAtTime(0, now, 0.3);
      G.bpgeAmbient.lfoGain.gain.setTargetAtTime(0, now, 0.3);
    }
    return;
  }

  if (G.state !== 'playing') return;

  // MAIN BIOME: Whirlwind — periodic swirl toward center
  updateWhirlwind(dt);
  // ABYSS MECHANIC: Pressure Waves — periodic crushing force pushes orbs inward
  updateAbyssalPressure(dt);

  updateChainReaction(dt);
  updateCircles(dt);
  updateInterOrbGravity(dt);
  updateMarbleBounce(dt);
  updateColorSynthesis(dt);
  if (G.marbleMode <= 0) updateOrbMerging(dt); // no merging during marble mode
  updateMergeAnimations(dt);
  updateExplosions(dt);
  updateParticles(dt);
  updateAmbientParticles(dt);
  updateFieldStars(dt, G.W, G.H);
  updateVoidStars(dt, G.W, G.H);
  updateFloatingTexts(dt);
  updateAftershocks(dt);
  updateGravityWells(dt);
  updateBlackHole(dt);
  updateSuperBlackHole(dt);
  updateMiniBlackHoles(dt);
  updateBoss(dt);
  updateWatcher(dt);
  updateBombs(dt);
  updateShadowBalls(dt);
  updateRiftWalls(dt);
  updateBridges(dt);
  updateWormhole(dt);
  trySpawnWormhole();
  updateRefillQueue(dt);
  updateMassConservation(dt);
  updateBPGEAmbient();

  // 100 BPM beat pulse system — random orbs pulse on beat at 50%+ madness
  const beatMadness = getMadnessAmount();
  if (beatMadness >= 0.5) {
    const bpm120Period = 0.6; // 100 BPM = 0.6s per beat
    const prevPhase = G.beatPhase;
    G.beatPhase += dt / bpm120Period;
    // On each beat crossing (phase wraps past 1.0)
    if (Math.floor(G.beatPhase) > Math.floor(prevPhase)) {
      G.beatPhase -= Math.floor(G.beatPhase);
      // Select random 15-40% of living orbs to pulse
      G.beatPulseOrbs = [];
      const selectChance = 0.15 + Math.random() * 0.25;
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (!c.popped && c.alive && Math.random() < selectChance) {
          G.beatPulseOrbs.push(c.id);
        }
      }
    }
  } else {
    G.beatPhase = 0;
    G.beatPulseOrbs = [];
  }

  // === World Transparency Milestone Banners ===
  // Show dramatic text when crossing 50%, 75%, 90% WT thresholds
  const wtAmount = getMadnessAmount();
  const wtMilestones = [
    { pct: 50, threshold: 0.50, text: 'THE MEMBRANE THINS', subtext: '50% WORLD TRANSPARENCY', color: '#b060ff',
      lore: '\u201CThe Membrane does not separate. The Membrane is the act of two things disagreeing about whether they are one thing.\u201D \u2014ADAM-007' },
    { pct: 75, threshold: 0.75, text: 'REALITY UNRAVELS',   subtext: '75% WORLD TRANSPARENCY', color: '#ff5080',
      lore: '\u201CThe Membrane is a argument. You are a punctuation mark.\u201D \u2014HOLL-003' },
    { pct: 90, threshold: 0.90, text: 'THE OTHER SIDE BLEEDS THROUGH', subtext: '90% WORLD TRANSPARENCY', color: '#ff2020',
      lore: '\u201CAll instruments are functioning within normal parameters. The Membrane is stable. Nothing is wrong.\u201D \u2014ENUM-003' }
  ];
  for (const ms of wtMilestones) {
    if (wtAmount >= ms.threshold && !G.wtMilestones[ms.pct]) {
      G.wtMilestones[ms.pct] = true;
      G.wtBanner = { text: ms.text, subtext: ms.subtext, timer: 0, duration: 5.0, color: ms.color, lore: ms.lore || null };
      G.shakeAmount = Math.max(G.shakeAmount, ms.pct === 90 ? 8 : 4);
    }
  }
  // Update active banner timer
  if (G.wtBanner) {
    G.wtBanner.timer += dt;
    if (G.wtBanner.timer >= G.wtBanner.duration) G.wtBanner = null;
  }

  // Tap timer countdown (uses raw dt so slo-mo doesn't save you)
  // Infinite taps: keep taps topped up, skip timer decay
  if (infiniteTaps) {
    if (G.taps < 99) { G.taps = 99; updateHUD(); }
    G.tapTimer = G.tapTimerMax;
  } else if (G.taps > 0 && !G.pendingLevelUp && !G.chainActive) {
    G.tapTimer -= G.rawDt;
    if (G.tapTimer <= 0) {
      G.taps--;
      G.tapTimer = G.tapTimerMax;
      if (G.taps <= 0) {
        G.state = 'game_over';
        showGameOver();
      }
      updateHUD();
    }
  }

  // Decay effects
  if (G.shakeAmount > 0) G.shakeAmount = Math.max(0, G.shakeAmount - dt * 15);
  if (G.chromaticAb > 0) G.chromaticAb = Math.max(0, G.chromaticAb - dt * 8);
  if (G.whiteGlow > 0) G.whiteGlow = Math.max(0, G.whiteGlow - dt * 1.5);

  // Recover time scale
  if (G.timeScale < 1.0) {
    G.timeScale = Math.min(1.0, G.timeScale + G.rawDt * 0.3);
  }
}

function gameLoop(timestamp) {
  requestAnimationFrame(gameLoop);

  const rawDt = Math.min((timestamp - G.lastTime) / 1000, 0.05);
  G.lastTime = timestamp;
  G.rawDt = rawDt;
  G.dt = rawDt * G.timeScale;
  G.time += G.dt;

  update(G.dt);
  render();
}

// ==================================================
// ==================================================
// SECTION 16b: TESTLEVEL LIGHTING ENGINE
// — Point light at cursor, geometric circle shadows, dust layer
// — ONLY active when biomeOverride === 1 (TESTLEVEL)
// ==================================================
let _lightCanvas = null;
let _lightCtx = null;
let _dustCanvas = null;
let _dustCtx = null;
let _lightW = 0, _lightH = 0;

function initLightingEngine() {
  _lightCanvas = document.createElement('canvas');
  _lightCtx = _lightCanvas.getContext('2d');
  _dustCanvas = document.createElement('canvas');
  _dustCtx = _dustCanvas.getContext('2d');
}
initLightingEngine();

function rebuildDustLayer(w, h) {
  _dustCanvas.width = w;
  _dustCanvas.height = h;
  _dustCtx.clearRect(0, 0, w, h);
  const count = Math.floor(w * h / 350);
  for (let i = 0; i < count; i++) {
    const x = Math.random() * w;
    const y = Math.random() * h;
    const size = 0.4 + Math.random() * 1.2;
    const alpha = 0.04 + Math.random() * 0.08;
    _dustCtx.globalAlpha = alpha;
    _dustCtx.fillStyle = '#c8b0e0';
    _dustCtx.beginPath();
    _dustCtx.arc(x, y, size, 0, Math.PI * 2);
    _dustCtx.fill();
  }
  _dustCtx.globalAlpha = 1;
}

// --- LT Saturation helper: shift hex color saturation by amount (-1..+1) ---
function adjustSaturationHex(hex, shift) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  const l = (max + min) / 2;
  if (max === min) return hex; // achromatic — no saturation to shift
  let h, s;
  const d = max - min;
  s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
  if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
  else if (max === g) h = ((b - r) / d + 2) / 6;
  else h = ((r - g) / d + 4) / 6;
  // Shift saturation
  s = Math.max(0, Math.min(1, s + shift));
  // HSL → RGB
  if (s === 0) {
    const v = Math.round(l * 255);
    return '#' + ((1<<24)|(v<<16)|(v<<8)|v).toString(16).slice(1);
  }
  const hue2rgb = (p, q, t) => { if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p; };
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const nr = Math.round(hue2rgb(p, q, h + 1/3) * 255);
  const ng = Math.round(hue2rgb(p, q, h) * 255);
  const nb = Math.round(hue2rgb(p, q, h - 1/3) * 255);
  return '#' + ((1<<24)|(nr<<16)|(ng<<8)|nb).toString(16).slice(1);
}

function computeCircleShadow(lx, ly, cx, cy, cr, lightR) {
  const dx = cx - lx, dy = cy - ly;
  const d = Math.sqrt(dx * dx + dy * dy);
  if (d < cr * 1.1) return null;
  if (d > lightR * 1.5 + cr) return null;
  const alpha = Math.atan2(dy, dx);
  const theta = Math.asin(Math.min(1, cr / d));
  const dir1 = alpha + theta;
  const dir2 = alpha - theta;
  const t1x = cx + Math.cos(dir1 + Math.PI * 0.5) * cr;
  const t1y = cy + Math.sin(dir1 + Math.PI * 0.5) * cr;
  const t2x = cx + Math.cos(dir2 - Math.PI * 0.5) * cr;
  const t2y = cy + Math.sin(dir2 - Math.PI * 0.5) * cr;
  const farDist = lightR * 2.2;
  const f1x = lx + Math.cos(dir1) * farDist;
  const f1y = ly + Math.sin(dir1) * farDist;
  const f2x = lx + Math.cos(dir2) * farDist;
  const f2y = ly + Math.sin(dir2) * farDist;
  return { t1x, t1y, f1x, f1y, f2x, f2y, t2x, t2y };
}

// World → screen coordinate conversion (accounts for zoom)
function _w2s(wx, wy) {
  const cx = G.W / 2, cy = G.H / 2;
  return { x: cx + (wx - cx) * G.zoomLevel, y: cy + (wy - cy) * G.zoomLevel };
}

function renderTestLevelLighting(ctx, W, H) {
  if (G.biomeOverride !== 1) return;

  if (_lightW !== W || _lightH !== H) {
    _lightW = W; _lightH = H;
    _lightCanvas.width = W;
    _lightCanvas.height = H;
    rebuildDustLayer(W, H);
  }

  const zoom = G.zoomLevel || 1;
  const rawCX = G.cursorX, rawCY = G.cursorY;
  const hasCursor = rawCX > -500 && rawCY > -500;
  const sc = hasCursor ? _w2s(rawCX, rawCY) : { x: W / 2, y: H / 2 };
  const lx = sc.x, ly = sc.y;

  const lightR = 1400;            // very wide, huge feather radius
  // Cache light position for cross-function access (orb saturation in renderCircles)
  G._ltLx = lx; G._ltLy = ly; G._ltR = lightR;
  const darkAlpha = 0.08;         // whisper-thin darkness — just a hint darker than non-LT
  const flickerT = G.time || 0;
  const flicker = 1.0 + Math.sin(flickerT * 3.7) * 0.012 + Math.sin(flickerT * 7.1) * 0.006;
  const effectiveR = lightR * flicker;

  // --- Step 1: Fill with ambient darkness ---
  _lightCtx.clearRect(0, 0, W, H);
  _lightCtx.globalCompositeOperation = 'source-over';
  _lightCtx.fillStyle = `rgba(0,0,0,${darkAlpha})`;
  _lightCtx.fillRect(0, 0, W, H);

  // --- Step 2: Punch wide radial light cone at cursor ---
  if (hasCursor) {
    _lightCtx.globalCompositeOperation = 'destination-out';
    const grad = _lightCtx.createRadialGradient(lx, ly, 0, lx, ly, effectiveR);
    grad.addColorStop(0, 'rgba(255,255,255,0.35)');     // very subtle center
    grad.addColorStop(0.10, 'rgba(255,255,255,0.28)');  // gentle
    grad.addColorStop(0.25, 'rgba(255,255,255,0.18)');
    grad.addColorStop(0.45, 'rgba(255,255,255,0.08)');
    grad.addColorStop(0.65, 'rgba(255,255,255,0.03)');
    grad.addColorStop(0.85, 'rgba(255,255,255,0.005)');
    grad.addColorStop(1.0, 'rgba(255,255,255,0)');
    _lightCtx.fillStyle = grad;
    _lightCtx.beginPath();
    _lightCtx.arc(lx, ly, effectiveR, 0, Math.PI * 2);
    _lightCtx.fill();
  }

  // --- Step 3: Cast soft shadows from ORBS ONLY (shadow balls excluded) ---
  _lightCtx.globalCompositeOperation = 'source-over';
  const shadowAlpha = darkAlpha * 0.55;

  if (hasCursor) {
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (!c.alive || c.popped) continue;
      const cs = _w2s(c.x, c.y);
      const sr = c.radius * zoom;
      const shadow = computeCircleShadow(lx, ly, cs.x, cs.y, sr, effectiveR);
      if (!shadow) continue;
      // Multi-pass feathered shadow — 4 layers from soft outer to tight core
      const midX = (shadow.t1x + shadow.t2x + shadow.f1x + shadow.f2x) * 0.25;
      const midY = (shadow.t1y + shadow.t2y + shadow.f1y + shadow.f2y) * 0.25;
      const shadowPasses = [
        { expand: 1.18, alpha: shadowAlpha * 0.10 },  // outermost penumbra
        { expand: 1.12, alpha: shadowAlpha * 0.20 },  // soft edge
        { expand: 1.06, alpha: shadowAlpha * 0.40 },  // mid blur
        { expand: 1.0,  alpha: shadowAlpha * 0.75 },  // tight core
      ];
      for (const pass of shadowPasses) {
        _lightCtx.fillStyle = `rgba(0,0,0,${pass.alpha.toFixed(3)})`;
        _lightCtx.beginPath();
        _lightCtx.moveTo(midX + (shadow.t1x - midX) * pass.expand, midY + (shadow.t1y - midY) * pass.expand);
        _lightCtx.lineTo(midX + (shadow.f1x - midX) * pass.expand, midY + (shadow.f1y - midY) * pass.expand);
        _lightCtx.lineTo(midX + (shadow.f2x - midX) * pass.expand, midY + (shadow.f2y - midY) * pass.expand);
        _lightCtx.lineTo(midX + (shadow.t2x - midX) * pass.expand, midY + (shadow.t2y - midY) * pass.expand);
        _lightCtx.closePath();
        _lightCtx.fill();
      }
      // Orb body shadow — lit-side edge blur: gradient from dark backside to transparent lit side
      const orbDx = cs.x - lx, orbDy = cs.y - ly;
      const orbAngle = Math.atan2(orbDy, orbDx);
      // Shadow on the far side from light, with soft blurred edge toward light
      const shadowCx = cs.x + Math.cos(orbAngle) * sr * 0.15;
      const shadowCy = cs.y + Math.sin(orbAngle) * sr * 0.15;
      const orbShadGrad = _lightCtx.createRadialGradient(
        cs.x - Math.cos(orbAngle) * sr * 0.4,
        cs.y - Math.sin(orbAngle) * sr * 0.4,
        0, shadowCx, shadowCy, sr * 0.95
      );
      orbShadGrad.addColorStop(0, 'rgba(0,0,0,0)');
      orbShadGrad.addColorStop(0.3, 'rgba(0,0,0,0)');
      orbShadGrad.addColorStop(0.55, `rgba(0,0,0,${(shadowAlpha * 0.5).toFixed(3)})`);
      orbShadGrad.addColorStop(0.8, `rgba(0,0,0,${(shadowAlpha * 0.8).toFixed(3)})`);
      orbShadGrad.addColorStop(1, `rgba(0,0,0,${shadowAlpha.toFixed(3)})`);
      _lightCtx.fillStyle = orbShadGrad;
      _lightCtx.beginPath();
      _lightCtx.arc(cs.x, cs.y, sr * 0.92, 0, Math.PI * 2);
      _lightCtx.fill();
    }
    // NOTE: Shadow balls completely excluded — they don't interact with light
  }

  // --- Step 4: Orb self-glow (each orb emits faint light) ---
  _lightCtx.globalCompositeOperation = 'destination-out';
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    const cs = _w2s(c.x, c.y);
    const sr = c.radius * zoom;
    const glowR = sr * 4.0;
    const orbGlow = _lightCtx.createRadialGradient(cs.x, cs.y, 0, cs.x, cs.y, glowR);
    orbGlow.addColorStop(0, 'rgba(255,255,255,0.65)');
    orbGlow.addColorStop(0.3, 'rgba(255,255,255,0.30)');
    orbGlow.addColorStop(0.6, 'rgba(255,255,255,0.08)');
    orbGlow.addColorStop(1, 'rgba(255,255,255,0)');
    _lightCtx.fillStyle = orbGlow;
    _lightCtx.beginPath();
    _lightCtx.arc(cs.x, cs.y, glowR, 0, Math.PI * 2);
    _lightCtx.fill();
  }

  // --- Step 4b: ALL Black Hole variants — strong radiation glow ---
  // Mini black holes
  if (G.miniBlackHoles && G.miniBlackHoles.length > 0) {
    for (let mi = 0; mi < G.miniBlackHoles.length; mi++) {
      const mbh = G.miniBlackHoles[mi];
      const ms = _w2s(mbh.x, mbh.y);
      const lifeAlpha = Math.min(1, (mbh.life / (mbh.maxLife || mbh.life)) * 2);
      const glowRadius = mbh.gravityRadius * zoom * 2.0;
      const mbhGlow = _lightCtx.createRadialGradient(ms.x, ms.y, 0, ms.x, ms.y, glowRadius);
      mbhGlow.addColorStop(0, `rgba(255,255,255,${(0.95 * lifeAlpha).toFixed(2)})`);
      mbhGlow.addColorStop(0.1, `rgba(255,255,255,${(0.85 * lifeAlpha).toFixed(2)})`);
      mbhGlow.addColorStop(0.3, `rgba(255,255,255,${(0.45 * lifeAlpha).toFixed(2)})`);
      mbhGlow.addColorStop(0.6, `rgba(255,255,255,${(0.12 * lifeAlpha).toFixed(2)})`);
      mbhGlow.addColorStop(1, 'rgba(255,255,255,0)');
      _lightCtx.fillStyle = mbhGlow;
      _lightCtx.beginPath();
      _lightCtx.arc(ms.x, ms.y, glowRadius, 0, Math.PI * 2);
      _lightCtx.fill();
    }
  }
  // Regular black holes
  if (G.blackHoles && G.blackHoles.length > 0) {
    for (let bi = 0; bi < G.blackHoles.length; bi++) {
      const bh = G.blackHoles[bi];
      const bs = _w2s(bh.x, bh.y);
      const fadeIn = bh.fadeIn || 1;
      const fadeOut = bh.life < 2.0 ? bh.life / 2.0 : 1;
      const bhAlpha = fadeIn * fadeOut;
      const bhGlowR = (bh.gravityRadius || 120) * zoom * 1.8;
      const bhGlow = _lightCtx.createRadialGradient(bs.x, bs.y, 0, bs.x, bs.y, bhGlowR);
      bhGlow.addColorStop(0, `rgba(255,255,255,${(0.9 * bhAlpha).toFixed(2)})`);
      bhGlow.addColorStop(0.15, `rgba(255,255,255,${(0.7 * bhAlpha).toFixed(2)})`);
      bhGlow.addColorStop(0.4, `rgba(255,255,255,${(0.3 * bhAlpha).toFixed(2)})`);
      bhGlow.addColorStop(0.7, `rgba(255,255,255,${(0.08 * bhAlpha).toFixed(2)})`);
      bhGlow.addColorStop(1, 'rgba(255,255,255,0)');
      _lightCtx.fillStyle = bhGlow;
      _lightCtx.beginPath();
      _lightCtx.arc(bs.x, bs.y, bhGlowR, 0, Math.PI * 2);
      _lightCtx.fill();
    }
  }
  // Super black hole
  if (G.superBlackHole) {
    const sbh = G.superBlackHole;
    const ss = _w2s(sbh.x, sbh.y);
    const sbhGlowR = (sbh.eventHorizon || 80) * zoom * 3.0;
    const sbhGlow = _lightCtx.createRadialGradient(ss.x, ss.y, 0, ss.x, ss.y, sbhGlowR);
    sbhGlow.addColorStop(0, 'rgba(255,255,255,0.95)');
    sbhGlow.addColorStop(0.1, 'rgba(255,255,255,0.80)');
    sbhGlow.addColorStop(0.3, 'rgba(255,255,255,0.40)');
    sbhGlow.addColorStop(0.6, 'rgba(255,255,255,0.10)');
    sbhGlow.addColorStop(1, 'rgba(255,255,255,0)');
    _lightCtx.fillStyle = sbhGlow;
    _lightCtx.beginPath();
    _lightCtx.arc(ss.x, ss.y, sbhGlowR, 0, Math.PI * 2);
    _lightCtx.fill();
  }

  // --- Step 4c: Chain Link glow (WT >75%) ---
  if (getMadnessAmount() > 0.75 && G.chainLinks && G.chainLinks.length > 0) {
    for (let ci = 0; ci < G.chainLinks.length; ci++) {
      const link = G.chainLinks[ci];
      const target = findCircleById(link.targetId);
      if (!target || target.popped) continue;
      const srcS = _w2s(link.srcX, link.srcY);
      const tgtS = _w2s(target.x, target.y);
      const progress = Math.min(link.timer / link.duration, 1);
      // Glow at 5 points along the link line for continuous light
      for (let pi = 0; pi <= 4; pi++) {
        const t = pi / 4;
        const pt = { x: srcS.x + (tgtS.x - srcS.x) * t, y: srcS.y + (tgtS.y - srcS.y) * t };
        const linkR = 40 + progress * 30;
        const linkGlow = _lightCtx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, linkR);
        linkGlow.addColorStop(0, `rgba(255,255,255,${(0.35 * progress).toFixed(2)})`);
        linkGlow.addColorStop(0.5, `rgba(255,255,255,${(0.12 * progress).toFixed(2)})`);
        linkGlow.addColorStop(1, 'rgba(255,255,255,0)');
        _lightCtx.fillStyle = linkGlow;
        _lightCtx.beginPath();
        _lightCtx.arc(pt.x, pt.y, linkR, 0, Math.PI * 2);
        _lightCtx.fill();
      }
    }
  }

  // --- Step 4d: Explosion light bursts ---
  if (G.explosions && G.explosions.length > 0) {
    for (let ei = 0; ei < G.explosions.length; ei++) {
      const e = G.explosions[ei];
      if (e.life <= 0) continue;
      const es = _w2s(e.x, e.y);
      const eGlowR = e.radius * zoom * e.life * 2.0;
      if (eGlowR < 5) continue;
      const brightness = Math.min(1, (e.flashAlpha || 0) + e.life * 0.6);
      const eGlow = _lightCtx.createRadialGradient(es.x, es.y, 0, es.x, es.y, eGlowR);
      eGlow.addColorStop(0, `rgba(255,255,255,${(0.9 * brightness).toFixed(2)})`);
      eGlow.addColorStop(0.2, `rgba(255,255,255,${(0.6 * brightness).toFixed(2)})`);
      eGlow.addColorStop(0.5, `rgba(255,255,255,${(0.2 * brightness).toFixed(2)})`);
      eGlow.addColorStop(1, 'rgba(255,255,255,0)');
      _lightCtx.fillStyle = eGlow;
      _lightCtx.beginPath();
      _lightCtx.arc(es.x, es.y, eGlowR, 0, Math.PI * 2);
      _lightCtx.fill();
    }
  }

  // --- Step 5: Composite light map onto game (SCREEN SPACE) ---
  ctx.save();
  const dpr = G.dpr || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Dust layer
  ctx.globalAlpha = 0.35;
  ctx.drawImage(_dustCanvas, 0, 0);
  ctx.globalAlpha = 1;

  // Darkness overlay
  ctx.globalCompositeOperation = 'source-over';
  ctx.drawImage(_lightCanvas, 0, 0);

  // --- Step 6: Warm glow at cursor (bigger center radius) ---
  if (hasCursor) {
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.14;
    const glowR = effectiveR * 0.5; // bigger center glow (was 0.35)
    const glow = ctx.createRadialGradient(lx, ly, 0, lx, ly, glowR);
    glow.addColorStop(0, '#ffe8c0');
    glow.addColorStop(0.3, '#e0c080');
    glow.addColorStop(0.7, '#c8a060');
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(lx, ly, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Purple rim
    ctx.globalAlpha = 0.05;
    const rim = ctx.createRadialGradient(lx, ly, effectiveR * 0.4, lx, ly, effectiveR * 0.95);
    rim.addColorStop(0, 'transparent');
    rim.addColorStop(0.5, '#a060ff');
    rim.addColorStop(1, 'transparent');
    ctx.fillStyle = rim;
    ctx.beginPath();
    ctx.arc(lx, ly, effectiveR * 0.95, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Step 6b: Black Hole colored glow overlays (screen blend) ---
  ctx.globalCompositeOperation = 'screen';
  // Mini BH: cyan
  if (G.miniBlackHoles && G.miniBlackHoles.length > 0) {
    for (let mi = 0; mi < G.miniBlackHoles.length; mi++) {
      const mbh = G.miniBlackHoles[mi];
      const ms = _w2s(mbh.x, mbh.y);
      const lifeAlpha = Math.min(1, (mbh.life / (mbh.maxLife || mbh.life)) * 2);
      ctx.globalAlpha = 0.25 * lifeAlpha;
      const cGlowR = mbh.gravityRadius * zoom * 0.8;
      const cGlow = ctx.createRadialGradient(ms.x, ms.y, 0, ms.x, ms.y, cGlowR);
      cGlow.addColorStop(0, '#ffffff');
      cGlow.addColorStop(0.2, '#a0f0ff');
      cGlow.addColorStop(0.5, '#60e0ff');
      cGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = cGlow;
      ctx.beginPath();
      ctx.arc(ms.x, ms.y, cGlowR, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // Regular BH: purple/violet
  if (G.blackHoles && G.blackHoles.length > 0) {
    for (let bi = 0; bi < G.blackHoles.length; bi++) {
      const bh = G.blackHoles[bi];
      const bs = _w2s(bh.x, bh.y);
      const fadeIn = bh.fadeIn || 1;
      const fadeOut = bh.life < 2.0 ? bh.life / 2.0 : 1;
      ctx.globalAlpha = 0.2 * fadeIn * fadeOut;
      const cR = (bh.gravityRadius || 120) * zoom * 0.6;
      const cGlow = ctx.createRadialGradient(bs.x, bs.y, 0, bs.x, bs.y, cR);
      cGlow.addColorStop(0, '#e0c0ff');
      cGlow.addColorStop(0.3, '#a060ff');
      cGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = cGlow;
      ctx.beginPath();
      ctx.arc(bs.x, bs.y, cR, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // Super BH: bright white/blue
  if (G.superBlackHole) {
    const sbh = G.superBlackHole;
    const ss = _w2s(sbh.x, sbh.y);
    ctx.globalAlpha = 0.3;
    const sGR = (sbh.eventHorizon || 80) * zoom * 1.5;
    const sGlow = ctx.createRadialGradient(ss.x, ss.y, 0, ss.x, ss.y, sGR);
    sGlow.addColorStop(0, '#ffffff');
    sGlow.addColorStop(0.15, '#c0e0ff');
    sGlow.addColorStop(0.4, '#6080ff');
    sGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = sGlow;
    ctx.beginPath();
    ctx.arc(ss.x, ss.y, sGR, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// SECTION 17: INITIALIZATION & BOOT
// ==================================================
function resizeCanvas() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  G.dpr = dpr;
  G.W = window.innerWidth;
  G.H = window.innerHeight;
  G.canvas.width = G.W * dpr;
  G.canvas.height = G.H * dpr;
  G.canvas.style.width = G.W + 'px';
  G.canvas.style.height = G.H + 'px';
  G.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  createScanlinePattern();
}

// ==================================================
// LORE SPLASH + INSTRUCTIONS — sequential screens before title
// ==================================================
const LORE_SPLASHES = [
  { text: 'One to empty. One to fill. One to mean.',
    source: 'Adamical Grid, Cell 11-Null' },
  { text: 'The Membrane does not separate. The Membrane is the act of two things disagreeing about whether they are one thing.',
    source: 'Adamical Grid, Cell 1-1-0' },
  { text: 'There were three grips and the space between them, and the space was everything.',
    source: 'Adamical Grid, Preamble' },
  { text: 'Before the Membrane there was the Asking, and before the Asking there was the silence that did not know it was silent.',
    source: 'Adamical Grid, Cell 0-0-1' },
  { text: 'The contradiction is not a flaw. The contradiction is the architecture.',
    source: 'Adamical Grid, Cell 7-7-7' },
  { text: 'Where meaning touches, sight remains.',
    source: 'Adamical Grid, Cell 11-Null' },
  { text: 'What is resolved does not vanish. It becomes what it was trying to say.',
    source: 'Adamical Grid, Cell 3-0-9' },
  { text: 'Three grips in the sand. One wet. One charred. One that is not there but the sand is shaped around it.',
    source: 'Adamical Grid, Cell 9-Null' },
  { text: 'Something made the Membrane. Something stood in the empty place and decided that two things that could not both be true would both be true, and the disagreement between them would be a world. We found its fingerprints. There were three sets.',
    source: 'Fragment Analysis Division' },
  { text: 'The Membrane is an argument. You are a punctuation mark. Try to be a question mark rather than a period.',
    source: 'Hollowmath Collective' },
  { text: 'We are what happens when mathematics is wrong but refuses to stop working.',
    source: 'Hollowmath Kel-Nought' },
  { text: 'The first grip was wet. It held nothing and the nothing stayed held.',
    source: 'Adamical Grid, Cell 0-0-0' },
  { text: 'The second grip burned. It held everything and everything screamed to be held.',
    source: 'Adamical Grid, Cell 0-0-1' },
  { text: 'The third grip is not a grip. It is a choice made with fingers that are not there, shaping material that does not resist, into forms that did not exist until the shaping decided they should.',
    source: 'Adamical Grid, Cell 0-0-2' },
  { text: 'Where all three grips are equal, nothing holds. Where nothing holds, everything flickers. Where everything flickers, the wrong ones build.',
    source: 'Adamical Grid, Cell 12-0-0' },
  { text: 'The third hand opens. What it held becomes what it gave.',
    source: 'Adamical Grid, Cell 15-0-0' },
];

let splashPhase = 'lore'; // 'lore' → 'changelog' → 'instructions' → 'done'
let splashAutoTimer = null;

// --- CHANGELOG DATA — prioritized (biggest changes first) ---
const CHANGELOG = [
  { title: 'Vector Eye Overhaul', items: [
    'Orb eyes now use 4 desaturated vector variants matching the Nexus boss',
    'V0 Pale, V1 Striated, V2 Slit pupil, V3 Cracked iris — each orb gets one',
    'Removed hard outlines — eyes blend organically into orb surfaces',
    'Extra sprouting eyes (85%+ WT) also use the 4-variant system',
  ]},
  { title: 'Rebalanced Progression', items: [
    'Game length doubled — madness builds over ~12 minutes instead of ~6',
    'Score thresholds widened: 150k–1.4M (was 100k–900k)',
    'Horror from black holes capped lower — score matters more now',
    'XP curve steepened — levels feel earned, not automatic',
  ]},
  { title: 'Tighter Tap Economy', items: [
    'Start with 8 taps (was 10) — every tap counts',
    'Chain thresholds raised — need bigger combos for bonus taps',
    'Level-up gives +1 tap (was +2)',
    'Tap decay timer shortened to 10s (was 12s)',
  ]},
  { title: 'Chain Reaction Tuning', items: [
    'Blast radius reduced (50–115px, was 55–130px)',
    'Fractures delayed by 1 level — start at L5 instead of L4',
    'Cascade burst thresholds raised — need longer chains to trigger',
    'Echo burst chance: 8% per level (was 10%)',
  ]},
  { title: 'Shadow Balls', items: [
    'Dark phantom orbs appear at 70%+ madness',
    'Non-interactive — they drift behind normal orbs like ghosts',
    'Follow gravity chaotically — pulled by cursor, whirlwinds, pressure',
    'Feed black holes — fractional mass based on size (17-50% per ball)',
  ]},
  { title: 'Supermassive Black Hole', items: [
    'Fully loaded SBH triggers a SUPERNOVA when collapsed',
    'Supernova covers 45%+ of the play area — screen-filling devastation',
    'Spawns less frequently now (30–50s, was 20–35s)',
  ]},
  { title: 'Abyss Biome', items: [
    'Black holes rendered as spinning ocean whirlpools in Abyss',
    'Supermassive black holes become deep maelstroms',
    'Biome gravity effects 50% longer, scale 1.25–3× with madness',
  ]},
  { title: 'Cursor & Physics', items: [
    'Cursor pull radius vastly expanded (4–10× reach scaling with madness)',
    'Orb field density softer — peaks at 2.5× (was 3.5×) at max madness',
    'Bigger orbs from 50%+ madness, giant merged orbs scale with madness',
  ]},
];

function buildChangelogModal() {
  const modal = document.getElementById('changelog-modal');
  const continueWrap = document.getElementById('changelog-continue');
  if (!modal) return;

  // --- Left column: What's New (changelog) ---
  let clHtml = '<div id="changelog-title">What\'s New</div>';
  for (let s = 0; s < CHANGELOG.length; s++) {
    const sec = CHANGELOG[s];
    clHtml += '<div class="cl-section">';
    clHtml += `<div class="cl-section-title">${sec.title}</div>`;
    for (let i = 0; i < sec.items.length; i++) {
      clHtml += `<div class="cl-item">${sec.items[i]}</div>`;
    }
    clHtml += '</div>';
  }

  // --- Right column: Coming Next (roadmap) ---
  const ROADMAP = [
    { title: 'Biome 1', items: [
      'Boss mechanics overhaul',
      'Possible lighting effects',
      'Ambient music',
      'Shitloads of gameplay balancing',
      'New random ideas',
      'Biome ending wormhole'
    ]},
    { title: 'All / Generic', items: [
      'GFX, fonts, UIs, etc etc etc',
      'New Biome',
      'Lore madness',
      'New gameplay features'
    ]}
  ];
  let rmHtml = '<div id="roadmap-title">Coming Next</div>';
  for (let s = 0; s < ROADMAP.length; s++) {
    const sec = ROADMAP[s];
    rmHtml += '<div class="rm-section">';
    rmHtml += `<div class="rm-section-title">${sec.title}</div>`;
    for (let i = 0; i < sec.items.length; i++) {
      rmHtml += `<div class="rm-item">${sec.items[i]}</div>`;
    }
    rmHtml += '</div>';
  }

  // --- Two-column layout ---
  let html = '<div id="changelog-columns">';
  html += '<div id="changelog-inner">' + clHtml + '</div>';
  html += '<div id="roadmap-inner">' + rmHtml + '</div>';
  html += '</div>';
  modal.innerHTML = html;

  // Continue button handler — only this button advances, NOT background clicks
  const btn = document.getElementById('changelog-btn');
  if (btn) {
    btn.addEventListener('click', (e) => { e.stopPropagation(); advanceSplash(); });
    btn.addEventListener('touchend', (e) => { e.stopPropagation(); e.preventDefault(); advanceSplash(); });
  }
}

function initSplashSequence() {
  // --- LORE SPLASH ---
  const loreEl = document.getElementById('lore-text');
  const splashEl = document.getElementById('lore-splash');
  if (!loreEl || !splashEl) { splashPhase = 'done'; return; }

  const lore = LORE_SPLASHES[Math.floor(Math.random() * LORE_SPLASHES.length)];
  // Split text into sentences for row-by-row reveal
  const sentences = lore.text.match(/[^.!?]+[.!?]+/g) || [lore.text];
  loreEl.innerHTML = sentences.map((s, i) =>
    `<span class="lore-line" style="animation-delay:${1 + i * 1.2}s">${s.trim()}</span>`
  ).join('');
  const attrEl = document.querySelector('#lore-splash .lore-attribution');
  if (attrEl) {
    attrEl.textContent = '\u2014 ' + lore.source;
    // Delay attribution until after all lines have appeared
    attrEl.style.transitionDelay = (1 + sentences.length * 1.2 + 1) + 's';
  }

  // Fade in over 3s (triggered by adding .visible class after a frame)
  requestAnimationFrame(() => {
    splashEl.classList.add('visible');
  });

  // Auto-advance: wait for all lines to appear + 4s reading time (user can tap anytime to skip)
  const totalRevealTime = (1 + sentences.length * 1.2 + 2) * 1000; // lines + attribution fade
  const autoAdvanceMs = Math.min(totalRevealTime + 4000, 13000); // cap at 13s total
  splashAutoTimer = setTimeout(() => { if (splashPhase === 'lore') advanceSplash(); }, autoAdvanceMs);

  // --- BUILD CHANGELOG MODAL (hidden until needed) ---
  buildChangelogModal();

  // --- INSTRUCTIONS SCREEN (created but hidden) ---
  const instrStyle = document.createElement('style');
  instrStyle.textContent = `
    #instructions-splash { position:fixed;top:0;left:0;right:0;bottom:0;z-index:45;background:rgba(0,0,0,0.7);display:flex;flex-direction:column;align-items:center;justify-content:center;opacity:0;pointer-events:all;cursor:pointer;transition:opacity 1s ease-in; }
    #instructions-splash.visible { opacity:1; }
    #instructions-splash.fade-out { opacity:0; transition:opacity 1s ease-out; }
    .instr-row { display:flex; align-items:flex-start; gap:14px; margin-bottom:20px; font-family:'Orbitron','Courier New',monospace; font-size:16px; line-height:1.7; color:rgba(255,255,255,0.9); letter-spacing:1px; opacity:0; }
    #instructions-splash.visible .instr-row { animation: lore-fade-in 0.8s ease-out forwards; }
    #instructions-splash.visible .instr-row:nth-child(1) { animation-delay: 0.3s; }
    #instructions-splash.visible .instr-row:nth-child(2) { animation-delay: 0.7s; }
    #instructions-splash.visible .instr-row:nth-child(3) { animation-delay: 1.1s; }
    #instructions-splash.visible .instr-row:nth-child(4) { animation-delay: 1.5s; }
    .instr-icon { font-size:23px; color:rgba(180,80,255,0.85); flex-shrink:0; margin-top:1px; }
    .instr-continue { position:absolute; bottom:32px; font-family:'Orbitron','Courier New',monospace; font-size:13px; letter-spacing:3px; text-transform:uppercase; color:rgba(255,255,255,0.45); opacity:0; transition:opacity 1.5s ease-out 2.5s; }
    #instructions-splash.visible .instr-continue { opacity:1; }
  `;
  document.head.appendChild(instrStyle);

  const instrEl = document.createElement('div');
  instrEl.id = 'instructions-splash';
  instrEl.innerHTML = `
    <div style="font-family:'Orbitron','Courier New',monospace;font-size:23px;letter-spacing:6px;text-transform:uppercase;color:rgba(255,255,255,0.95);margin-bottom:28px;">How to Play</div>
    <div style="max-width:520px;padding:0 24px;">
      <div class="instr-row"><span class="instr-icon">&#9673;</span><span>Tap orbs to pop them. Each pop tears the membrane — nearby orbs chain-react.</span></div>
      <div class="instr-row"><span class="instr-icon">&#9733;</span><span>Longer chains earn more taps. Spend taps wisely — they are finite.</span></div>
      <div class="instr-row"><span class="instr-icon">&#9679;</span><span>Move the cursor to draw orbs toward you. Herd them. Shape the field.</span></div>
      <div class="instr-row"><span class="instr-icon">&#9670;</span><span>Long press to place sigils. Level up to awaken new powers.</span></div>
    </div>
    <div class="instr-continue">click to continue</div>
  `;
  instrEl.addEventListener('click', (e) => { e.stopPropagation(); advanceSplash(); });
  instrEl.addEventListener('touchend', (e) => { e.stopPropagation(); e.preventDefault(); advanceSplash(); });
  document.body.appendChild(instrEl);

  // Global listeners for click/key to advance (skips lore, NOT changelog — changelog needs button)
  const splashAdvance = (e) => {
    // Don't intercept dev button clicks
    if (e.target && (e.target.id === 'biome-btn' || e.target.id === 'madness-btn' || e.target.id === 'autolvl-btn')) return;
    // Changelog requires the Continue button — don't skip on random clicks
    if (splashPhase === 'changelog') return;
    advanceSplash();
  };
  document.addEventListener('keydown', splashAdvance, { once: false });
  document.addEventListener('click', splashAdvance, { once: false });
  document.addEventListener('touchend', splashAdvance, { once: false });

  // Store cleanup ref
  window._splashCleanup = () => {
    document.removeEventListener('keydown', splashAdvance);
    document.removeEventListener('click', splashAdvance);
    document.removeEventListener('touchend', splashAdvance);
  };
}

function advanceSplash() {
  if (splashPhase === 'lore') {
    // Transition: lore → changelog
    splashPhase = 'changelog';
    if (splashAutoTimer) { clearTimeout(splashAutoTimer); splashAutoTimer = null; }

    const splashEl = document.getElementById('lore-splash');
    const clModal = document.getElementById('changelog-modal');
    const clContinue = document.getElementById('changelog-continue');

    // Fade out lore
    splashEl.classList.remove('visible');
    splashEl.classList.add('fade-out');
    setTimeout(() => { splashEl.style.display = 'none'; }, 1600);

    // Fade in changelog after lore starts fading
    setTimeout(() => {
      if (clModal) {
        clModal.style.display = 'flex';
        // Short timeout to ensure display change is committed before triggering opacity transition
        setTimeout(() => {
          clModal.classList.add('visible');
          // Belt-and-suspenders: force opacity if CSS transition doesn't fire
          setTimeout(() => {
            if (clModal && getComputedStyle(clModal).opacity < 0.5) {
              clModal.style.opacity = '1';
            }
          }, 900);
        }, 50);
      }
      if (clContinue) clContinue.classList.add('visible');
    }, 800);

  } else if (splashPhase === 'changelog') {
    // Transition: changelog → instructions (modal over live game field)
    splashPhase = 'instructions';

    const clModal = document.getElementById('changelog-modal');
    const clContinue = document.getElementById('changelog-continue');
    const instrEl = document.getElementById('instructions-splash');

    // Fade out changelog
    if (clModal) {
      clModal.classList.remove('visible');
      clModal.classList.add('fade-out');
      setTimeout(() => { clModal.style.display = 'none'; }, 700);
    }
    if (clContinue) {
      clContinue.classList.remove('visible');
      setTimeout(() => { clContinue.style.display = 'none'; }, 700);
    }

    // Spawn circles NOW — they'll be visible behind the instructions overlay
    spawnInitialCircles();

    // Fade in instructions as translucent modal over the balls
    setTimeout(() => {
      if (instrEl) instrEl.classList.add('visible');
    }, 500);

  } else if (splashPhase === 'instructions') {
    // Transition: instructions → start game directly (skip title screen)
    splashPhase = 'done';

    const instrEl = document.getElementById('instructions-splash');
    if (instrEl) {
      instrEl.classList.remove('visible');
      instrEl.classList.add('fade-out');
      setTimeout(() => { instrEl.style.display = 'none'; }, 1100);
    }

    // Cleanup global listeners
    if (window._splashCleanup) { window._splashCleanup(); window._splashCleanup = null; }

    // Start the game after instructions fade
    setTimeout(() => {
      // Safety net: force-hide ALL splash overlays to prevent blocking
      ['lore-splash', 'changelog-modal', 'changelog-continue', 'instructions-splash'].forEach(id => {
        const el = document.getElementById(id);
        if (el) { el.style.display = 'none'; el.style.opacity = '0'; el.style.pointerEvents = 'none'; }
      });
      initAudio();
      resetGame();
    }, 600);

  }
  // 'done' — do nothing, game is running
}

function init() {
  G.canvas = document.getElementById('c');
  G.ctx = G.canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  setupInput();

  // Show lore → instructions → title sequence
  initSplashSequence();

  // Circles are spawned AFTER changelog ends (see advanceSplash changelog→instructions)
  // Do NOT spawn here — splash screens should show on clean black background

  G.lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
