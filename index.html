<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>POP FIELD</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; user-select: none; -webkit-user-select: none; }
canvas { display: block; width: 100%; height: 100%; }
#hud { position: fixed; top: 0; left: 0; right: 0; padding: 12px 16px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 10; font-family: 'Orbitron', 'Courier New', monospace; }
#hud > div { text-transform: uppercase; letter-spacing: 3px; font-size: 16px; color: rgba(255,255,255,0.85); text-shadow: 0 0 8px rgba(0,200,255,0.5); }
#hud .val { font-size: 24px; font-weight: bold; letter-spacing: 1px; }
#xp-bar-wrap { position: fixed; bottom: 0; left: 0; right: 0; height: 8px; background: rgba(255,255,255,0.06); z-index: 10; pointer-events: none; display: none; }
#xp-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #b24dff, #ff3c8e, #ffd84d); transition: width 0.3s ease-out; }
#title-screen, #gameover-screen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; pointer-events: none; font-family: 'Orbitron', 'Courier New', monospace; text-transform: uppercase; }
#title-screen h1 { font-size: 64px; letter-spacing: 16px; color: #fff; text-shadow: 0 0 30px rgba(0,200,255,0.8), 0 0 60px rgba(0,200,255,0.4); margin-bottom: 8px; }
#title-screen .sub { font-size: 18px; letter-spacing: 6px; color: rgba(255,255,255,0.5); margin-bottom: 24px; }
#title-screen .splash-info { max-width: 400px; text-align: center; margin-bottom: 24px; }
#title-screen .splash-item { margin-bottom: 14px; }
#title-screen .splash-label { font-size: 14px; letter-spacing: 3px; color: rgba(180,80,255,0.9); margin-bottom: 3px; }
#title-screen .splash-desc { font-size: 13px; letter-spacing: 1px; color: rgba(255,255,255,0.55); text-transform: none; line-height: 1.6; }
#title-screen .tap-start { font-size: 20px; letter-spacing: 8px; color: rgba(255,255,255,0.7); animation: pulse-text 2s ease-in-out infinite; }
#gameover-screen h1 { font-size: 48px; letter-spacing: 12px; color: #ff4060; text-shadow: 0 0 30px rgba(255,64,96,0.8); margin-bottom: 16px; }
#gameover-screen .score-display { font-size: 26px; letter-spacing: 4px; color: rgba(255,255,255,0.8); margin-bottom: 8px; }
#gameover-screen .tap-start { font-size: 18px; letter-spacing: 6px; color: rgba(255,255,255,0.5); margin-top: 30px; animation: pulse-text 2s ease-in-out infinite; }
@keyframes pulse-text { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
#upgrade-panel { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 30; background: rgba(0,0,0,0.75); font-family: 'Orbitron', 'Courier New', monospace; text-transform: uppercase; pointer-events: all; }
#upgrade-panel h2 { font-size: 36px; letter-spacing: 12px; color: #ffffff; text-shadow: none; margin-bottom: 30px; }
#upgrade-choices { display: flex; flex-direction: column; gap: 18px; width: 90%; max-width: 420px; }
.upgrade-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 20px 22px; cursor: pointer; transition: background 0.15s, border-color 0.15s; }
.upgrade-card:active { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.5); }
.upgrade-card .name { font-size: 20px; letter-spacing: 3px; color: rgba(255,255,255,0.95); margin-bottom: 4px; }
.upgrade-card .level { font-size: 13px; letter-spacing: 2px; color: rgba(255,255,255,0.4); margin-bottom: 6px; }
.upgrade-card .desc { font-size: 15px; letter-spacing: 1px; color: rgba(255,255,255,0.7); text-transform: none; line-height: 1.4; }
#biome-btn { position: fixed; top: 56px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#biome-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#biome-btn.active { border-color: rgba(0,229,255,0.5); color: #00e5ff; text-shadow: 0 0 8px rgba(0,229,255,0.4); }
#madness-btn { position: fixed; top: 88px; right: 16px; z-index: 15; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 6px 12px; color: rgba(255,255,255,0.6); font-family: 'Orbitron', 'Courier New', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; pointer-events: all; transition: background 0.15s, border-color 0.15s, color 0.15s; }
#madness-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.9); }
#madness-btn.active { border-color: rgba(255,50,80,0.7); color: #ff3050; text-shadow: 0 0 8px rgba(255,50,80,0.5); }
</style>
</head>
<body>

<canvas id="c"></canvas>
<button id="biome-btn" title="Toggle biome [B]">Abyss</button>
<button id="madness-btn" title="Toggle full madness [M]">Madness</button>

<div id="xp-bar-wrap"><div id="xp-bar-fill"></div></div>
<div id="hud" style="display:none;">
  <div>Taps<br><span class="val" id="hud-taps">3</span></div>
  <div style="text-align:center;">Level<br><span class="val" id="hud-level">1</span></div>
  <div style="text-align:right;">Score<br><span class="val" id="hud-score">0</span></div>
</div>

<div id="title-screen">
  <h1>POP FIELD</h1>
  <div class="sub">Chain Reaction</div>
  <div class="splash-info">
    <div class="splash-item">
      <div class="splash-label">&#9673; Archons</div>
      <div class="splash-desc">Orbs ascend into Archon forms at level 5+. Pop them during chains for massive gravity-pull combos.</div>
    </div>
    <div class="splash-item">
      <div class="splash-label">&#9679; Black Holes</div>
      <div class="splash-desc">Voids open and swallow nearby orbs. Feed them mass, then tap to collapse for bonus taps and a powerful blast.</div>
    </div>
    <div class="splash-item">
      <div class="splash-label">&#9670; Void Cracks</div>
      <div class="splash-desc">Rare armored orbs with purple energy. First hit cracks them (pulls orbs in), second hit shatters (pushes orbs out).</div>
    </div>
    <div class="splash-item">
      <div class="splash-desc" style="color: rgba(255,255,255,0.35); font-style: italic; margin-top: 8px;">Something watches from beyond the membrane. As the field destabilizes, the boundary thins. You will feel their gaze before you see them.</div>
    </div>
  </div>
  <div class="tap-start">Tap to Start</div>
</div>

<div id="gameover-screen" style="display:none;">
  <h1>Game Over</h1>
  <div class="score-display" id="go-score">Score: 0</div>
  <div class="score-display" id="go-level">Level: 1</div>
  <div class="score-display" id="go-chain">Best Chain: 0</div>
  <div class="tap-start">Tap to Restart</div>
</div>

<div id="upgrade-panel">
  <h2>Level Up</h2>
  <div id="upgrade-choices"></div>
</div>

<script>
// ==================================================
// SECTION 1: CONSTANTS & CONFIGURATION
// ==================================================
const BASE_TAPS = 8;                    // generous starting taps
const BASE_CIRCLE_COUNT = 45;          // denser field = better chains early
const BASE_CIRCLE_RADIUS = 18;
const BASE_BLAST_RADIUS = 100;         // bigger base blast — reliable chains
const MAX_BLAST_RADIUS = 150;          // cap for late-game blast growth
const MAX_TAP_DISTANCE = 80;
const MAX_CIRCLES = 300;
const MAX_PARTICLES = 800;
const MAX_EXPLOSIONS = 40;
const MAX_FLOATING_TEXTS = 15;
const MAX_PAINT_SPLATS = 200;
const MAX_AFTERSHOCKS = 20;
const XP_BASE = 15;                     // level 2 after ~3-4 decent chains
const XP_SCALE = 1.7;                   // steeper curve: 15→26→44→74→126...
const INTER_ORB_GRAVITY = 15;            // gentle pull from bigger → smaller orbs
const CHAIN_POP_DELAY_MIN = 0.015;
const CHAIN_POP_DELAY_MAX = 0.045;
const CHAIN_POP_DELAY_JITTER = 0.015;
const LINK_TENSION_TIME_BASE = 0.18;
// Chain animation 25% faster for small/mid combos, normal speed for biggest (40+)
function getLinkTensionTime() {
  if (G.chainCount >= 40) return LINK_TENSION_TIME_BASE; // biggest combos keep original speed
  return LINK_TENSION_TIME_BASE * 0.75; // 25% faster
}
const LINK_PULL_STRENGTH = 120;
const SC_SPAWN_CHANCE = 0.09;
const SC_RADIUS_MULT = 1.6;
const SC_SPIKE_MIN = 5;
const SC_SPIKE_MAX = 8;
const SC_GRAVITY_LIFE = 0.4;
const SC_GRAVITY_STRENGTH = 200;
const DELAYED_BLAST_MINOR = 15;        // harder to trigger
const DELAYED_BLAST_MAJOR = 25;        // megacombo rarer
const DELAYED_BLAST_MEGA = 45;         // true megacombo is special
const TAP_TIMER_BASE = 12;             // +20% more time between tap decay
const BOMB_FUSE_TIME = 3.5;
const BOMB_BLAST_MULT = 1.4;

// ==================================================
// SECTION 2: PALETTE DEFINITIONS
// ==================================================
// Three main colors per palette: violet, pink, yellow — shifting per level
const PALETTES = [
  { // Level 1-3: Deep violet + hot pink + warm gold
    name: 'PHASE I',
    bgTop: '#0d0018', bgBot: '#1a0028',
    colors: ['#b24dff', '#ff3c8e', '#ffd84d'],
    accent: '#e040fb',
    baseNote: 240,
    oscType: 'sine'
  },
  { // Level 4-6: Richer, more saturated
    name: 'PHASE II',
    bgTop: '#120020', bgBot: '#200035',
    colors: ['#9c27b0', '#ff1a6e', '#ffe066'],
    accent: '#ea80fc',
    baseNote: 262,
    oscType: 'sine'
  },
  { // Level 7-9: Deeper, neon edges
    name: 'PHASE III',
    bgTop: '#0a0014', bgBot: '#1a0030',
    colors: ['#7c4dff', '#ff4081', '#ffca28'],
    accent: '#d500f9',
    baseNote: 294,
    oscType: 'sawtooth'
  },
  { // Level 10-12: High contrast, electric
    name: 'PHASE IV',
    bgTop: '#06000f', bgBot: '#14002a',
    colors: ['#651fff', '#f50057', '#ffc400'],
    accent: '#aa00ff',
    baseNote: 330,
    oscType: 'sawtooth'
  },
  { // Level 13+: Ultra vivid, white-hot accents
    name: 'PHASE V',
    bgTop: '#04000a', bgBot: '#10001e',
    colors: ['#d050ff', '#ff2070', '#ffe180'],
    accent: '#e040fb',
    baseNote: 349,
    oscType: 'sine'
  }
];
const PALETTE_LEVELS = 3; // levels per palette

// Special biomes — toggled manually, override the level-based palette
const SPECIAL_BIOMES = [
  { // ABYSS — deep ocean trench, bioluminescent
    name: 'ABYSS',
    bgTop: '#000a12', bgBot: '#001018',
    colors: ['#00e5ff', '#00bfa5', '#76ff03'],
    accent: '#18ffff',
    baseNote: 180,
    oscType: 'triangle'
  }
];

// Biome lore intro texts — shown on biome transitions
const BIOME_LORE = {
  'PHASE I': [
    'The field awakens. Orbs drift in primordial silence.',
    'Matter condenses from nothing. The first whispers of form.',
    'A membrane between worlds stretches thin. Light seeps through.'
  ],
  'PHASE II': [
    'Warmth bleeds through. The orbs grow restless.',
    'The field remembers motion. Patterns emerge from chaos.',
    'Energy pools in the spaces between. Something stirs.'
  ],
  'PHASE III': [
    'Fractures spread. Something watches from the edges.',
    'The orbs pulse with stolen light. Gravity bends wrong.',
    'Archons form unbidden. The field is no longer yours alone.'
  ],
  'PHASE IV': [
    'The field hungers. The Watchers press closer.',
    'Chains echo longer than they should. Time thickens.',
    'The void between orbs is not empty. It breathes.'
  ],
  'PHASE V': [
    'Boundaries dissolve. Their gaze is all that remains.',
    'Every pop tears the membrane further. The Watchers drink.',
    'The field and the void are one. You were always here.'
  ],
  'ABYSS': [
    'You sink below. A different eye opens in the deep.',
    'Pressure crushes thought. Bioluminescent horrors drift past.',
    'The deep remembers what the surface forgot. It waits.'
  ]
};

// ==================================================
// SECTION 3: UPGRADE DEFINITIONS
// ==================================================
const UPGRADE_DEFS = {
  novaRadius:   { name: 'Nova Radius',   maxLvl: 8, desc: l => `Blast radius +${l*12}px wider — chains reach much further` },
  echoBurst:    { name: 'Echo Burst',    maxLvl: 6, desc: l => `${18*l}% chance each pop triggers a second blast (1.4x range)` },
  gravityWell:  { name: 'Gravity Well',  maxLvl: 6, desc: l => `Pops pull nearby orbs inward (strength ${l}) — clusters chains` },
  volatileOrbs: { name: 'Volatile Orbs', maxLvl: 5, desc: l => `${8*l}% of orbs glow volatile — when popped, 3x blast radius` },
  aftershock:   { name: 'Aftershock',    maxLvl: 5, desc: l => `Pops leave hot zones for ${(0.5*l).toFixed(1)}s — orbs drifting in get popped` },
  fission:      { name: 'Fission',       maxLvl: 6, desc: l => `Each pop spawns ${Math.min(3,l)} mini orbs that fly outward and chain` },
  chainFuel:    { name: 'Chain Bounty',   maxLvl: 6, desc: l => `Bonus tap rewards x${(1+0.3*l).toFixed(1)} — bigger chains earn more taps` },
  density:      { name: 'Density',       maxLvl: 6, desc: l => `+${6*l} orbs on field — more targets, bigger chains` },
  bombCharges:  { name: 'Mine Layer',    maxLvl: 3, desc: l => `Long press to place ${l} free mine${l>1?'s':''} (${BOMB_FUSE_TIME}s fuse, ${Math.round(BOMB_BLAST_MULT*100)}% blast)` },
  attractorField: { name: 'Attractor',  maxLvl: 5, desc: l => `Taps & mines pull orbs inward (range ${60+l*30}px, strength ${l}) — gravity draws them in` }
};

// Archons (SCs): Random orbs ascend into larger, spiky "Archon" forms
// When popped, Archons create a gravity well that pulls orbs inward AND have 1.5x blast radius
// They appear with tendrils and blinking eyes — pop them during chains for massive combos

// ==================================================
// SECTION 4: GAME STATE
// ==================================================
const G = {
  state: 'title',
  taps: BASE_TAPS,
  score: 0,
  level: 1,
  xp: 0,
  xpToNext: XP_BASE,
  bestChain: 0,
  chainActive: false,
  chainCount: 0,
  chainXpValue: 0,
  chainQueue: [],
  chainTimer: 0,
  chainOriginX: 0,
  chainOriginY: 0,
  time: 0,
  dt: 0,
  rawDt: 0,
  timeScale: 1.0,
  shakeAmount: 0,
  whiteGlow: 0,
  chromaticAb: 0,
  upgrades: { novaRadius:0, echoBurst:0, gravityWell:0, volatileOrbs:0, aftershock:0, fission:0, chainFuel:0, density:0, bombCharges:0, attractorField:0 },
  cursorX: -1000, cursorY: -1000,
  cursorVx: 0, cursorVy: 0,
  prevCursorX: -1000, prevCursorY: -1000,
  circles: [],
  particles: [],
  explosions: [],
  floatingTexts: [],
  paintSplats: [],
  aftershocks: [],
  chainLinks: [],
  biomeIndex: 0,
  prevBiomeIndex: 0,
  biomeTransition: 1,
  canvas: null,
  ctx: null,
  W: 0,
  H: 0,
  dpr: 1,
  audioCtx: null,
  audioUnlocked: false,
  scanlinePattern: null,
  pendingLevelUp: false,
  lastTime: 0,
  nextCircleId: 0,
  refillQueue: [],
  refillTimer: 0,
  gravityWells: [],
  delayedBlast: null,
  tapTimer: 0,
  tapTimerMax: TAP_TIMER_BASE,
  bombs: [],
  bombsPlacedThisRound: 0,
  blackHole: null,
  blackHoleTimer: 0,
  watcher: { opacity: 0, eyeGlow: 0, reachAmount: 0, breathPhase: 0 },
  horrorBoost: 0,      // cumulative horror from black holes (0-0.5 range, adds to score-based horror)
  biomeOverride: -1,  // -1 = use level-based, 0+ = index into SPECIAL_BIOMES
  prevPalette: null,
  beatPhase: 0,        // 100 BPM beat tracker (0-1 per beat)
  beatPulseOrbs: [],   // indices of orbs currently pulsing on beat
  boss: null,          // active boss entity
  bossTimer: 30,       // countdown to first boss spawn
  bossKillCount: 0,    // total bosses killed this run
  zoomLevel: 2.0,      // current zoom (2.0 = 200%, zoomed in; 0.5 = 50% zoomed out)
  zoomTarget: 2.0,     // smooth zoom transition target
  gameLeft: 0,         // visible game area boundaries (updated each frame from zoom)
  gameTop: 0,
  gameRight: 0,
  gameBottom: 0,
  gameW: 0,
  gameH: 0,
  popCenterX: 0,           // exponential moving average of pop positions
  popCenterY: 0,
  popTrackCount: 0          // number of pops tracked for directional bias
};

function resetGame() {
  G.state = 'playing';
  G.taps = BASE_TAPS;
  G.score = 0;
  G.level = 1;
  G.xp = 0;
  G.xpToNext = XP_BASE;
  G.bestChain = 0;
  G.chainActive = false;
  G.chainCount = 0;
  G.chainXpValue = 0;
  G.chainQueue = [];
  G.chainTimer = 0;
  G.time = 0;
  G.timeScale = 1.0;
  G.shakeAmount = 0;
  G.whiteGlow = 0;
  G.chromaticAb = 0;
  G.upgrades = { novaRadius:0, echoBurst:0, gravityWell:0, volatileOrbs:0, aftershock:0, fission:0, chainFuel:0, density:0, bombCharges:0, attractorField:0 };
  G.circles = [];
  G.particles = [];
  G.explosions = [];
  G.floatingTexts = [];
  G.paintSplats = [];
  G.aftershocks = [];
  G.chainLinks = [];
  G.gravityWells = [];
  G.delayedBlast = null;
  G.tapTimer = TAP_TIMER_BASE;
  G.tapTimerMax = TAP_TIMER_BASE;
  G.bombs = [];
  G.bombsPlacedThisRound = 0;
  G.blackHole = null;
  G.blackHoleTimer = 0;
  G.watcher = { opacity: 0, eyeGlow: 0, reachAmount: 0, breathPhase: 0 };
  G.horrorBoost = 0;
  G.biomeIndex = 0;
  G.prevBiomeIndex = 0;
  G.biomeTransition = 1;
  G.pendingLevelUp = false;
  G.nextCircleId = 0;
  G.refillQueue = [];
  G.refillTimer = 0;
  G.beatPhase = 0;
  G.beatPulseOrbs = [];
  G.boss = null;
  G.bossTimer = 30;
  G.bossKillCount = 0;
  G.zoomLevel = 2.0;
  G.zoomTarget = 2.0;
  G.popCenterX = 0;
  G.popCenterY = 0;
  G.popTrackCount = 0;
  // Compute game boundaries immediately so spawning uses correct area
  const resetHalfW = G.W / (2 * G.zoomLevel);
  const resetHalfH = G.H / (2 * G.zoomLevel);
  const resetCx = G.W / 2, resetCy = G.H / 2;
  G.gameLeft = resetCx - resetHalfW;
  G.gameTop = resetCy - resetHalfH;
  G.gameRight = resetCx + resetHalfW;
  G.gameBottom = resetCy + resetHalfH;
  G.gameW = G.gameRight - G.gameLeft;
  G.gameH = G.gameBottom - G.gameTop;
  whirlwindTimer = 0;
  whirlwindActive = 0;
  whirlwindDir = 1;
  abyssPressureTimer = 0;
  abyssPressureWave = 0;
  spawnInitialCircles();
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('xp-bar-wrap').style.display = 'block';
  document.getElementById('xp-bar-fill').style.width = '0%';
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  document.getElementById('upgrade-panel').style.display = 'none';
}

// ==================================================
// SECTION 5: AUDIO SYSTEM
// ==================================================
function initAudio() {
  if (G.audioCtx) return;
  try {
    G.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    G.audioUnlocked = true;
  } catch(e) {}
}

function playPopSound(chainIndex) {
  if (!G.audioCtx) return;
  const biome = getCurrentBiome();
  const freq = Math.min(biome.baseNote * Math.pow(1.055, Math.min(chainIndex, 70)), 4000);
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = biome.oscType;
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + 0.1);
  const vol = Math.min(0.12, 0.04 + chainIndex * 0.0015);
  gain.gain.setValueAtTime(vol, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.18);
}

function playBonusTapSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(880, now);
  osc.frequency.exponentialRampToValueAtTime(1400, now + 0.15);
  gain.gain.setValueAtTime(0.18, now);
  gain.gain.linearRampToValueAtTime(0.18, now + 0.1);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.35);
}

function playPhantomSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(80, now);
  osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
  gain.gain.setValueAtTime(0.08, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.2);
}

function playSCPopSound(chainIndex) {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Deep boom — low sine sweep
  const osc1 = G.audioCtx.createOscillator();
  const gain1 = G.audioCtx.createGain();
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(60, now);
  osc1.frequency.exponentialRampToValueAtTime(25, now + 0.3);
  gain1.gain.setValueAtTime(0.2, now);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
  osc1.connect(gain1);
  gain1.connect(G.audioCtx.destination);
  osc1.start(now);
  osc1.stop(now + 0.4);
  // Crunch layer — square wave burst
  const osc2 = G.audioCtx.createOscillator();
  const gain2 = G.audioCtx.createGain();
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(90, now);
  osc2.frequency.exponentialRampToValueAtTime(30, now + 0.15);
  gain2.gain.setValueAtTime(0.06, now);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc2.connect(gain2);
  gain2.connect(G.audioCtx.destination);
  osc2.start(now);
  osc2.stop(now + 0.25);
}

function playVoidCrackSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Eerie crack — descending sine with pitch wobble
  const osc1 = G.audioCtx.createOscillator();
  const gain1 = G.audioCtx.createGain();
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(400, now);
  osc1.frequency.exponentialRampToValueAtTime(80, now + 0.4);
  gain1.gain.setValueAtTime(0.15, now);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  osc1.connect(gain1);
  gain1.connect(G.audioCtx.destination);
  osc1.start(now);
  osc1.stop(now + 0.55);
  // Sub rumble
  const osc2 = G.audioCtx.createOscillator();
  const gain2 = G.audioCtx.createGain();
  osc2.type = 'triangle';
  osc2.frequency.setValueAtTime(50, now);
  osc2.frequency.exponentialRampToValueAtTime(30, now + 0.3);
  gain2.gain.setValueAtTime(0.12, now);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  osc2.connect(gain2);
  gain2.connect(G.audioCtx.destination);
  osc2.start(now);
  osc2.stop(now + 0.45);
}

function playAbyssWooshSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Sub-bass whoosh — deep rumble sweep
  const sub = G.audioCtx.createOscillator();
  const subGain = G.audioCtx.createGain();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(35, now);
  sub.frequency.exponentialRampToValueAtTime(20, now + 1.2);
  subGain.gain.setValueAtTime(0.001, now);
  subGain.gain.linearRampToValueAtTime(0.15, now + 0.3);
  subGain.gain.linearRampToValueAtTime(0.12, now + 0.8);
  subGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
  sub.connect(subGain);
  subGain.connect(G.audioCtx.destination);
  sub.start(now);
  sub.stop(now + 1.6);
  // Triangle wave sweep — whooshing mid layer
  const tri = G.audioCtx.createOscillator();
  const triGain = G.audioCtx.createGain();
  tri.type = 'triangle';
  tri.frequency.setValueAtTime(120, now);
  tri.frequency.exponentialRampToValueAtTime(50, now + 1.0);
  triGain.gain.setValueAtTime(0.001, now);
  triGain.gain.linearRampToValueAtTime(0.06, now + 0.2);
  triGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
  tri.connect(triGain);
  triGain.connect(G.audioCtx.destination);
  tri.start(now);
  tri.stop(now + 1.3);
}

function playDelayedBlastBuildup(tier, duration) {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Rising sweep — sawtooth from low to high over the buildup duration
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sawtooth';
  const startFreq = tier === 3 ? 80 : tier === 2 ? 120 : 180;
  const endFreq = tier === 3 ? 900 : tier === 2 ? 700 : 500;
  osc.frequency.setValueAtTime(startFreq, now);
  osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration * 0.9);
  const vol = tier === 3 ? 0.10 : tier === 2 ? 0.07 : 0.05;
  gain.gain.setValueAtTime(0.01, now);
  gain.gain.linearRampToValueAtTime(vol, now + duration * 0.8);
  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + duration + 0.05);
  // Sub-bass rumble
  const sub = G.audioCtx.createOscillator();
  const subGain = G.audioCtx.createGain();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(40, now);
  subGain.gain.setValueAtTime(0.08, now);
  subGain.gain.linearRampToValueAtTime(0.15, now + duration * 0.8);
  subGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
  sub.connect(subGain);
  subGain.connect(G.audioCtx.destination);
  sub.start(now);
  sub.stop(now + duration + 0.05);
}

function playDelayedBlastExplosion(tier) {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Bass drop
  const bass = G.audioCtx.createOscillator();
  const bassGain = G.audioCtx.createGain();
  bass.type = 'sine';
  bass.frequency.setValueAtTime(tier === 3 ? 200 : 150, now);
  bass.frequency.exponentialRampToValueAtTime(20, now + 0.4);
  const bv = tier === 3 ? 0.25 : tier === 2 ? 0.18 : 0.12;
  bassGain.gain.setValueAtTime(bv, now);
  bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  bass.connect(bassGain);
  bassGain.connect(G.audioCtx.destination);
  bass.start(now);
  bass.stop(now + 0.55);
  // White noise burst
  const bufferSize = G.audioCtx.sampleRate * 0.3;
  const noiseBuffer = G.audioCtx.createBuffer(1, bufferSize, G.audioCtx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
  const noise = G.audioCtx.createBufferSource();
  noise.buffer = noiseBuffer;
  const noiseGain = G.audioCtx.createGain();
  const nv = tier === 3 ? 0.12 : tier === 2 ? 0.08 : 0.05;
  noiseGain.gain.setValueAtTime(nv, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
  noise.connect(noiseGain);
  noiseGain.connect(G.audioCtx.destination);
  noise.start(now);
  noise.stop(now + 0.3);
  // High ring
  if (tier >= 2) {
    const ring = G.audioCtx.createOscillator();
    const ringGain = G.audioCtx.createGain();
    ring.type = 'sine';
    ring.frequency.setValueAtTime(2000, now);
    ring.frequency.exponentialRampToValueAtTime(600, now + 0.4);
    ringGain.gain.setValueAtTime(0.06, now);
    ringGain.gain.exponentialRampToValueAtTime(0.001, now + 0.45);
    ring.connect(ringGain);
    ringGain.connect(G.audioCtx.destination);
    ring.start(now);
    ring.stop(now + 0.5);
  }
}

// ==================================================
// SECTION 6: UTILITIES
// ==================================================
function dist(x1, y1, x2, y2) {
  const dx = x1 - x2, dy = y1 - y2;
  return Math.sqrt(dx*dx + dy*dy);
}

function lerp(a, b, t) { return a + (b - a) * t; }

function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  const r = Math.round(lerp(r1,r2,t)), g = Math.round(lerp(g1,g2,t)), b = Math.round(lerp(b1,b2,t));
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}

// ==================================================
// MADNESS SYSTEM — unified 0% to 100% scale
// ==================================================
// 0% = initial state, colorful, normal orbs, clean UI
// 100% = full horror: eyes everywhere, Enochian UI, desaturated palette
// Driven by score progression + black hole exposure (horrorBoost)
//
// Score contribution:  0 at <100k, ramps 0→0.5 at 100k→500k, 0.5→1.0 at 500k→900k
// Black holes add permanent horrorBoost (capped at 0.6)
// Total capped at 1.0
let devMadnessOverride = -1; // -1 = off, 0-1 = forced value

function getMadnessAmount() {
  if (devMadnessOverride >= 0) return devMadnessOverride;
  let base = 0;
  if (G.score >= 100000 && G.score < 500000) base = (G.score - 100000) / 400000 * 0.5;
  else if (G.score >= 500000) base = 0.5 + Math.min(0.5, (G.score - 500000) / 400000);
  return Math.min(1, base + G.horrorBoost);
}

// Alias for backward compatibility — horror and madness are the same value
function getHorrorAmount() {
  return getMadnessAmount();
}

// Desaturate + tint a hex color toward sickly grey-green-brown
function horrorShift(hex, amount) {
  if (amount <= 0) return hex;
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  // Desaturate toward luminance
  const lum = r * 0.299 + g * 0.587 + b * 0.114;
  r = Math.round(lerp(r, lum, amount * 0.8));
  g = Math.round(lerp(g, lum, amount * 0.8));
  b = Math.round(lerp(b, lum, amount * 0.8));
  // Past 50% horror: tint toward sickly flesh/bile tones
  if (amount > 0.5) {
    const tintStr = (amount - 0.5) * 2; // 0 to 1
    // Shift toward dark muted flesh (140, 100, 80)
    r = Math.round(lerp(r, Math.min(r, 140), tintStr * 0.4));
    g = Math.round(lerp(g, Math.min(g, 90), tintStr * 0.5));
    b = Math.round(lerp(b, Math.min(b, 70), tintStr * 0.5));
    // Darken overall
    const darken = 1 - tintStr * 0.25;
    r = Math.round(r * darken);
    g = Math.round(g * darken);
    b = Math.round(b * darken);
  }
  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function getCurrentPalette() {
  if (G.biomeOverride >= 0 && G.biomeOverride < SPECIAL_BIOMES.length) {
    return SPECIAL_BIOMES[G.biomeOverride];
  }
  const idx = Math.min(Math.floor((G.level - 1) / PALETTE_LEVELS), PALETTES.length - 1);
  return PALETTES[idx];
}

// Compat shim — old code calls getCurrentBiome()
function getCurrentBiome() {
  const p = getCurrentPalette();
  return {
    bgTop: p.bgTop, bgBot: p.bgBot,
    orbColors: p.colors.map(c => [c, c]),
    particleType: 'spark',
    gridTint: 'rgba(0,0,0,0)',
    baseNote: p.baseNote,
    oscType: p.oscType
  };
}

// Color a circle based on its screen position (cluster gradient)
function getClusterColor(x, y) {
  const p = getCurrentPalette();
  const t = Math.max(0, Math.min(1, x / G.W));
  let color;
  if (t < 0.5) {
    const lt = t * 2;
    color = lerpColor(p.colors[0], p.colors[1], lt);
  } else {
    const lt = (t - 0.5) * 2;
    color = lerpColor(p.colors[1], p.colors[2], lt);
  }
  // Horror desaturation at high scores
  const horror = getHorrorAmount();
  if (horror > 0) color = horrorShift(color, horror);
  return color;
}

function getTargetCircleCount() {
  // Starts at 45, grows by ~2 per level, caps around 65 (before density upgrade)
  const levelBonus = Math.min(20, (G.level - 1) * 2);
  const baseCount = BASE_CIRCLE_COUNT + levelBonus + G.upgrades.density * 6;
  // Soften by zoom: at 2.0× → ~70% orbs, at 1.0 → 100%, at 0.5 → 100% (capped)
  const zoomFactor = Math.min(1, 0.3 + 0.7 / G.zoomLevel);
  // Madness orb flood: after 50% madness, gradually double the orb count
  // 0-50% madness: 1.0×, 50-100% madness: ramps 1.0× → 2.0×
  const madness = getMadnessAmount();
  const madnessOrbMult = madness <= 0.5 ? 1.0 : 1.0 + (madness - 0.5) * 2.0;
  return Math.round(baseCount * zoomFactor * madnessOrbMult);
}

// --- PROGRESSION SCALING HELPERS ---
// Level-scaled blast radius: sqrt curve — big jump early, diminishing later
// All physics scale with madness: radius grows up to +30% at full madness
function getMadnessPhysicsScale() {
  return 1 + getMadnessAmount() * 0.3; // 1.0 at 0 madness, 1.3 at full
}

function getBlastRadius() {
  const t = Math.min(1, (G.level - 1) / 9); // 0 at lvl1, 1 at lvl10
  const growth = Math.sqrt(t);
  const base = BASE_BLAST_RADIUS + (MAX_BLAST_RADIUS - BASE_BLAST_RADIUS) * growth;
  // Soften blast by zoom: at 2.0× → ~85%, at 1.0 → 100%, at 0.5 → 100%
  const zoomScale = Math.min(1, 0.3 + 0.7 / G.zoomLevel);
  // Madness amplifies all physics
  return base * zoomScale * getMadnessPhysicsScale();
}

// Level-scaled fracturing: no fractures at lvl1, ramps in GRADUALLY over 10 levels
function getFractureCounts() {
  // Level 1-2: no fracturing at all
  // Level 3-4: gen0→1 only (1 fragment)
  // Level 5-6: gen0→1, gen1→1 (single chain)
  // Level 7-8: gen0→2, gen1→1 (branching starts)
  // Level 9:   gen0→2, gen1→1, gen2→1 (full depth, lean)
  // Level 10-11: gen0→2, gen1→2, gen2→1 (full fracturing tree)
  // Level 12-14: gen0→2, gen1→2, gen2→1, gen3→1 (gen-4 "smaller1" tier)
  // Level 15+: gen0→2, gen1→2, gen2→1, gen3→1, gen4→1 (gen-5 "micro" tier)
  // [gen0, gen1, gen2, gen3, gen4] → how many children each generation spawns
  if (G.level <= 2) return [0, 0, 0, 0, 0];
  if (G.level <= 4) return [1, 0, 0, 0, 0];
  if (G.level <= 6) return [1, 1, 0, 0, 0];
  if (G.level <= 8) return [2, 1, 0, 0, 0];
  if (G.level <= 9) return [2, 1, 1, 0, 0];
  if (G.level <= 11) return [2, 2, 1, 0, 0];
  if (G.level <= 14) return [2, 2, 1, 1, 0]; // gen-4 "smaller1" at level 12+
  return [2, 2, 1, 1, 1]; // gen-5 "micro" at level 15+
}

// Level-scaled shrapnel: needs higher chain count early, loosens later
function getShrapnelThreshold() {
  if (G.level <= 2) return 4;   // need chain ≥ 4 early
  if (G.level <= 4) return 3;
  return 2;
}

// Level-scaled bonus tap thresholds
function getBonusTapThresholds() {
  const lvl = G.level;
  if (lvl <= 2) return { big: 15, mid: 8,  small: 4, smallChance: 0.50 };  // 4+ pops = 50% chance +1 tap
  if (lvl <= 4) return { big: 20, mid: 12, small: 6, smallChance: 0.45 };
  if (lvl <= 6) return { big: 25, mid: 15, small: 8, smallChance: 0.40 };
  if (lvl <= 9) return { big: 35, mid: 22, small: 12, smallChance: 0.35 };
  return { big: 35, mid: 20, small: 12, smallChance: 0.40 };
}

// Level-scaled tap timer: tighter early, more generous later
function getTapTimerMax() {
  // Level 1: 10s, grows by 0.5s per level, caps at 16s
  return Math.min(16, TAP_TIMER_BASE + (G.level - 1) * 0.5);
}

// Cascade Burst: smaller orbs (gen-1, gen-2) spawn bonus micro-fragments
// during long chains. Rule: chainCount must exceed threshold based on generation.
// gen-1 needs chain≥12 to burst, gen-2 needs chain≥20. Spawns 1-2 even tinier orbs.
function getCascadeBurstCount(generation) {
  if (generation === 1 && G.chainCount >= 12) return 1 + (G.chainCount >= 25 ? 1 : 0);
  if (generation === 2 && G.chainCount >= 20) return 1;
  if (generation === 3 && G.chainCount >= 25) return 1; // gen-3 can burst into gen-4
  if (generation === 4 && G.chainCount >= 30) return 1; // gen-4 can burst into gen-5
  return 0;
}

// ==================================================
// SECTION 7: CIRCLE (ORB) MANAGEMENT
// ==================================================
function createCircle(x, y) {
  const color = getClusterColor(x, y);
  const isVolatile = Math.random() < (G.upgrades.volatileOrbs * 0.08);
  const baseR = BASE_CIRCLE_RADIUS + Math.random() * 4;
  let r = baseR;
  if (isVolatile) r *= 1.3;
  // Void Crack orbs: RARE special armored orbs from level 3+ (flat 3% chance)
  const armorChance = G.level >= 3 ? 0.03 : 0;
  const isArmored = !isVolatile && Math.random() < armorChance;
  return {
    id: G.nextCircleId++,
    x, y,
    radius: r,
    baseRadius: r,
    color: color,
    colorEdge: color,
    volatile: isVolatile,
    armored: isArmored,
    armorHP: isArmored ? 2 : 0,  // 2=fresh, 1=cracked, 0=normal
    superCell: false,
    spikeCount: 0,
    scFade: 0,
    scTimer: 0,
    scLifespan: 0,
    scCooldown: 3 + Math.random() * 8,
    popped: false,
    queued: false,
    pulsePhase: Math.random() * Math.PI * 2,
    vx: 0, vy: 0,
    driftAngle: Math.random() * Math.PI * 2,
    driftTimer: Math.random() * 3,
    generation: 0,
    shrapnel: false,
    shrapnelImmune: 0,
    spawnAnim: 1.0,
    fadeIn: 0,
    alive: true,
    trail: [], // position history for motion blur
    synthCooldown: 0, // cooldown timer for color synthesis
    mergeCount: 1,     // how many orbs merged into this one
    mergeCooldown: 0,  // cooldown between merges
    mergeTarget: null,  // ID of orb being merged into (null = not merging)
    mergeAnimProgress: 0, // 0→1 merge animation progress
    mergeGlow: 0       // glow flash on orb that absorbed another
  };
}

function findCircleById(id) {
  for (let i = 0; i < G.circles.length; i++) {
    if (G.circles[i].id === id) return G.circles[i];
  }
  return null;
}

function spawnInitialCircles() {
  G.circles = [];
  const count = getTargetCircleCount();
  const margin = 30;
  // Use zoom-aware boundaries for spawning (fall back to full screen if not yet computed)
  const sL = G.gameLeft || 0, sT = G.gameTop || 0;
  const sW = G.gameW || G.W, sH = G.gameH || G.H;
  for (let i = 0; i < count; i++) {
    let x, y, valid, attempts = 0;
    do {
      x = sL + margin + Math.random() * (sW - margin * 2);
      y = sT + margin + Math.random() * (sH - margin * 2);
      valid = true;
      for (let j = 0; j < G.circles.length; j++) {
        if (dist(x, y, G.circles[j].x, G.circles[j].y) < 30) { valid = false; break; }
      }
      attempts++;
    } while (!valid && attempts < 30);
    const c = createCircle(x, y);
    c.spawnAnim = 0;
    G.circles.push(c);
  }
}

function spawnCircleFromEdge() {
  if (G.circles.length >= MAX_CIRCLES) return;

  // ~25% chance: spawn from darkness (fade-in at random position)
  if (Math.random() < 0.25) {
    spawnCircleFadeIn();
    return;
  }

  // Directional bias: 50% chance to spawn from opposite side of recent pops
  let edge;
  const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
  const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
  if (Math.random() < 0.5 && G.popTrackCount > 5) {
    const pdx = G.popCenterX - gcx;
    const pdy = G.popCenterY - gcy;
    if (Math.abs(pdx) > Math.abs(pdy)) {
      edge = pdx > 0 ? 0 : 1; // pops on right → spawn from left, vice versa
    } else {
      edge = pdy > 0 ? 2 : 3; // pops on bottom → spawn from top, vice versa
    }
  } else {
    edge = Math.floor(Math.random() * 4);
  }
  let x, y, vx = 0, vy = 0;
  const margin = 30;
  const speed = 40 + Math.random() * 30;
  const eL = G.gameLeft || 0, eT = G.gameTop || 0;
  const eR = G.gameRight || G.W, eB = G.gameBottom || G.H;
  switch(edge) {
    case 0: x = eL - margin; y = eT + margin + Math.random() * ((eB - eT) - margin*2); vx = speed; break;
    case 1: x = eR + margin; y = eT + margin + Math.random() * ((eB - eT) - margin*2); vx = -speed; break;
    case 2: y = eT - margin; x = eL + margin + Math.random() * ((eR - eL) - margin*2); vy = speed; break;
    case 3: y = eB + margin; x = eL + margin + Math.random() * ((eR - eL) - margin*2); vy = -speed; break;
  }
  const c = createCircle(x, y);
  c.vx = vx;
  c.vy = vy;
  c.spawnAnim = 1.0;
  G.circles.push(c);
}

// Fade-in spawn: orb materializes from darkness at a random screen position
function spawnCircleFadeIn() {
  if (G.circles.length >= MAX_CIRCLES) return;
  const margin = 50;
  const fL = G.gameLeft || 0, fT = G.gameTop || 0;
  const fW = G.gameW || G.W, fH = G.gameH || G.H;
  const x = fL + margin + Math.random() * (fW - margin * 2);
  const y = fT + margin + Math.random() * (fH - margin * 2);
  const c = createCircle(x, y);
  c.vx = 0;
  c.vy = 0;
  c.spawnAnim = 0; // no slide-in
  c.fadeIn = 1.0; // custom fade-in timer (1.0 → 0.0)
  c.radius = 0.1; // starts tiny, grows
  G.circles.push(c);
}

// Weighted orb value: default=1.0, smaller orbs count as less toward population cap
function getOrbValue(c) {
  const sizeRatio = c.radius / BASE_CIRCLE_RADIUS;
  if (sizeRatio >= 1.5) return 1.5; // big merged orbs count as more
  if (sizeRatio >= 0.9) return 1.0; // normal orbs
  if (sizeRatio >= 0.5) return 0.5; // mid/small fragments
  if (sizeRatio >= 0.3) return 0.25; // smaller1
  if (sizeRatio >= 0.15) return 0.15; // smaller2
  return 0.1; // micro
}

function getWeightedOrbCount() {
  let total = 0;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;
    total += getOrbValue(c);
  }
  return total;
}

function refillCircles() {
  const target = getTargetCircleCount();
  const weightedAlive = getWeightedOrbCount();
  const needed = Math.round(target - weightedAlive);
  G.refillQueue = [];
  G.refillTimer = 0;
  for (let i = 0; i < needed; i++) {
    G.refillQueue.push(i * 0.05);
  }
}

function updateRefillQueue(dt) {
  if (G.refillQueue.length === 0) return;
  G.refillTimer += dt;
  while (G.refillQueue.length > 0 && G.refillTimer >= G.refillQueue[0]) {
    G.refillQueue.shift();
    spawnCircleFromEdge();
  }
}

function updateCircles(dt) {
  // Only remove dead circles when chain is NOT active
  if (!G.chainActive) {
    G.circles = G.circles.filter(c => c.alive);
  }

  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.alive || c.popped) continue;

    // Shrapnel immunity countdown
    if (c.shrapnelImmune > 0) c.shrapnelImmune -= dt;

    // Spawn slide-in animation
    if (c.spawnAnim > 0) {
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      c.spawnAnim -= dt * 1.5;
      if (c.spawnAnim <= 0) {
        c.spawnAnim = 0;
        c.vx = 0;
        c.vy = 0;
      }
    }

    // Velocity-based movement for all orbs (shrapnel, fission, gravity-affected)
    // Light drag lets momentum persist for orbital mechanics
    if (c.spawnAnim <= 0 && (Math.abs(c.vx) > 0.5 || Math.abs(c.vy) > 0.5)) {
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      // Gentle drag — velocity persists long enough for orbits
      const drag = 1 - 1.2 * dt;
      c.vx *= drag;
      c.vy *= drag;
    }

    // Fade-in from darkness animation — grow from nothing
    if (c.fadeIn > 0) {
      c.fadeIn -= dt * 0.8; // ~1.25s to fully appear
      if (c.fadeIn <= 0) {
        c.fadeIn = 0;
        c.radius = c.baseRadius;
      } else {
        const t = 1 - c.fadeIn;
        c.radius = c.baseRadius * t * t; // accelerating growth
      }
    }

    // Gravitational swirl — orbital motion around field center + gentle attractors
    // Each orb feels a pull toward a slowly-shifting attractor point
    // but also gets a tangential push, creating swirling orbits
    const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
    const gw = G.gameW || G.W, gh = G.gameH || G.H;
    const attractX = gcx + Math.sin(G.time * 0.13) * gw * 0.2;
    const attractY = gcy + Math.cos(G.time * 0.11) * gh * 0.15;
    const adx = attractX - c.x;
    const ady = attractY - c.y;
    const aDist = Math.sqrt(adx * adx + ady * ady) + 1;
    // Gravitational pull (inverse distance, capped)
    const gravStr = Math.min(35, 800 / aDist) * dt;
    // Tangential component (perpendicular to radial) — creates orbiting
    const tangentX = -ady / aDist;
    const tangentY = adx / aDist;
    const tangentStr = Math.min(25, 500 / aDist) * dt;
    // Apply both radial pull and tangential swirl
    c.x += (adx / aDist) * gravStr + tangentX * tangentStr;
    c.y += (ady / aDist) * gravStr + tangentY * tangentStr;

    // Ambient wave overlay for organic feel
    c.x += Math.sin(G.time * 0.4 + c.pulsePhase) * 0.6 * dt * 10;
    c.y += Math.cos(G.time * 0.35 + c.pulsePhase * 1.3) * 0.6 * dt * 10;

    // Brownian nudges — change drift direction periodically
    c.driftTimer -= dt;
    if (c.driftTimer <= 0) {
      c.driftTimer = 1.5 + Math.random() * 2.5;
      c.driftAngle += (Math.random() - 0.5) * 2.0;
    }
    const driftSpeed = c.superCell ? 8 : 12;
    c.x += Math.cos(c.driftAngle) * driftSpeed * dt;
    c.y += Math.sin(c.driftAngle) * driftSpeed * dt;

    // Cursor gravity — pull toward mouse/touch, boosted by cursor movement speed
    if (G.cursorX > 0 && G.cursorY > 0) {
      const cdx = G.cursorX - c.x;
      const cdy = G.cursorY - c.y;
      const cDist = Math.sqrt(cdx * cdx + cdy * cdy) + 1;
      // Cursor speed boost: fast circular motion amplifies gravity (1.0× to 2.5×)
      const cursorSpeed = Math.sqrt(G.cursorVx * G.cursorVx + G.cursorVy * G.cursorVy);
      const speedBoost = 1 + Math.min(1.5, cursorSpeed / 400);
      // Gradual inverse-square falloff — strong nearby, wide reach, grows with madness
      const madPhys = getMadnessPhysicsScale();
      const cursorPull = Math.min(65 * speedBoost * madPhys, 16000 * speedBoost * madPhys / (cDist * cDist + 80)) * dt;
      c.x += (cdx / cDist) * cursorPull;
      c.y += (cdy / cDist) * cursorPull;

      // Cursor BRUSH: moving cursor pushes nearby orbs in cursor direction
      // Like brushing marbles on a table
      if (cursorSpeed > 30 && cDist < 60 + c.radius) {
        const brushStr = Math.min(1, cursorSpeed / 800) * (1 - cDist / (60 + c.radius));
        const brushForce = brushStr * 120 * dt;
        c.vx += (G.cursorVx / cursorSpeed) * brushForce;
        c.vy += (G.cursorVy / cursorSpeed) * brushForce;
      }
    }

    // Record trail for motion blur (max 12 positions, pronounced effect)
    const speed = Math.sqrt(c.vx * c.vx + c.vy * c.vy);
    if (speed > 6 && c.trail) {
      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 12) c.trail.shift();
    } else if (c.trail && c.trail.length > 0) {
      c.trail.shift(); // fade out trail when slow
    }

    // Keep on screen — shrapnel/fission wrap around, normal orbs soft-bounce
    // Use zoom-aware game boundaries
    const pad = c.radius + 5;
    const bL = G.gameLeft || 0, bT = G.gameTop || 0;
    const bR = G.gameRight || G.W, bB = G.gameBottom || G.H;
    if (c.spawnAnim <= 0) {
      const speed = Math.sqrt(c.vx * c.vx + c.vy * c.vy);
      if ((c.shrapnel || c.generation > 0) && speed > 50) {
        // Screen wrap — appear from opposite edge
        if (c.x < bL - pad) c.x = bR + pad - 1;
        else if (c.x > bR + pad) c.x = bL - pad + 1;
        if (c.y < bT - pad) c.y = bB + pad - 1;
        else if (c.y > bB + pad) c.y = bT - pad + 1;
      } else {
        if (c.x < bL + pad) { c.x = bL + pad; c.driftAngle = Math.PI - c.driftAngle; if (c.vx < 0) c.vx *= -0.5; }
        if (c.x > bR - pad) { c.x = bR - pad; c.driftAngle = Math.PI - c.driftAngle; if (c.vx > 0) c.vx *= -0.5; }
        if (c.y < bT + pad) { c.y = bT + pad; c.driftAngle = -c.driftAngle; if (c.vy < 0) c.vy *= -0.5; }
        if (c.y > bB - pad) { c.y = bB - pad; c.driftAngle = -c.driftAngle; if (c.vy > 0) c.vy *= -0.5; }
      }
    }

    // Colors are now persistent — set at creation, not updated per frame
    // Orbs keep the color they spawned with as they drift

    // Pulse phase
    c.pulsePhase += dt * (c.superCell ? 3 : 2);

    // Merge glow decay (survivor flash after absorbing another orb)
    if (c.mergeGlow > 0) c.mergeGlow = Math.max(0, c.mergeGlow - dt * 3);

    // SC mutation lifecycle — only gen-0 circles can mutate
    if (!c.volatile && !c.queued && c.spawnAnim <= 0 && c.generation === 0) {
      if (c.superCell) {
        // Currently an SC — count down lifespan
        c.scTimer += dt;
        if (c.scTimer < 0.34) {
          // Fade in
          c.scFade = c.scTimer / 0.34;
          c.radius = c.baseRadius + (c.baseRadius * (SC_RADIUS_MULT - 1)) * c.scFade;
        } else if (c.scTimer > c.scLifespan - 0.42) {
          // Fade out
          c.scFade = Math.max(0, (c.scLifespan - c.scTimer) / 0.42);
          c.radius = c.baseRadius + (c.baseRadius * (SC_RADIUS_MULT - 1)) * c.scFade;
          if (c.scTimer >= c.scLifespan) {
            // Revert to normal
            c.superCell = false;
            c.spikeCount = 0;
            c.scFade = 0;
            c.radius = c.baseRadius;
            c.scCooldown = 4.25 + Math.random() * 10.2;
          }
        } else {
          c.scFade = 1;
          c.radius = c.baseRadius * SC_RADIUS_MULT;
        }
      } else {
        // Normal cell — count cooldown, maybe mutate
        c.scCooldown -= dt;
        if (c.scCooldown <= 0) {
          if (G.level >= 5 && Math.random() < SC_SPAWN_CHANCE) {
            c.superCell = true;
            c.spikeCount = SC_SPIKE_MIN + Math.floor(Math.random() * (SC_SPIKE_MAX - SC_SPIKE_MIN + 1));
            c.scTimer = 0;
            c.scLifespan = 2.1 + Math.random() * 3.4;
            c.scFade = 0;
          }
          c.scCooldown = 3.4 + Math.random() * 8.5;
        }
      }
    }
  }
}

// ==================================================
// SECTION 7b: COLOR SYNTHESIS — orbs blending on contact
// ==================================================
// When orbs of different colors overlap, they exchange color,
// producing a brief visual spark and blending toward each other.
// Synthesis creates emergent color evolution across the field.

function colorDistance(hex1, hex2) {
  const r1 = parseInt(hex1.slice(1,3),16), g1 = parseInt(hex1.slice(3,5),16), b1 = parseInt(hex1.slice(5,7),16);
  const r2 = parseInt(hex2.slice(1,3),16), g2 = parseInt(hex2.slice(3,5),16), b2 = parseInt(hex2.slice(5,7),16);
  return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
}

function updateColorSynthesis(dt) {
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Decrement cooldowns
  for (let i = 0; i < len; i++) {
    if (circles[i].synthCooldown > 0) circles[i].synthCooldown -= dt;
  }

  // Spatial grid for O(n) proximity — avoids O(n²) brute force
  const cellSize = 50; // roughly 2x max radius
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH);
  for (let i = 0; i < grid.length; i++) grid[i] = null;

  // Populate grid
  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped || c.spawnAnim > 0.5) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._gridNext = grid[idx];
    grid[idx] = i;
  }

  // Check neighboring cells
  let synthCount = 0;
  const maxSynthPerFrame = 5; // cap effects per frame for performance

  for (let i = 0; i < len && synthCount < maxSynthPerFrame; i++) {
    const a = circles[i];
    if (!a.alive || a.popped || a.synthCooldown > 0 || a.spawnAnim > 0.3) continue;

    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    // Check 3x3 neighborhood
    for (let dy = -1; dy <= 1 && synthCount < maxSynthPerFrame; dy++) {
      for (let dx = -1; dx <= 1 && synthCount < maxSynthPerFrame; dx++) {
        const nx = gx + dx;
        const ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        const idx = ny * gridW + nx;
        let j = grid[idx];
        while (j !== null && synthCount < maxSynthPerFrame) {
          const b = circles[j];
          const nextJ = b._gridNext;

          if (j > i && b.alive && !b.popped && b.synthCooldown <= 0 && b.spawnAnim <= 0.3) {
            // Distance check
            const ddx = a.x - b.x;
            const ddy = a.y - b.y;
            const dist = Math.sqrt(ddx * ddx + ddy * ddy);
            const touchDist = a.radius + b.radius;

            if (dist < touchDist * 0.85) {
              // Check color difference — only synthesize if colors are sufficiently different
              const cDiff = colorDistance(a.color, b.color);
              if (cDiff > 80) {
                // === SYNTHESIS! ===
                // Blend both colors toward each other (asymmetric — smaller orb shifts more)
                const aSize = a.radius * a.radius; // area-based weight
                const bSize = b.radius * b.radius;
                const total = aSize + bSize;
                const blendA = 0.08 * (bSize / total); // how much A shifts toward B
                const blendB = 0.08 * (aSize / total); // how much B shifts toward A

                a.color = lerpColor(a.color, b.color, blendA);
                a.colorEdge = a.color;
                b.color = lerpColor(b.color, a.color, blendB);
                b.colorEdge = b.color;

                // Cooldown prevents rapid-fire synthesis
                a.synthCooldown = 0.4 + Math.random() * 0.2;
                b.synthCooldown = 0.4 + Math.random() * 0.2;

                // Slight velocity kick — gentle push apart
                const pushStr = 15;
                const nx2 = dist > 0.5 ? ddx / dist : (Math.random() - 0.5);
                const ny2 = dist > 0.5 ? ddy / dist : (Math.random() - 0.5);
                a.vx += nx2 * pushStr;
                a.vy += ny2 * pushStr;
                b.vx -= nx2 * pushStr;
                b.vy -= ny2 * pushStr;

                // Visual effect: synthesis spark
                const mx = (a.x + b.x) * 0.5;
                const my = (a.y + b.y) * 0.5;
                const blendedColor = lerpColor(a.color, b.color, 0.5);

                // Emit tiny sparks at contact point
                for (let s = 0; s < 4; s++) {
                  const angle = Math.random() * Math.PI * 2;
                  const speed = 30 + Math.random() * 50;
                  spawnParticle(mx, my, 'spark', blendedColor, {
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    maxLife: 0.25 + Math.random() * 0.2,
                    size: 1.5 + Math.random() * 2
                  });
                }

                // Soft glow ring at contact
                spawnParticle(mx, my, 'ripple', blendedColor, {
                  maxLife: 0.4,
                  size: 0,
                  layer: 'bg'
                });

                synthCount++;
              }
            }
          }

          j = nextJ;
        }
      }
    }
  }

  // Clean up grid pointers
  for (let i = 0; i < len; i++) {
    circles[i]._gridNext = null;
  }
}

// ==================================================
// SECTION 7c: ORB MERGING — combo-bubbles from collisions
// ==================================================
function updateOrbMerging(dt) {
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Decrement merge cooldowns
  for (let i = 0; i < len; i++) {
    if (circles[i].mergeCooldown > 0) circles[i].mergeCooldown -= dt;
  }

  // Spatial hash grid (same approach as color synthesis)
  const cellSize = 50;
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH).fill(null);

  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped || c.spawnAnim > 0.5 || c.mergeCooldown > 0) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._mergeNext = grid[idx];
    grid[idx] = i;
  }

  let merges = 0;
  const maxMerges = 3; // performance cap per frame

  for (let i = 0; i < len && merges < maxMerges; i++) {
    const a = circles[i];
    if (!a.alive || a.popped || a.mergeCooldown > 0 || a.spawnAnim > 0.3) continue;
    if (a.mergeCount >= 6 || a.superCell || a.armored) continue;

    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    for (let dy = -1; dy <= 1 && merges < maxMerges; dy++) {
      for (let dx = -1; dx <= 1 && merges < maxMerges; dx++) {
        const nx = gx + dx, ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        let j = grid[ny * gridW + nx];
        while (j !== null && merges < maxMerges) {
          const b = circles[j];
          const nextJ = b._mergeNext;
          if (j > i && b.alive && !b.popped && b.mergeCooldown <= 0
              && b.spawnAnim <= 0.3 && (b.mergeCount || 1) < 4
              && !b.superCell && !b.armored) {
            const ddx = a.x - b.x;
            const ddy = a.y - b.y;
            const d = Math.sqrt(ddx * ddx + ddy * ddy);
            const touchDist = a.radius + b.radius;

            // Merge on hard overlap (70%) — physics-based: speed + mass determine merge chance
            if (d < touchDist * 0.7) {
              // Calculate relative impact speed
              const relVx = a.vx - b.vx;
              const relVy = a.vy - b.vy;
              const impactSpeed = Math.sqrt(relVx * relVx + relVy * relVy);
              // Mass ratio (area-based) — bigger ratio = easier merge
              const massA = a.radius * a.radius;
              const massB = b.radius * b.radius;
              const massRatio = Math.max(massA, massB) / Math.min(massA, massB);
              // Merge probability: low base + speed boost + mass ratio boost
              const speedFactor = Math.min(1, impactSpeed / 120);
              const massFactor = Math.min(1, (massRatio - 1) / 3);
              const mergeChance = 0.02 + speedFactor * 0.45 + massFactor * 0.25;
              if (Math.random() < mergeChance) {
                // Area-based radius growth, capped
                const newArea = Math.PI * a.radius * a.radius + Math.PI * b.radius * b.radius;
                a.radius = Math.min(BASE_CIRCLE_RADIUS * 3.5, Math.sqrt(newArea / Math.PI));
                a.baseRadius = a.radius;

                // Blend colors
                a.color = lerpColor(a.color, b.color, 0.5);
                a.colorEdge = a.color;
                a.mergeCount = (a.mergeCount || 1) + (b.mergeCount || 1);

                // Average velocities
                a.vx = (a.vx + b.vx) * 0.5;
                a.vy = (a.vy + b.vy) * 0.5;
                a.mergeCooldown = 1.0;
                a.mergeGlow = 1.0; // survivor glows briefly

                // Start merge animation instead of instant kill
                b.mergeTarget = a.id;
                b.mergeAnimProgress = 0;
                b.queued = true; // prevent chain pops during merge anim

                // Visual ripple at merge point
                const mx = (a.x + b.x) * 0.5, my = (a.y + b.y) * 0.5;
                spawnParticle(mx, my, 'ripple', a.color, {
                  maxLife: 0.4, size: 0, layer: 'bg'
                });

                merges++;
              } else {
                // Push apart instead of merging
                a.mergeCooldown = 0.5;
                b.mergeCooldown = 0.5;
                if (d > 0.1) {
                  const pushStr = 30;
                  a.vx += (ddx / d) * pushStr;
                  a.vy += (ddy / d) * pushStr;
                  b.vx -= (ddx / d) * pushStr;
                  b.vy -= (ddy / d) * pushStr;
                }
              }
            }
          }
          j = nextJ;
        }
      }
    }
  }

  // Clean up grid pointers
  for (let i = 0; i < len; i++) {
    circles[i]._mergeNext = undefined;
  }
}

// ==================================================
// SECTION 7d: INTER-ORB GRAVITY — bigger orbs pull smaller orbs
// ==================================================
function updateInterOrbGravity(dt) {
  const circles = G.circles;
  const len = circles.length;
  if (len < 2) return;

  // Spatial hash grid (same 50px cells as merging)
  const cellSize = 50;
  const gridW = Math.ceil(G.W / cellSize) + 1;
  const gridH = Math.ceil(G.H / cellSize) + 1;
  const grid = new Array(gridW * gridH).fill(null);

  for (let i = 0; i < len; i++) {
    const c = circles[i];
    if (!c.alive || c.popped) continue;
    const gx = Math.floor(c.x / cellSize);
    const gy = Math.floor(c.y / cellSize);
    if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) continue;
    const idx = gy * gridW + gx;
    c._gravNext = grid[idx];
    grid[idx] = i;
  }

  // Check neighbors — only pull from larger → smaller
  for (let i = 0; i < len; i++) {
    const a = circles[i];
    if (!a.alive || a.popped || a.queued) continue;
    const gx = Math.floor(a.x / cellSize);
    const gy = Math.floor(a.y / cellSize);

    // Larger cell size reach: check wider area for bigger orbs
    const reach = Math.ceil((a.radius * 4) / cellSize);
    const searchR = Math.min(reach, 3); // cap search radius

    for (let dy = -searchR; dy <= searchR; dy++) {
      for (let dx = -searchR; dx <= searchR; dx++) {
        const nx = gx + dx, ny = gy + dy;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        let j = grid[ny * gridW + nx];
        while (j !== null) {
          const b = circles[j];
          const nextJ = b._gravNext;
          if (j !== i && b.alive && !b.popped) {
            // Determine which is bigger
            let big, small;
            if (a.radius > b.radius * 1.2) { big = a; small = b; }
            else if (b.radius > a.radius * 1.2) { big = b; small = a; }
            else { j = nextJ; continue; } // too similar in size, skip

            const ddx = big.x - small.x;
            const ddy = big.y - small.y;
            const d = Math.sqrt(ddx * ddx + ddy * ddy);
            // Mid/big balls get 15% bigger gravity radius
            const sizeBonus = big.radius >= BASE_CIRCLE_RADIUS ? 1.15 : 1.0;
            const madPhys = getMadnessPhysicsScale();
            const range = big.radius * 4.5 * sizeBonus * madPhys;

            if (d < range && d > 5) {
              // Gravity strength — scaled by big orb's relative size + madness
              let str = INTER_ORB_GRAVITY * (big.radius / BASE_CIRCLE_RADIUS) * madPhys * dt / Math.max(d, 10);
              // Merged orbs pull harder
              if (big.mergeCount > 1) str *= 1.5;
              // Falloff near edge of range
              const falloff = 1 - (d / range);
              str *= falloff;

              small.vx += (ddx / d) * str;
              small.vy += (ddy / d) * str;
            }
          }
          j = nextJ;
        }
      }
    }
  }

  // Clean up
  for (let i = 0; i < len; i++) {
    circles[i]._gravNext = undefined;
  }
}

// ==================================================
// SECTION 7e: MERGE ANIMATIONS — absorbed orbs melt into survivors
// ==================================================
function updateMergeAnimations(dt) {
  for (let i = G.circles.length - 1; i >= 0; i--) {
    const c = G.circles[i];
    if (c.mergeTarget === null || c.mergeTarget === undefined) continue;

    c.mergeAnimProgress += dt / 0.45; // 0.45s animation duration (was 0.3s)

    const target = findCircleById(c.mergeTarget);
    if (!target || !target.alive) {
      // Target gone — instant kill
      c.alive = false;
      c.popped = true;
      continue;
    }

    // Lerp position toward target (accelerating)
    const t = Math.min(1, c.mergeAnimProgress);
    const easeT = t * t; // ease-in
    c.x = lerp(c.x, target.x, easeT * 0.25);
    c.y = lerp(c.y, target.y, easeT * 0.25);

    // Shrink radius
    c.radius = Math.max(1, c.baseRadius * (1 - t));

    // Stretch factor — increases during merge for ellipse distortion toward target
    c.mergeStretch = t;

    // Emit mass-flow particles toward target (2-3 per frame during merge)
    if (Math.random() < 0.4) {
      const angle = Math.atan2(target.y - c.y, target.x - c.x);
      const spread = (Math.random() - 0.5) * 0.8;
      const speed = 60 + Math.random() * 80;
      spawnParticle(c.x, c.y, 'spark', c.color, {
        vx: Math.cos(angle + spread) * speed,
        vy: Math.sin(angle + spread) * speed,
        maxLife: 0.25, size: 2 + Math.random() * 2, layer: 'fg'
      });
    }

    // Animation complete
    if (t >= 1) {
      c.alive = false;
      c.popped = true;
    }
  }
}

// ==================================================
// SECTION 8: PARTICLE SYSTEM
// ==================================================
const particlePool = [];
for (let i = 0; i < MAX_PARTICLES; i++) {
  particlePool.push({ active: false, type: 'spark', x:0, y:0, vx:0, vy:0, life:0, maxLife:1, size:4, color:'#fff', alpha:1, rotation:0, rotSpeed:0, trail:null, radius:0, w:0, h:0, layer:'fg', gravity:false });
}

// Ambient mote spawner — fills screen with tiny drifting specks
let ambientTimer = 0;
function updateAmbientParticles(dt) {
  // Base rate: spawn ~15 motes/sec, during chain up to ~40/sec
  const baseRate = 15;
  const chainBoost = G.chainActive ? 25 + G.chainCount * 0.5 : 0;
  const rate = baseRate + chainBoost;
  ambientTimer += dt;
  const interval = 1 / rate;
  while (ambientTimer >= interval) {
    ambientTimer -= interval;
    const palette = getCurrentPalette();
    const color = palette.colors[Math.floor(Math.random() * palette.colors.length)];
    const aL = G.gameLeft || 0, aT = G.gameTop || 0;
    const aW = G.gameW || G.W, aH = G.gameH || G.H;
    const x = aL + Math.random() * aW;
    const y = aT + Math.random() * aH;
    const angle = Math.random() * Math.PI * 2;
    const speed = 5 + Math.random() * 15;
    const p = spawnParticle(x, y, 'mote', color, {
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      maxLife: 2.0 + Math.random() * 3.0,
      size: 0.8 + Math.random() * 1.5,
      layer: 'bg'
    });
    if (p) p.gravity = true; // motes respond to gravity wells
  }
}

function acquireParticle() {
  for (let i = 0; i < particlePool.length; i++) {
    if (!particlePool[i].active) { particlePool[i].active = true; return particlePool[i]; }
  }
  return null;
}

function spawnParticle(x, y, type, color, config) {
  const p = acquireParticle();
  if (!p) return;
  p.type = type;
  p.x = x; p.y = y;
  p.vx = config.vx || 0;
  p.vy = config.vy || 0;
  p.life = 1.0;
  p.maxLife = config.maxLife || 1.0;
  p.size = config.size || 4;
  p.color = color;
  p.alpha = 1;
  p.rotation = config.rotation || 0;
  p.rotSpeed = config.rotSpeed || 0;
  p.trail = null;
  p.radius = 0;
  p.w = config.w || 0;
  p.h = config.h || 0;
  p.layer = config.layer || 'fg';
  return p;
}

function spawnPopParticles(x, y, color) {
  const biome = getCurrentBiome();
  const count = 12;

  // Generic sparks
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.4;
    const speed = 80 + Math.random() * 120;
    spawnParticle(x, y, 'spark', color, {
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      maxLife: 0.4 + Math.random() * 0.3,
      size: 2 + Math.random() * 3
    });
  }

  // Extra tiny debris motes — fill the screen with small stuff
  const palette = getCurrentPalette();
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 20 + Math.random() * 50;
    const moteColor = palette.colors[Math.floor(Math.random() * palette.colors.length)];
    const p = spawnParticle(x, y, 'mote', moteColor, {
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      maxLife: 1.5 + Math.random() * 2.5,
      size: 0.6 + Math.random() * 1.2,
      layer: 'bg'
    });
    if (p) p.gravity = true;
  }

  // Biome-specific
  switch(biome.particleType) {
    case 'ripple':
      spawnParticle(x, y, 'ripple', color, { maxLife: 0.8, size: 0, layer: 'bg' });
      break;
    case 'ember':
      for (let i = 0; i < 4; i++) {
        spawnParticle(x + (Math.random()-0.5)*20, y, 'ember', color, {
          vx: (Math.random()-0.5)*30, vy: -40 - Math.random()*40,
          maxLife: 1.2 + Math.random()*0.8, size: 2 + Math.random()*3
        });
      }
      break;
    case 'ribbon':
      for (let i = 0; i < 2; i++) {
        spawnParticle(x, y, 'ribbon', color, {
          vx: (Math.random()-0.5)*40, vy: -20 - Math.random()*30,
          maxLife: 1.0 + Math.random()*0.5, size: 3
        });
      }
      break;
    case 'hex':
      for (let i = 0; i < 3; i++) {
        const a = Math.random() * Math.PI * 2;
        spawnParticle(x, y, 'hex', color, {
          vx: Math.cos(a)*50, vy: Math.sin(a)*50,
          maxLife: 0.7 + Math.random()*0.3, size: 6 + Math.random()*6,
          rotation: Math.random()*Math.PI, rotSpeed: (Math.random()-0.5)*4
        });
      }
      break;
    case 'glitch':
      for (let i = 0; i < 4; i++) {
        spawnParticle(x + (Math.random()-0.5)*30, y + (Math.random()-0.5)*20, 'glitch', color, {
          maxLife: 0.3 + Math.random()*0.4,
          w: 8 + Math.random()*20, h: 2 + Math.random()*6
        });
      }
      break;
    case 'splat':
      // Add to persistent paint splats
      if (G.paintSplats.length < MAX_PAINT_SPLATS) {
        G.paintSplats.push({ x, y, color, size: 10 + Math.random()*15, alpha: 0.3 + Math.random()*0.2, seed: Math.random()*1000 });
      }
      // Also a brief splat particle
      spawnParticle(x, y, 'splat', color, { maxLife: 0.5, size: 12 + Math.random()*8 });
      break;
    case 'star':
      for (let i = 0; i < 3; i++) {
        const a = Math.random() * Math.PI * 2;
        spawnParticle(x, y, 'star', color, {
          vx: Math.cos(a)*60, vy: Math.sin(a)*60,
          maxLife: 0.6 + Math.random()*0.4, size: 4 + Math.random()*5,
          rotation: Math.random()*Math.PI, rotSpeed: (Math.random()-0.5)*5
        });
      }
      break;
  }
}

function updateParticles(dt) {
  for (let i = 0; i < particlePool.length; i++) {
    const p = particlePool[i];
    if (!p.active) continue;

    p.life -= dt / p.maxLife;
    if (p.life <= 0) { p.active = false; p.trail = null; continue; }

    switch(p.type) {
      case 'spark':
        p.vx *= (1 - 3 * dt);
        p.vy *= (1 - 3 * dt);
        p.vy += 50 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.alpha = p.life;
        p.size = Math.max(0.5, p.size * (1 - dt * 2));
        break;
      case 'ripple':
        p.radius += 60 * dt;
        p.alpha = p.life * 0.5;
        break;
      case 'ember':
        p.vy -= 20 * dt;
        p.vx += (Math.random()-0.5) * 80 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.alpha = p.life * (0.7 + 0.3 * Math.sin(G.time * 15 + p.x));
        break;
      case 'ribbon':
        p.vy -= 10 * dt;
        p.vx = Math.sin(G.time * 3 + p.y * 0.02) * 30;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (!p.trail) p.trail = [];
        p.trail.push({x: p.x, y: p.y});
        if (p.trail.length > 15) p.trail.shift();
        p.alpha = p.life * 0.6;
        break;
      case 'hex':
        p.vx *= (1 - 2 * dt);
        p.vy *= (1 - 2 * dt);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rotation += p.rotSpeed * dt;
        p.alpha = p.life;
        break;
      case 'glitch':
        if (Math.random() < 0.15) {
          p.x += (Math.random()-0.5) * 20;
          p.y += (Math.random()-0.5) * 10;
        }
        p.alpha = p.life * (Math.random() > 0.12 ? 1 : 0);
        break;
      case 'splat':
        p.alpha = p.life * 0.6;
        p.size *= (1 + dt * 0.5);
        break;
      case 'star':
        p.vx *= (1 - 2 * dt);
        p.vy *= (1 - 2 * dt);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rotation += p.rotSpeed * dt;
        p.alpha = p.life;
        break;
      case 'mote': {
        // Tiny ambient specks — swirl with gravitational feel
        // Ambient swirl around center
        const mgcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
        const mgcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
        const mgw = G.gameW || G.W, mgh = G.gameH || G.H;
        const mAttrX = mgcx + Math.sin(G.time * 0.13) * mgw * 0.2;
        const mAttrY = mgcy + Math.cos(G.time * 0.11) * mgh * 0.15;
        const mdx = mAttrX - p.x, mdy = mAttrY - p.y;
        const mDist = Math.sqrt(mdx*mdx + mdy*mdy) + 1;
        const mGrav = Math.min(12, 200 / mDist) * dt;
        const mTanX = -mdy / mDist, mTanY = mdx / mDist;
        const mTan = Math.min(10, 150 / mDist) * dt;
        p.vx += (mdx / mDist) * mGrav + mTanX * mTan;
        p.vy += (mdy / mDist) * mGrav + mTanY * mTan;
        // Velocity damping to keep motes from flying off
        p.vx *= (1 - 0.5 * dt);
        p.vy *= (1 - 0.5 * dt);
        p.x += p.vx * dt + Math.sin(G.time * 1.5 + p.y * 0.01) * 2 * dt;
        p.y += p.vy * dt + Math.cos(G.time * 1.2 + p.x * 0.01) * 2 * dt;
        p.alpha = p.life * 0.4;
        // Gravity well attraction for motes
        if (p.gravity) {
          for (let gw = 0; gw < G.gravityWells.length; gw++) {
            const well = G.gravityWells[gw];
            const wdx = well.x - p.x, wdy = well.y - p.y;
            const wd = Math.sqrt(wdx*wdx + wdy*wdy);
            if (wd < well.radius && wd > 2) {
              const pull = well.strength * 0.3 * dt / wd;
              p.vx += wdx * pull;
              p.vy += wdy * pull;
            }
          }
          // Cursor gravity on motes too
          if (G.cursorX > 0 && G.cursorY > 0) {
            const cdx = G.cursorX - p.x, cdy = G.cursorY - p.y;
            const cd = Math.sqrt(cdx*cdx + cdy*cdy) + 1;
            const cPull = Math.min(8, 1000 / (cd * cd + 300)) * dt;
            p.vx += (cdx / cd) * cPull * 3;
            p.vy += (cdy / cd) * cPull * 3;
          }
        }
        // Wrap around visible game edges
        const pL = G.gameLeft || 0, pT = G.gameTop || 0;
        const pR = G.gameRight || G.W, pB = G.gameBottom || G.H;
        if (p.x < pL - 10) p.x = pR + 10;
        if (p.x > pR + 10) p.x = pL - 10;
        if (p.y < pT - 10) p.y = pB + 10;
        if (p.y > pB + 10) p.y = pT - 10;
        break;
      }
    }
  }
}

// ==================================================
// SECTION 9: EXPLOSION SYSTEM
// ==================================================
function createExplosion(x, y, maxRadius, color, isEcho) {
  if (G.explosions.length >= MAX_EXPLOSIONS) G.explosions.shift();
  G.explosions.push({
    x, y,
    radius: 0,
    maxRadius: maxRadius,
    color: color,
    life: 1.0,
    isEcho: isEcho || false,
    flashAlpha: 1.0
  });
}

function updateExplosions(dt) {
  for (let i = G.explosions.length - 1; i >= 0; i--) {
    const e = G.explosions[i];
    e.radius += (e.maxRadius * 3) * dt;
    if (e.radius > e.maxRadius) e.radius = e.maxRadius;
    e.life -= dt * 3;
    e.flashAlpha = Math.max(0, e.flashAlpha - dt * 8);
    if (e.life <= 0) G.explosions.splice(i, 1);
  }
}

// ==================================================
// SECTION 9b: BOMB SYSTEM
// ==================================================
function placeBomb(x, y) {
  G.bombs.push({
    x, y,
    fuse: BOMB_FUSE_TIME,
    maxFuse: BOMB_FUSE_TIME,
    radius: BASE_BLAST_RADIUS * BOMB_BLAST_MULT,
    color: getCurrentPalette().accent
  });
  spawnFloatingText(x, y - 20, 'MINE SET', getCurrentPalette().accent);
  playBombPlaceSound();

  // Attractor Field: mines create a persistent gravity well while fusing
  // Gentle pull — orbs orbit and drift in, fast ones slingshot past
  if (G.upgrades.attractorField > 0) {
    const lvl = G.upgrades.attractorField;
    const aRange = 80 + lvl * 35;
    G.gravityWells.push({
      x, y,
      strength: 20 + lvl * 12,
      radius: aRange,
      life: BOMB_FUSE_TIME,
      maxLife: BOMB_FUSE_TIME,
      color: getCurrentPalette().accent
    });
  }
}

function updateBombs(dt) {
  for (let i = G.bombs.length - 1; i >= 0; i--) {
    const b = G.bombs[i];
    b.fuse -= dt;
    if (b.fuse <= 0) {
      detonateBomb(b);
      G.bombs.splice(i, 1);
    }
  }
}

function detonateBomb(b) {
  createExplosion(b.x, b.y, b.radius, b.color, false);
  G.shakeAmount = Math.max(G.shakeAmount, 6);
  playDelayedBlastExplosion(1);

  // Pop all circles in range — start a chain if not already active
  const wasActive = G.chainActive;
  if (!wasActive) {
    G.chainActive = true;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainQueue = [];
    G.chainOriginX = b.x;
    G.chainOriginY = b.y;
  }

  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    const d = dist(b.x, b.y, c.x, c.y);
    if (d < b.radius + c.radius) {
      c.queued = true;
      const tension = getLinkTensionTime() * (0.4 + 0.3 * (d / b.radius)) + Math.random() * 0.04;
      G.chainLinks.push({
        srcX: b.x, srcY: b.y,
        targetId: c.id,
        color: b.color,
        timer: 0,
        duration: tension
      });
    }
  }

  if (!wasActive && G.chainLinks.length === 0 && G.chainQueue.length === 0) {
    G.chainActive = false;
  }
}

function renderBombs(ctx) {
  for (let i = 0; i < G.bombs.length; i++) {
    const b = G.bombs[i];
    const fuseT = b.fuse / b.maxFuse;
    const urgency = 1 - fuseT;
    const blink = Math.sin(b.fuse * (6 + urgency * 20)) > 0;
    ctx.save();
    // Outer ring — blast radius preview
    ctx.globalAlpha = 0.06 + urgency * 0.08;
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    // Mine body
    ctx.globalAlpha = 0.6 + urgency * 0.4;
    ctx.fillStyle = blink ? b.color : '#ffffff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5 + urgency * 3, 0, Math.PI * 2);
    ctx.fill();
    // Fuse arc
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 10 + urgency * 4, -Math.PI / 2, -Math.PI / 2 + fuseT * Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

function playBombPlaceSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, now);
  osc.frequency.exponentialRampToValueAtTime(150, now + 0.12);
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.18);
}

// ==================================================
// SECTION 10: CHAIN REACTION ENGINE
// ==================================================
function startChain(x, y) {
  G.taps--;
  // If a chain is already active, this tap adds to it instead of starting fresh
  if (!G.chainActive) {
    G.chainActive = true;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainQueue = [];
  }
  G.chainOriginX = x;
  G.chainOriginY = y;

  // Find nearest circle
  let nearestCircle = null, nearDist = Infinity;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    const d = dist(x, y, c.x, c.y);
    if (d < nearDist) { nearDist = d; nearestCircle = c; }
  }

  // Attractor Field: normal taps create brief gravity well
  if (G.upgrades.attractorField > 0) {
    const lvl = G.upgrades.attractorField;
    const aRange = 60 + lvl * 30;
    G.gravityWells.push({
      x, y,
      strength: 50 + lvl * 35,
      radius: aRange,
      life: 0.5 + lvl * 0.15,
      maxLife: 0.5 + lvl * 0.15,
      color: getCurrentPalette().accent
    });
  }

  if (nearestCircle && nearDist < MAX_TAP_DISTANCE + nearestCircle.radius) {
    // Pop the nearest circle immediately
    nearestCircle.queued = true;
    G.chainQueue.push({ circleId: nearestCircle.id, triggerTime: 0 });
  } else {
    // Phantom pop — create a temporary explosion at tap point
    phantomPop(x, y);
  }
  updateHUD();
}

function phantomPop(x, y) {
  const phantomR = getBlastRadius() * 0.7;
  createExplosion(x, y, phantomR, '#ffffff', false);
  playPhantomSound();

  // Still check if anything is in range — create links
  const blastR = phantomR + G.upgrades.novaRadius * 12;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    const d = dist(x, y, c.x, c.y);
    if (d < blastR + c.radius) {
      c.queued = true;
      const distFactor = d / (blastR + c.radius);
      const tension = getLinkTensionTime() * (0.6 + distFactor * 0.4) + Math.random() * 0.08;
      G.chainLinks.push({
        srcX: x, srcY: y,
        targetId: c.id,
        color: '#ffffff',
        timer: 0,
        duration: tension
      });
    }
  }

  if (G.chainLinks.length === 0 && G.chainQueue.length === 0) {
    // Nothing hit, chain ends immediately
    G.chainActive = false;
  }
}

function popCircle(circleId) {
  const circle = findCircleById(circleId);
  if (!circle || circle.popped) return;

  // VOID CRACK orbs: first hit cracks them + creates gravity well pulling orbs in
  if (circle.armored && circle.armorHP > 1) {
    circle.armorHP = 1;
    circle.queued = false; // un-queue so next blast can re-target
    createExplosion(circle.x, circle.y, circle.radius * 2, '#9040ff', true);
    G.shakeAmount = Math.max(G.shakeAmount, 3);
    // Gravity well on crack — pulls nearby orbs inward for juicy chain potential
    G.gravityWells.push({
      x: circle.x, y: circle.y,
      strength: 180,
      radius: getBlastRadius() * 1.8,
      life: 0.8,
      maxLife: 0.8,
      color: '#8030ff'
    });
    playVoidCrackSound();
    return; // don't pop yet
  }
  // VOID CRACK pop: second hit — repulsion burst pushes orbs outward
  if (circle.armored && circle.armorHP === 1) {
    const repulseR = getBlastRadius() * 1.5;
    for (let i = 0; i < G.circles.length; i++) {
      const other = G.circles[i];
      if (other.popped || !other.alive || other.id === circle.id) continue;
      const d = dist(circle.x, circle.y, other.x, other.y);
      if (d < repulseR && d > 3) {
        const dx = other.x - circle.x, dy = other.y - circle.y;
        const pushStr = (1 - d / repulseR) * 250;
        other.vx += (dx / d) * pushStr;
        other.vy += (dy / d) * pushStr;
      }
    }
    createExplosion(circle.x, circle.y, repulseR, '#c060ff', false);
    G.shakeAmount = Math.max(G.shakeAmount, 5);
  }

  circle.popped = true;
  G.chainCount++;
  // Track pop position for directional respawn bias
  G.popCenterX = G.popCenterX * 0.9 + circle.x * 0.1;
  G.popCenterY = G.popCenterY * 0.9 + circle.y * 0.1;
  G.popTrackCount++;
  // XP scales with generation AND orb size — bigger orbs reward more, smaller much less
  // Diminishing returns after 15 pops (was 20)
  const xpValues = [1, 0.5, 0.25, 0.15, 0.08, 0.04];
  const sizeXpScale = Math.max(0.15, (circle.radius / BASE_CIRCLE_RADIUS) * 0.6);
  const baseXp = circle.shrapnel ? 0.15 : (xpValues[circle.generation] || 0.15);
  const dimFactor = G.chainCount <= 15 ? 1.0 : 15 / G.chainCount;
  G.chainXpValue += baseXp * sizeXpScale * dimFactor;

  // Calculate blast radius (scales with level AND orb size)
  const baseR = getBlastRadius();
  const novaBonus = G.upgrades.novaRadius * 12;
  const sizeScale = circle.radius / BASE_CIRCLE_RADIUS; // 1.0 for normal, up to 2.5 for merged
  let blastR = (baseR + novaBonus) * (0.7 + 0.3 * sizeScale);
  if (circle.volatile) blastR *= 3;

  // Super Cell: create persistent gravity well
  if (circle.superCell) {
    G.gravityWells.push({
      x: circle.x, y: circle.y,
      strength: SC_GRAVITY_STRENGTH,
      radius: blastR * 2.5,
      life: SC_GRAVITY_LIFE,
      maxLife: SC_GRAVITY_LIFE,
      color: circle.color
    });
    blastR *= 1.5; // SC has bigger blast
  }

  // Visual explosion
  createExplosion(circle.x, circle.y, blastR, circle.color, false);

  // Audio
  if (circle.superCell) {
    playSCPopSound(G.chainCount);
  } else {
    playPopSound(G.chainCount);
  }

  // Particles
  spawnPopParticles(circle.x, circle.y, circle.color);

  // Feedback escalation
  applyChainFeedback(G.chainCount);

  // Gravity Well: pull nearby orbs toward this pop — gradual falloff, scales with orb size + madness
  if (G.upgrades.gravityWell > 0) {
    const gwMadPhys = getMadnessPhysicsScale();
    const pullStrength = G.upgrades.gravityWell * 22 * sizeScale * gwMadPhys;
    const pullRange = blastR * 2.8 * gwMadPhys;
    for (let i = 0; i < G.circles.length; i++) {
      const other = G.circles[i];
      if (other.popped || !other.alive) continue;
      const d = dist(circle.x, circle.y, other.x, other.y);
      if (d < pullRange && d > 5) {
        const dx = circle.x - other.x, dy = circle.y - other.y;
        // Gradual: inverse distance with smooth edge falloff
        const edgeFade = 1 - (d / pullRange);
        const pull = pullStrength * edgeFade * edgeFade / Math.max(d, 15);
        other.x += (dx / d) * pull * d * 0.5;
        other.y += (dy / d) * pull * d * 0.5;
      }
    }
  }

  // Find neighbors in blast radius — create links instead of instant queue
  for (let i = 0; i < G.circles.length; i++) {
    const other = G.circles[i];
    if (other.popped || other.queued || !other.alive) continue;
    if (other.shrapnelImmune > 0) continue; // shrapnel needs time to fly out
    const d = dist(circle.x, circle.y, other.x, other.y);
    if (d < blastR + other.radius) {
      other.queued = true;
      const distFactor = d / (blastR + other.radius);
      const tension = getLinkTensionTime() * (0.6 + distFactor * 0.4) + Math.random() * 0.08;
      G.chainLinks.push({
        srcX: circle.x, srcY: circle.y,
        targetId: other.id,
        color: circle.color,
        timer: 0,
        duration: tension
      });
    }
  }

  // Boss damage check — chain pops can hurt the boss (size-scaled)
  damageBoss(circle.x, circle.y, blastR, circle.radius);

  // Echo Burst
  if (G.upgrades.echoBurst > 0 && Math.random() < G.upgrades.echoBurst * 0.18) {
    const echoR = blastR * 1.4;
    createExplosion(circle.x, circle.y, echoR, circle.color, true);
    for (let i = 0; i < G.circles.length; i++) {
      const other = G.circles[i];
      if (other.popped || other.queued || !other.alive) continue;
      if (other.shrapnelImmune > 0) continue;
      const d = dist(circle.x, circle.y, other.x, other.y);
      if (d < echoR + other.radius) {
        other.queued = true;
        const tension = getLinkTensionTime() * 0.5 + Math.random() * 0.06;
        G.chainLinks.push({
          srcX: circle.x, srcY: circle.y,
          targetId: other.id,
          color: circle.color,
          timer: 0,
          duration: tension
        });
      }
    }
  }

  // Compute "away from cursor" base angle for directional fragments/shrapnel/fission
  let awayAngle = Math.random() * Math.PI * 2; // fallback: random
  if (G.cursorX > 0 && G.cursorY > 0) {
    awayAngle = Math.atan2(circle.y - G.cursorY, circle.x - G.cursorX);
  }

  // Combo shrapnel: popped balls spawn 40%-size balls LAUNCHED away from cursor
  // Spawned AFTER blast-radius check so they don't get immediately queued/popped
  // These are real gameplay objects — poppable by other blasts, affected by gravity
  // Threshold scales with level (6 early → 2 late), base 2 shrapnel + combo scaling
  const shrapnelThreshold = getShrapnelThreshold();
  if (G.chainCount >= shrapnelThreshold) {
    const baseShrapnel = 1;
    const comboBonus = Math.floor(G.chainCount / 8);
    const shrapnelCount = Math.min(4, Math.floor(baseShrapnel * (1 + comboBonus * 0.4)));
    for (let s = 0; s < shrapnelCount; s++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      const spread = (shrapnelCount > 1) ? ((s / (shrapnelCount - 1)) - 0.5) * Math.PI : 0;
      const angle = awayAngle + spread + (Math.random() - 0.5) * 0.5;
      const speed = 400 + Math.random() * 250;
      const sc = createCircle(circle.x, circle.y);
      sc.radius = BASE_CIRCLE_RADIUS * 0.4 + Math.random() * 3;
      sc.baseRadius = sc.radius;
      sc.generation = 1;
      sc.superCell = false;
      sc.spikeCount = 0;
      sc.scCooldown = 999;
      sc.armored = false; sc.armorHP = 0;  // shrapnel never armored
      sc.vx = Math.cos(angle) * speed;
      sc.vy = Math.sin(angle) * speed;
      sc.spawnAnim = 0;
      sc.shrapnel = true;
      sc.shrapnelImmune = 0.35; // immune to blasts for 350ms so it can fly out visibly
      G.circles.push(sc);
    }
  }

  // Fission (nerfed: gen-1+, max 3, shrapnel XP, blast immunity) — directional
  if (G.upgrades.fission > 0) {
    const fissionCount = Math.min(3, G.upgrades.fission);
    for (let i = 0; i < fissionCount; i++) {
      if (G.circles.length < MAX_CIRCLES) {
        const fSpread = (fissionCount > 1) ? ((i / (fissionCount - 1)) - 0.5) * Math.PI * 0.7 : 0;
        const angle = awayAngle + fSpread + (Math.random() - 0.5) * 0.4;
        const speed = 100 + Math.random() * 60;
        const fc = createCircle(circle.x, circle.y);
        fc.radius = BASE_CIRCLE_RADIUS * 0.6;
        fc.baseRadius = fc.radius;
        fc.generation = Math.max(1, circle.generation + 1); // always at least gen-1
        fc.superCell = false;
        fc.spikeCount = 0;
        fc.scCooldown = 999;
        fc.armored = false; fc.armorHP = 0;
        fc.vx = Math.cos(angle) * speed;
        fc.vy = Math.sin(angle) * speed;
        fc.spawnAnim = 0.5;
        fc.shrapnel = true;  // reduced XP
        fc.shrapnelImmune = 0.2; // blast immunity to prevent instant chain from parent
        G.circles.push(fc);
      }
    }
  }

  // Aftershock — leave lingering hot zone
  if (G.upgrades.aftershock > 0) {
    if (G.aftershocks.length < MAX_AFTERSHOCKS) {
      G.aftershocks.push({
        x: circle.x, y: circle.y,
        radius: blastR * 0.7,
        life: G.upgrades.aftershock * 0.5,
        maxLife: G.upgrades.aftershock * 0.5,
        color: circle.color
      });
    }
  }

  // FRACTURING SYSTEM: Orbs shatter into smaller pieces on pop
  // Fragments fly AWAY from cursor position (cursor-relative direction)
  // Gen 0 (100%) → gen-1 (60%) → gen-2 (35%) → gen-3 (20%) → gen-4 (12%) → gen-5 (7%)
  const nextGen = circle.generation + 1;
  const fracCounts = getFractureCounts();
  const fracCount = fracCounts[circle.generation] || 0;
  if (nextGen <= 5 && fracCount > 0 && G.circles.length < MAX_CIRCLES - 2) {
    const FRAC_SCALES = [1.0, 0.6, 0.35, 0.20, 0.12, 0.07];
    const scale = FRAC_SCALES[nextGen];
    const count = fracCount;
    const speed = 50 + (nextGen * 15);
    for (let m = 0; m < count; m++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      // Spread fragments in a cone centered on "away from cursor" direction
      const spread = (count > 1) ? ((m / (count - 1)) - 0.5) * Math.PI * 0.8 : 0;
      const angle = awayAngle + spread + (Math.random() - 0.5) * 0.6;
      const spawnDist = 6 + Math.random() * 10;
      const mx = circle.x + Math.cos(angle) * spawnDist;
      const my = circle.y + Math.sin(angle) * spawnDist;
      const mc = createCircle(mx, my);
      mc.radius = BASE_CIRCLE_RADIUS * scale + Math.random() * 2;
      mc.baseRadius = mc.radius;
      mc.generation = nextGen;
      mc.superCell = false;
      mc.spikeCount = 0;
      mc.scCooldown = 999;
      mc.armored = false; mc.armorHP = 0;  // fragments never armored
      mc.spawnAnim = 0;
      mc.shrapnelImmune = 0.2; // brief immunity so they fly out visibly
      mc.vx = Math.cos(angle) * speed;
      mc.vy = Math.sin(angle) * speed;
      G.circles.push(mc);
    }
  }

  // CASCADE BURST: gen-1 and gen-2 orbs spawn bonus micro-fragments — directional
  const cascadeCount = getCascadeBurstCount(circle.generation);
  if (cascadeCount > 0 && G.circles.length < MAX_CIRCLES - 2) {
    const MICRO_SCALES = [0, 0.35, 0.18, 0.12]; // gen-1 bursts to 35%, gen-2 to 18%, gen-3 to 12%
    const microScale = MICRO_SCALES[circle.generation] || 0.12;
    const microGen = Math.min(4, circle.generation + 1);
    for (let cb = 0; cb < cascadeCount; cb++) {
      if (G.circles.length >= MAX_CIRCLES) break;
      const angle = awayAngle + (Math.random() - 0.5) * Math.PI * 0.6;
      const speed = 60 + Math.random() * 40;
      const mc = createCircle(circle.x, circle.y);
      mc.radius = BASE_CIRCLE_RADIUS * microScale + Math.random() * 1.5;
      mc.baseRadius = mc.radius;
      mc.generation = microGen;
      mc.superCell = false;
      mc.spikeCount = 0;
      mc.scCooldown = 999;
      mc.armored = false; mc.armorHP = 0;
      mc.spawnAnim = 0;
      mc.shrapnelImmune = 0.25;
      mc.vx = Math.cos(angle) * speed;
      mc.vy = Math.sin(angle) * speed;
      G.circles.push(mc);
    }
  }

  // Mark for removal after chain
  circle.alive = false;
}

function updateAftershocks(dt) {
  for (let a = G.aftershocks.length - 1; a >= 0; a--) {
    const as = G.aftershocks[a];
    as.life -= dt;
    if (as.life <= 0) { G.aftershocks.splice(a, 1); continue; }
    // Aftershocks pop circles that drift into hot zones
    if (G.chainActive) {
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (c.popped || c.queued || !c.alive) continue;
        if (c.shrapnelImmune > 0) continue;
        const d = dist(as.x, as.y, c.x, c.y);
        if (d < as.radius + c.radius) {
          c.queued = true;
          G.chainQueue.push({ circleId: c.id, triggerTime: G.chainTimer + Math.random() * 0.05 });
        }
      }
    }
  }
}

function updateGravityWells(dt) {
  const gwMadPhys = getMadnessPhysicsScale();
  for (let i = G.gravityWells.length - 1; i >= 0; i--) {
    const gw = G.gravityWells[i];
    gw.life -= dt;
    if (gw.life <= 0) { G.gravityWells.splice(i, 1); continue; }
    const progress = 1 - (gw.life / gw.maxLife);
    const pullMult = Math.min(1, progress * 2); // ramps up over first half of life
    for (let j = 0; j < G.circles.length; j++) {
      const c = G.circles[j];
      if (c.popped || !c.alive) continue;
      const d = dist(gw.x, gw.y, c.x, c.y);
      if (d < gw.radius * gwMadPhys && d > 3) {
        const dx = gw.x - c.x, dy = gw.y - c.y;
        const accel = gw.strength * gwMadPhys * pullMult * dt / Math.max(d, 30);
        c.vx += (dx / d) * accel;
        c.vy += (dy / d) * accel;
      }
    }
  }
}

// ==================================================
// BLACK HOLE — Star Control style gravity + compression pop mechanic
// Pulls orbs inward. Orbs compressed near the core build up "mass".
// When enough mass accumulates → free chain pop (gravitational collapse).
// Orbs that touch the event horizon get swallowed (destroyed) and add mass.
// The player can also tap the black hole to trigger an early collapse.
// ==================================================
const BH_VISUAL_RADIUS = 25;           // smaller, subtler visual
const BH_GRAVITY_RADIUS = 420;         // pull range — wider to catch more orbs
const BH_STRENGTH = 1100;               // strong pull for visible orbits
const BH_TANGENT_STRENGTH = 0.55;      // tangential force ratio — creates orbital spin
const BH_COLLAPSE_THRESHOLD = 5;       // swallowed orbs needed for free pop
const BH_SWALLOW_RADIUS_MULT = 0.5;    // fraction of visual radius = swallow zone (smaller = harder to swallow)

function updateBlackHole(dt) {
  if (!G.blackHole) {
    G.blackHoleTimer += dt;
    if (G.blackHoleTimer > 15 + Math.random() * 20) {
      G.blackHoleTimer = 0;
      const margin = 80;
      const bhL = G.gameLeft || 0, bhT = G.gameTop || 0;
      const bhW = G.gameW || G.W, bhH = G.gameH || G.H;
      G.blackHole = {
        x: bhL + margin + Math.random() * (bhW - margin * 2),
        y: bhT + margin + Math.random() * (bhH - margin * 2),
        radius: BH_VISUAL_RADIUS,
        gravityRadius: BH_GRAVITY_RADIUS,
        strength: BH_STRENGTH,
        life: 8 + Math.random() * 8,
        maxLife: 0,
        phase: Math.random() * Math.PI * 2,
        fadeIn: 0,
        mass: 0,             // swallowed orbs count
        collapseReady: false, // true when mass >= threshold
        pulseTime: 0,         // pulse animation when collapse is ready
        dust: []              // star dust particles inside
      };
      // Initialize star dust
      for (let di = 0; di < 25; di++) {
        G.blackHole.dust.push({
          angle: Math.random() * Math.PI * 2,
          dist: 0.3 + Math.random() * 0.6,
          size: 0.5 + Math.random() * 1.5,
          speed: 0.3 + Math.random() * 0.8
        });
      }
      G.blackHole.maxLife = G.blackHole.life;
      spawnFloatingText(G.blackHole.x, G.blackHole.y - 40, 'VOID OPENS', '#8050cc');
    }
    return;
  }

  const bh = G.blackHole;
  bh.phase += dt * 1.2;

  // Update star dust particles — spiral inward, respawn at outer edge
  if (bh.dust) {
    for (let di = 0; di < bh.dust.length; di++) {
      const d = bh.dust[di];
      d.angle += d.speed * dt * 2.5;
      d.dist -= dt * 0.15;
      if (d.dist < 0.05) {
        d.dist = 0.7 + Math.random() * 0.25;
        d.angle = Math.random() * Math.PI * 2;
        d.size = 0.5 + Math.random() * 1.5;
        d.speed = 0.3 + Math.random() * 0.8;
      }
    }
  }

  // Fade in
  if (bh.fadeIn < 1) bh.fadeIn = Math.min(1, bh.fadeIn + dt / 1.2);

  // Black holes progressively corrupt the world — each second adds permanent horror
  // Swallowing orbs accelerates it
  const horrorRate = 0.003 + bh.mass * 0.002; // base + mass bonus
  G.horrorBoost = Math.min(0.6, G.horrorBoost + horrorRate * dt);

  // Countdown life
  bh.life -= dt;
  if (bh.life <= 0) {
    // Dying: if it had mass, release a collapse pop as a parting gift
    if (bh.mass >= BH_COLLAPSE_THRESHOLD) {
      triggerBlackHoleCollapse(bh);
    }
    G.blackHole = null;
    return;
  }

  const fadeOut = bh.life < 1.5 ? bh.life / 1.5 : 1;
  const fadeMult = bh.fadeIn * fadeOut;

  // Check collapse readiness
  if (bh.mass >= BH_COLLAPSE_THRESHOLD && !bh.collapseReady) {
    bh.collapseReady = true;
    bh.pulseTime = 0;
  }
  if (bh.collapseReady) {
    bh.pulseTime += dt;
    // Auto-collapse after 3 seconds of being ready
    if (bh.pulseTime > 3) {
      triggerBlackHoleCollapse(bh);
      G.blackHole = null;
      return;
    }
  }

  // Gravity pull on orbs — Star Control style: adds to velocity for orbital mechanics
  const bhMadPhys = getMadnessPhysicsScale();
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    const dx = bh.x - c.x;
    const dy = bh.y - c.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > bh.gravityRadius * bhMadPhys || d < 3) continue;

    // Radial gravity: 1/d with soft cap — pulls toward center, amplified by madness
    const accel = bh.strength * bhMadPhys * fadeMult * dt / Math.max(d, 20);
    const nx = dx / d;
    const ny = dy / d;
    c.vx += nx * accel;
    c.vy += ny * accel;

    // Tangential force: perpendicular push creates orbital spin
    // Orbs already near the hole spin faster (closer = stronger tangent)
    const tangentAccel = accel * BH_TANGENT_STRENGTH;
    c.vx += (-ny) * tangentAccel;
    c.vy += (nx) * tangentAccel;

    // Swallow: orb touches event horizon → destroyed, adds mass
    if (d < bh.radius * BH_SWALLOW_RADIUS_MULT) {
      c.alive = false;
      c.popped = true;
      bh.mass++;
      // Grow with each orb eaten
      bh.radius = BH_VISUAL_RADIUS + bh.mass * 3;
      bh.gravityRadius = BH_GRAVITY_RADIUS + bh.mass * 15;
      bh.strength = BH_STRENGTH + bh.mass * 80;
      // Tiny visual feedback
      spawnPopParticles(c.x, c.y, c.color);
      // Mass counter feedback
      if (bh.mass >= BH_COLLAPSE_THRESHOLD) {
        spawnFloatingText(bh.x, bh.y - 30, 'TAP TO COLLAPSE', '#e0a0ff');
      } else {
        spawnFloatingText(bh.x, bh.y - 20, `${bh.mass}/${BH_COLLAPSE_THRESHOLD}`, '#c080ff');
      }
    }
  }

  // Gentle pull on bombs too
  for (let i = 0; i < G.bombs.length; i++) {
    const b = G.bombs[i];
    const dx = bh.x - b.x;
    const dy = bh.y - b.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < bh.gravityRadius && d > 8) {
      const pull = bh.strength * 0.2 * fadeMult * dt / Math.max(d, 20);
      b.x += (dx / d) * pull;
      b.y += (dy / d) * pull;
    }
  }
}

// Tapping the black hole triggers an early collapse
function tryTapBlackHole(x, y) {
  if (!G.blackHole) return false;
  const bh = G.blackHole;
  const d = dist(x, y, bh.x, bh.y);
  if (d > bh.radius * 2.5) return false;

  // Tapping it always triggers collapse (even with low mass, but weaker)
  triggerBlackHoleCollapse(bh);
  G.blackHole = null;
  return true; // consumed the tap — don't also pop an orb
}

function triggerBlackHoleCollapse(bh) {
  // Gravitational collapse: free chain pop centered on the black hole
  // Blast radius scales with accumulated mass
  const baseBlast = BASE_BLAST_RADIUS * 0.8;
  const massBonus = bh.mass * 12;
  const collapseR = baseBlast + massBonus;

  // Collapse permanently pushes the world toward horror
  G.horrorBoost = Math.min(0.6, G.horrorBoost + 0.02 + bh.mass * 0.005);

  // Visual explosion
  createExplosion(bh.x, bh.y, collapseR, '#a060ff', false);

  // Sound
  playPopSound(bh.mass);

  // Particles
  spawnPopParticles(bh.x, bh.y, '#a060ff');

  // Screen feedback scales with mass
  if (bh.mass >= 3) {
    G.shakeAmount = Math.min(12, 3 + bh.mass * 1.5);
    G.whiteGlow = Math.min(0.3, bh.mass * 0.04);
  }

  // Pop nearby orbs — this is a FREE chain (no tap cost)
  let poppedCount = 0;
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || c.queued || !c.alive) continue;
    if (c.shrapnelImmune > 0) continue;
    const d = dist(bh.x, bh.y, c.x, c.y);
    if (d < collapseR + c.radius) {
      c.queued = true;
      const tension = getLinkTensionTime() * 0.5 + Math.random() * 0.1;
      G.chainLinks.push({
        srcX: bh.x, srcY: bh.y,
        targetId: c.id,
        color: '#a060ff',
        timer: 0,
        duration: tension
      });
      poppedCount++;
    }
  }

  // If we queued orbs, start a chain reaction (free — no tap deducted)
  if (poppedCount > 0 && !G.chainActive) {
    G.chainActive = true;
    G.chainCount = 0;
    G.chainXpValue = 0;
    G.chainTimer = 0;
    G.chainOriginX = bh.x;
    G.chainOriginY = bh.y;
  }

  // Floating text
  const label = bh.mass >= BH_COLLAPSE_THRESHOLD ? 'COLLAPSE!' : 'SINGULARITY';
  spawnFloatingText(bh.x, bh.y - 30, label, '#c080ff');

  // Free tap reward — always at least +1, +2 if high mass
  const bhTapBonus = bh.mass >= 8 ? 2 : 1;
  G.taps += bhTapBonus;
  spawnFloatingText(bh.x, bh.y - 55, `+${bhTapBonus} TAP${bhTapBonus > 1 ? 'S' : ''}`, '#c080ff');
  playBonusTapSound();
}

// ==================================================
// MAIN BIOME: Whirlwind Effect
// Periodic tangential swirl toward center, chaotic at high madness
// ==================================================
let whirlwindTimer = 0;
let whirlwindActive = 0; // >0 = swirl in progress (seconds remaining)
let whirlwindDir = 1;    // 1=clockwise, -1=counter-clockwise

function updateWhirlwind(dt) {
  // Only active in main biome (not ABYSS — ABYSS has its own pressure wave)
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (isAbyss) return;

  whirlwindTimer += dt;
  const madness = getMadnessAmount();

  // Trigger whirlwind every 10-18 seconds (more frequent at high madness)
  const interval = 14 - madness * 6; // 14s at 0 madness, 8s at full
  if (whirlwindActive <= 0 && whirlwindTimer > interval) {
    whirlwindActive = 1.8 + madness * 0.5; // 1.8-2.3s duration
    whirlwindTimer = 0;
    whirlwindDir = Math.random() < 0.5 ? 1 : -1;
  }

  if (whirlwindActive > 0) {
    whirlwindActive -= dt;
    const maxDur = 1.8 + madness * 0.5;
    const waveStr = Math.sin((maxDur - whirlwindActive) / maxDur * Math.PI); // sine pulse
    const cx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const cy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = c.x - cx, dy = c.y - cy;
      const d = Math.sqrt(dx * dx + dy * dy) + 1;

      // Tangential force (swirl) + slight radial pull inward, amplified by madness
      const swirlStr = waveStr * 50 * getMadnessPhysicsScale() * dt * Math.min(1, d / 200);
      // Tangential: perpendicular to radial direction
      const tx = -dy / d * whirlwindDir;
      const ty = dx / d * whirlwindDir;
      c.vx += tx * swirlStr;
      c.vy += ty * swirlStr;
      // Slight inward pull
      c.vx -= (dx / d) * swirlStr * 0.3;
      c.vy -= (dy / d) * swirlStr * 0.3;

      // At high madness: add chaotic jitter
      if (madness > 0.3) {
        const chaos = (madness - 0.3) * 30 * dt * waveStr;
        c.vx += (Math.random() - 0.5) * chaos;
        c.vy += (Math.random() - 0.5) * chaos;
      }
    }
  }

  // Black hole vortex: when a black hole is active, create persistent localized swirl
  // Strength scales with madness — at low madness it's subtle, at high madness it's a maelstrom
  if (G.blackHole && G.blackHole.fadeIn > 0.5) {
    const bh = G.blackHole;
    const bhFade = bh.fadeIn * (bh.life < 1.5 ? bh.life / 1.5 : 1);
    const vortexRange = bh.gravityRadius * 0.8;
    const vortexStr = (30 + madness * 80) * bhFade * dt; // subtle at 0 madness, fierce at 1.0
    const vortexDir = Math.sign(Math.sin(bh.phase * 0.3)) || 1;

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = c.x - bh.x, dy = c.y - bh.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < 3 || d > vortexRange) continue;
      // Tangential swirl — stronger closer to center
      const falloff = 1 - d / vortexRange;
      const sStr = vortexStr * falloff * falloff;
      const nx = dx / d, ny = dy / d;
      c.vx += (-ny) * vortexDir * sStr;
      c.vy += (nx) * vortexDir * sStr;
    }
  }
}

// ==================================================
// ABYSS MECHANIC: Abyssal Pressure Waves
// Periodic crushing waves push all orbs toward screen center
// Creates dense clusters for chain reactions
// ==================================================
let abyssPressureTimer = 0;
let abyssPressureWave = 0; // 0 = no wave, >0 = wave in progress

function updateAbyssalPressure(dt) {
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (!isAbyss) return;

  abyssPressureTimer += dt;

  // Trigger a pressure wave every 8-14 seconds
  if (abyssPressureWave <= 0 && abyssPressureTimer > 8 + Math.random() * 6) {
    abyssPressureWave = 1.5; // 1.5 second wave
    abyssPressureTimer = 0;
    playAbyssWooshSound();
  }

  if (abyssPressureWave > 0) {
    abyssPressureWave -= dt;
    const waveStr = Math.sin((1.5 - abyssPressureWave) / 1.5 * Math.PI); // sine pulse
    const cx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const cy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;

    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive) continue;
      const dx = cx - c.x, dy = cy - c.y;
      const d = Math.sqrt(dx * dx + dy * dy) + 1;
      // Push toward center with strength proportional to distance from center
      const pushStr = waveStr * 80 * dt * Math.min(1, d / 200);
      c.vx += (dx / d) * pushStr;
      c.vy += (dy / d) * pushStr;
    }
  }

  // Gentle underwater current — horizontal sine drift
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    const currentStr = 8 * dt;
    const currentAngle = Math.sin(G.time * 0.1 + c.y * 0.003) * 0.3;
    c.vx += Math.cos(currentAngle) * currentStr;
    c.vy += Math.sin(currentAngle) * currentStr * 0.3;
  }
}

function renderBlackHole(ctx) {
  if (!G.blackHole) return;
  const bh = G.blackHole;
  const fadeOut = bh.life < 1.5 ? bh.life / 1.5 : 1;
  const alpha = bh.fadeIn * fadeOut;
  const r = bh.radius;
  if (r * alpha < 1) return;

  ctx.save();

  // Subtle gravity field hint
  ctx.globalAlpha = alpha * 0.025;
  const fieldGrad = ctx.createRadialGradient(bh.x, bh.y, r, bh.x, bh.y, bh.gravityRadius * 0.6);
  fieldGrad.addColorStop(0, '#6030ff');
  fieldGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = fieldGrad;
  ctx.beginPath();
  ctx.arc(bh.x, bh.y, bh.gravityRadius * 0.6, 0, Math.PI * 2);
  ctx.fill();

  // Event horizon — black center with soft violet edge
  ctx.globalAlpha = alpha * 0.9;
  const horizonGrad = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, r);
  horizonGrad.addColorStop(0, '#000000');
  horizonGrad.addColorStop(0.6, '#050008');
  horizonGrad.addColorStop(0.85, '#180030');
  horizonGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = horizonGrad;
  ctx.beginPath();
  ctx.arc(bh.x, bh.y, r, 0, Math.PI * 2);
  ctx.fill();

  // Star dust — tiny particles spiraling inside the event horizon
  if (bh.dust) {
    const dustColors = ['#ffffff', '#aaccff', '#ffd080', '#c0a0ff'];
    for (let s = 0; s < bh.dust.length; s++) {
      const d = bh.dust[s];
      const dx = bh.x + Math.cos(d.angle) * d.dist * r;
      const dy = bh.y + Math.sin(d.angle) * d.dist * r;
      ctx.globalAlpha = alpha * d.dist * 0.8;
      ctx.fillStyle = dustColors[s % dustColors.length];
      ctx.beginPath();
      ctx.arc(dx, dy, d.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Thin bright edge
  ctx.globalAlpha = alpha * 0.35;
  ctx.strokeStyle = '#7040aa';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.arc(bh.x, bh.y, r * 0.8, 0, Math.PI * 2);
  ctx.stroke();

  // Collapse-ready pulse
  if (bh.collapseReady) {
    const pulseT = bh.pulseTime * 3;
    const pulseAlpha = 0.15 + 0.15 * Math.sin(pulseT);
    ctx.globalAlpha = alpha * pulseAlpha;
    ctx.strokeStyle = '#e0a0ff';
    ctx.lineWidth = 2;
    const pulseR = r * (1.5 + 0.3 * Math.sin(pulseT * 0.7));
    ctx.beginPath();
    ctx.arc(bh.x, bh.y, pulseR, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.restore();
}

function updateChainLinks(dt) {
  for (let i = G.chainLinks.length - 1; i >= 0; i--) {
    const link = G.chainLinks[i];
    link.timer += dt;
    const target = findCircleById(link.targetId);
    if (!target || target.popped) {
      G.chainLinks.splice(i, 1);
      continue;
    }
    // Pull target toward source point
    const d = dist(link.srcX, link.srcY, target.x, target.y);
    if (d > 2) {
      const progress = Math.min(link.timer / link.duration, 1);
      const pull = LINK_PULL_STRENGTH * progress * progress * dt;
      const dx = link.srcX - target.x;
      const dy = link.srcY - target.y;
      target.x += (dx / d) * pull;
      target.y += (dy / d) * pull;
    }
    // When tension time is up, pop the target
    if (link.timer >= link.duration) {
      G.chainLinks.splice(i, 1);
      if (!target.popped) {
        G.chainQueue.push({ circleId: target.id, triggerTime: G.chainTimer });
      }
    }
  }
}

function updateChainReaction(dt) {
  if (!G.chainActive) return;

  G.chainTimer += dt;

  // If delayed blast is active, only update that (chain is frozen)
  if (G.delayedBlast) {
    updateDelayedBlast(dt);
    return;
  }

  updateChainLinks(dt);

  let poppedThisFrame = false;
  for (let i = G.chainQueue.length - 1; i >= 0; i--) {
    const entry = G.chainQueue[i];
    if (G.chainTimer >= entry.triggerTime) {
      G.chainQueue.splice(i, 1);
      const circle = findCircleById(entry.circleId);
      if (!circle || circle.popped) continue;
      popCircle(entry.circleId);
      poppedThisFrame = true;
    }
  }

  // Chain ends when queue is empty, no links active, no delayed blast, and no pops this frame
  if (G.chainQueue.length === 0 && G.chainLinks.length === 0 && !G.delayedBlast && !poppedThisFrame) {
    endChain();
  }
}

function endChain() {
  G.chainActive = false;
  G.tapTimer = G.tapTimerMax; // Reset timer after chain
  const count = G.chainCount;
  if (count > G.bestChain) G.bestChain = count;

  // Score — base = count², boosted by level multiplier (1.0 at lvl1, grows 10% per level)
  // Score: quadratic up to 30 pops, then linear growth (prevents mega-score explosions)
  const levelMult = 1 + (G.level - 1) * 0.1;
  const rawScore = count <= 30 ? count * count : (900 + (count - 30) * 30);
  G.score += Math.floor(rawScore * levelMult);

  // Progressive zoom: 2.0 at score 0 → 0.5 at score ~200000
  G.zoomTarget = Math.max(0.5, 2.0 - G.score * (1.5 / 200000));

  // XP (shrapnel balls worth 25%)
  G.xp += Math.floor(G.chainXpValue);

  // Bonus taps — level-scaled thresholds (harder early, easier late)
  const bt = getBonusTapThresholds();
  let bonus = 0;
  if (count >= bt.big) bonus = 2;
  else if (count >= bt.mid) bonus = 1;
  else if (count >= bt.small && Math.random() < bt.smallChance) bonus = 1;

  if (bonus > 0) {
    const fuelMult = 1 + G.upgrades.chainFuel * 0.3;
    bonus = Math.ceil(bonus * fuelMult);
    G.taps += bonus;
    playBonusTapSound();
    spawnFloatingText(G.W / 2, G.H * 0.3, `+${bonus} TAP${bonus > 1 ? 'S' : ''}`, '#00ffa0');
  }

  // Clean up
  G.circles = G.circles.filter(c => c.alive && !c.popped);
  G.circles.forEach(c => { c.queued = false; });

  // FIELD CLEAR CHECK: if all orbs are gone → mega explosion + boss damage + advance
  if (G.circles.length === 0) {
    const clearCx = (G.gameLeft + G.gameRight) * 0.5 || G.W * 0.5;
    const clearCy = (G.gameTop + G.gameBottom) * 0.5 || G.H * 0.5;
    const megaR = Math.max(G.gameW || G.W, G.gameH || G.H) * 0.6;
    createExplosion(clearCx, clearCy, megaR, '#ffffff', false);
    G.shakeAmount = Math.max(G.shakeAmount, 15);
    G.whiteGlow = 1.0;
    G.chromaticAb = 8;
    playBossDeathSound();
    // Damage boss heavily (5 HP)
    if (G.boss && G.boss.state !== 'dying') {
      for (let dmg = 0; dmg < 5; dmg++) {
        damageBoss(clearCx, clearCy, megaR, BASE_CIRCLE_RADIUS * 3); // field clear = max damage
        G.boss.hitCooldown = 0; // reset cooldown between hits
      }
    }
    advanceBiome();
    spawnFloatingText(clearCx, clearCy - 50, 'FIELD CLEARED!', '#ffffff');
    // Big bonus taps for clearing the field
    G.taps += 3;
    playBonusTapSound();
    spawnFloatingText(clearCx, clearCy + 20, '+3 TAPS', '#ffffff');
  }

  // Refill
  refillCircles();

  // Check level-up
  checkLevelUp();

  // Check game over
  if (G.taps <= 0 && !G.pendingLevelUp) {
    G.state = 'game_over';
    showGameOver();
  }

  updateHUD();
}

function applyChainFeedback(chainIndex) {
  if (chainIndex >= 6) {
    G.shakeAmount = Math.min(14, 1 + (chainIndex - 6) * 0.4);
  }
  if (chainIndex >= 20) {
    G.chromaticAb = Math.min(6, 1.5 + (chainIndex - 20) * 0.3);
  }
  if (chainIndex >= 40) {
    G.whiteGlow = Math.min(0.6, 0.1 + (chainIndex - 40) * 0.04);
  }

  // Trigger tiered delayed blast at threshold crossings
  if (!G.delayedBlast) {
    let tier = 0, duration = 0, scale = 1;
    if (chainIndex === DELAYED_BLAST_MEGA) {
      tier = 3; duration = 0.75; scale = 0.05;
    } else if (chainIndex === DELAYED_BLAST_MAJOR) {
      tier = 2; duration = 0.5; scale = 0.12;
    } else if (chainIndex === DELAYED_BLAST_MINOR) {
      tier = 1; duration = 0.25; scale = 0.25;
    }
    if (tier > 0) {
      triggerDelayedBlast(tier, duration, scale);
    }
  }
}

function triggerDelayedBlast(tier, duration, targetTimeScale) {
  // Collect all pending targets (from links + queue)
  const targetIds = [];
  let cx = 0, cy = 0, count = 0;
  for (let i = 0; i < G.chainLinks.length; i++) {
    const t = findCircleById(G.chainLinks[i].targetId);
    if (t && !t.popped) {
      targetIds.push(t.id);
      cx += t.x; cy += t.y; count++;
    }
  }
  for (let i = 0; i < G.chainQueue.length; i++) {
    const t = findCircleById(G.chainQueue[i].circleId);
    if (t && !t.popped) {
      targetIds.push(t.id);
      cx += t.x; cy += t.y; count++;
    }
  }
  if (count === 0) return;
  cx /= count; cy /= count;

  G.delayedBlast = {
    tier, duration, targetTimeScale,
    timer: 0,
    centerX: cx, centerY: cy,
    targetIds,
    executed: false
  };

  // Freeze: clear queue and links so nothing pops during buildup
  G.chainQueue = [];
  G.chainLinks = [];

  // Mark targets as still queued so they don't get picked up again
  for (const id of targetIds) {
    const c = findCircleById(id);
    if (c) c.queued = true;
  }

  playDelayedBlastBuildup(tier, duration);
}

function updateDelayedBlast(dt) {
  if (!G.delayedBlast) return;
  const db = G.delayedBlast;

  // Use raw dt for buildup so slo-mo doesn't make it take forever
  db.timer += G.rawDt;

  const progress = Math.min(db.timer / db.duration, 1);

  // Slo-mo ramps down then snaps back at detonation
  G.timeScale = lerp(db.targetTimeScale, 0.02, progress * progress);

  // Pull all targets toward convergence center
  const pullForce = 80 + 200 * progress * progress;
  for (const id of db.targetIds) {
    const c = findCircleById(id);
    if (!c || c.popped) continue;
    const d = dist(db.centerX, db.centerY, c.x, c.y);
    if (d > 2) {
      const dx = db.centerX - c.x;
      const dy = db.centerY - c.y;
      c.x += (dx / d) * pullForce * G.rawDt;
      c.y += (dy / d) * pullForce * G.rawDt;
    }
  }

  // Darkening overlay intensity
  db.darkness = progress * (db.tier === 3 ? 0.6 : db.tier === 2 ? 0.4 : 0.2);

  // Execute at end
  if (db.timer >= db.duration) {
    executeDelayedBlast();
  }
}

function executeDelayedBlast() {
  const db = G.delayedBlast;
  if (!db || db.executed) return;
  db.executed = true;

  // Pop all targets simultaneously
  for (const id of db.targetIds) {
    const c = findCircleById(id);
    if (c && !c.popped) {
      popCircle(id);
    }
  }

  // Massive visual feedback based on tier
  const shakeAmt = db.tier === 3 ? 25 : db.tier === 2 ? 16 : 8;
  G.shakeAmount = shakeAmt;
  G.chromaticAb = db.tier === 3 ? 8 : db.tier === 2 ? 5 : 2;
  if (db.tier >= 2) G.whiteGlow = db.tier === 3 ? 0.8 : 0.4;

  // Big explosion at center
  const radius = db.tier === 3 ? 300 : db.tier === 2 ? 200 : 120;
  createExplosion(db.centerX, db.centerY, radius, getCurrentPalette().accent, false);

  // Restore time
  G.timeScale = 1.0;

  playDelayedBlastExplosion(db.tier);

  G.delayedBlast = null;
}

// ==================================================
// SECTION 10d: BOSS SYSTEM
// ==================================================

// --- Boss Audio ---
function playBossSpawnSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(40, now);
  osc.frequency.exponentialRampToValueAtTime(200, now + 1.0);
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.linearRampToValueAtTime(0.15, now + 0.4);
  gain.gain.linearRampToValueAtTime(0.12, now + 0.8);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 1.3);
  // Sub rumble
  const sub = G.audioCtx.createOscillator();
  const subG = G.audioCtx.createGain();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(25, now);
  subG.gain.setValueAtTime(0.12, now);
  subG.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
  sub.connect(subG);
  subG.connect(G.audioCtx.destination);
  sub.start(now);
  sub.stop(now + 1.6);
}

function playBossHitSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  const osc = G.audioCtx.createOscillator();
  const gain = G.audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(80, now);
  osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc.connect(gain);
  gain.connect(G.audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.25);
}

function playBossDeathSound() {
  if (!G.audioCtx) return;
  const now = G.audioCtx.currentTime;
  // Bass boom
  const bass = G.audioCtx.createOscillator();
  const bassG = G.audioCtx.createGain();
  bass.type = 'sine';
  bass.frequency.setValueAtTime(50, now);
  bass.frequency.exponentialRampToValueAtTime(20, now + 0.5);
  bassG.gain.setValueAtTime(0.2, now);
  bassG.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  bass.connect(bassG);
  bassG.connect(G.audioCtx.destination);
  bass.start(now);
  bass.stop(now + 0.7);
  // Mid crunch
  const mid = G.audioCtx.createOscillator();
  const midG = G.audioCtx.createGain();
  mid.type = 'sawtooth';
  mid.frequency.setValueAtTime(200, now);
  mid.frequency.exponentialRampToValueAtTime(60, now + 0.3);
  midG.gain.setValueAtTime(0.08, now);
  midG.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
  mid.connect(midG);
  midG.connect(G.audioCtx.destination);
  mid.start(now);
  mid.stop(now + 0.4);
  // High shimmer
  const hi = G.audioCtx.createOscillator();
  const hiG = G.audioCtx.createGain();
  hi.type = 'sine';
  hi.frequency.setValueAtTime(800, now + 0.1);
  hi.frequency.exponentialRampToValueAtTime(2000, now + 0.6);
  hiG.gain.setValueAtTime(0.001, now);
  hiG.gain.linearRampToValueAtTime(0.06, now + 0.15);
  hiG.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
  hi.connect(hiG);
  hiG.connect(G.audioCtx.destination);
  hi.start(now);
  hi.stop(now + 0.9);
}

// --- Boss Spawning (madness-gated) ---
// Phase 1: spawns at ~50% madness (half-madness) — normal boss
// Phase 2: spawns at ~90% madness (peak) — erratic, bizarre variant
// After killing both, cycle repeats with scaling difficulty
function trySpawnBoss(dt) {
  if (G.boss || G.pendingLevelUp) return;

  const madness = getMadnessAmount();

  // Determine which boss phase we're in
  // bossSpawnPhase: 0=waiting for first, 1=killed first waiting for peak, 2=both killed → cycle
  const phase = G.bossKillCount % 2; // 0=next is mid-madness, 1=next is peak-madness
  const madnessThreshold = phase === 0 ? 0.45 : 0.88;

  if (madness < madnessThreshold) return;

  // Cooldown timer after killing previous boss (15s grace period)
  G.bossTimer += dt;
  if (G.bossTimer < 15) return;
  G.bossTimer = 0;

  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const bossType = isAbyss ? 'leviathan' : 'nexus';
  const isPeakBoss = phase === 1; // erratic variant
  const baseHP = bossType === 'leviathan' ? 10 : 8;
  const peakBonus = isPeakBoss ? 15 : 0;
  const hp = baseHP + G.level * 3 + G.bossKillCount * 2 + peakBonus;

  // Spawn at random visible game edge
  let sx, sy;
  const bL = G.gameLeft || 0, bT = G.gameTop || 0;
  const bR = G.gameRight || G.W, bB = G.gameBottom || G.H;
  const edge = Math.floor(Math.random() * 4);
  if (edge === 0) { sx = bL + Math.random() * (bR - bL); sy = bT - 60; }
  else if (edge === 1) { sx = bR + 60; sy = bT + Math.random() * (bB - bT); }
  else if (edge === 2) { sx = bL + Math.random() * (bR - bL); sy = bB + 60; }
  else { sx = bL - 60; sy = bT + Math.random() * (bB - bT); }

  // Generate eye phases — peak boss has MORE eyes, erratic blink
  const baseEyeCount = bossType === 'nexus' ? (6 + Math.floor(Math.random() * 5)) : 2;
  const eyeCount = isPeakBoss ? baseEyeCount + 6 : baseEyeCount;
  const eyePhases = [];
  for (let i = 0; i < eyeCount; i++) {
    eyePhases.push({
      angle: (i / eyeCount) * Math.PI * 2 + Math.random() * 0.5,
      dist: isPeakBoss ? (0.2 + Math.random() * 0.5) : (0.3 + Math.random() * 0.35),
      size: isPeakBoss ? (0.08 + Math.random() * 0.15) : (0.12 + Math.random() * 0.08),
      blinkPhase: Math.random() * 10,
      blinkSpeed: isPeakBoss ? (1.5 + Math.random() * 3.0) : (0.8 + Math.random() * 0.6)
    });
  }

  // Generate tentacles — peak Leviathan has MORE, longer tentacles
  const baseTentCount = bossType === 'leviathan' ? (4 + Math.floor(Math.random() * 3)) : 0;
  const tentCount = isPeakBoss ? baseTentCount + 3 : baseTentCount;
  const tentacles = [];
  for (let i = 0; i < tentCount; i++) {
    tentacles.push({
      angle: (i / tentCount) * Math.PI * 2 + Math.random() * 0.3,
      length: isPeakBoss ? 1.4 : 1.0,
      hp: isPeakBoss ? 3 : 2,
      maxHp: isPeakBoss ? 3 : 2,
      grabTarget: null,
      regrowTimer: 0,
      phase: Math.random() * Math.PI * 2
    });
  }

  G.boss = {
    type: bossType,
    x: sx, y: sy,
    targetX: G.W * (0.3 + Math.random() * 0.4),
    targetY: G.H * (0.3 + Math.random() * 0.4),
    radius: isPeakBoss ? 140 : 55,
    hp: hp, maxHp: hp,
    phase: 0,
    spawnAnim: 1.0,
    state: 'idle',
    stateTimer: isPeakBoss ? 1.0 : 3 + Math.random() * 2,
    hitCooldown: 0,
    hitFlash: 0,
    eyePhases: eyePhases,
    tentacles: tentacles,
    mawOpen: 0,
    orbitAngle: Math.random() * Math.PI * 2,
    dyingTimer: 0,
    erratic: isPeakBoss  // flag for erratic behavior
  };

  const name = isPeakBoss
    ? (bossType === 'nexus' ? 'THE NEXUS WRITHES' : 'LEVIATHAN CONSUMES')
    : (bossType === 'nexus' ? 'NEXUS EMERGES' : 'LEVIATHAN RISES');
  spawnFloatingText(G.W / 2, G.H * 0.3, name, bossType === 'nexus' ? '#d050ff' : '#00e5ff');
  playBossSpawnSound();
  G.shakeAmount = Math.max(G.shakeAmount, isPeakBoss ? 12 : 6);
}

// --- Boss Update ---
function updateBoss(dt) {
  if (!G.boss) {
    trySpawnBoss(dt);
    return;
  }

  const b = G.boss;
  b.phase += dt;
  b.hitCooldown = Math.max(0, b.hitCooldown - dt);
  b.hitFlash = Math.max(0, b.hitFlash - dt * 5);

  // Boss slowly regenerates health — forces player to focus on boss
  if (b.state !== 'dying' && b.hp < b.maxHp && b.hitCooldown <= 0) {
    b.regenTimer = (b.regenTimer || 0) + dt;
    const regenRate = b.erratic ? 4.0 : 6.0; // erratic boss regens faster (every 4s vs 6s)
    if (b.regenTimer >= regenRate) {
      b.regenTimer = 0;
      b.hp = Math.min(b.maxHp, b.hp + 1);
      spawnFloatingText(b.x, b.y - b.radius - 20, '+1 HP',
        b.type === 'nexus' ? '#8030a0' : '#006080');
    }
  } else {
    b.regenTimer = 0; // reset timer when being hit
  }

  // Spawn animation — slide toward target position
  if (b.spawnAnim > 0) {
    b.spawnAnim = Math.max(0, b.spawnAnim - dt * 0.8);
    b.x = lerp(b.x, b.targetX, dt * 1.5);
    b.y = lerp(b.y, b.targetY, dt * 1.5);
    return;
  }

  // Death animation
  if (b.state === 'dying') {
    b.dyingTimer += dt;
    const deathDur = b.type === 'leviathan' ? 2.0 : 1.5;
    if (b.dyingTimer >= deathDur) {
      // Boss dies — reward player
      const reward = 3;
      G.taps += reward;
      spawnFloatingText(b.x, b.y - 40, '+' + reward + ' TAPS', '#00ffa0');

      // XP reward
      const xpReward = G.level * 5;
      G.chainXpValue += xpReward;

      // Mega explosion — pop nearby orbs for FREE
      const blastR = getBlastRadius() * 2;
      createExplosion(b.x, b.y, blastR, b.type === 'nexus' ? '#d050ff' : '#00e5ff', false);
      G.shakeAmount = Math.max(G.shakeAmount, 12);

      // Pop orbs in range (free, no tap cost)
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (c.popped || !c.alive || c.queued) continue;
        const d = dist(b.x, b.y, c.x, c.y);
        if (d < blastR + c.radius) {
          c.queued = true;
          G.chainQueue.push({ circleId: c.id, triggerTime: G.chainTimer + Math.random() * 0.15 });
          if (!G.chainActive) {
            G.chainActive = true;
            G.chainCount = 0;
            G.chainXpValue = 0;
            G.chainTimer = 0;
          }
        }
      }

      const deathMsg = b.type === 'nexus' ? 'NEXUS DESTROYED' : 'LEVIATHAN FALLS';
      spawnFloatingText(b.x, b.y, deathMsg, '#ffffff');
      playBossDeathSound();
      G.bossKillCount++;
      G.boss = null;
      G.bossTimer = 0;
      return;
    }
    // Death anim: expand and fade
    b.radius = 55 + b.dyingTimer * 40;
    return;
  }

  // Movement — orbit around shifting center (uses game boundaries)
  const gcx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
  const gcy = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.5;
  const gw = G.gameW || G.W, gh = G.gameH || G.H;
  const bossGL = G.gameLeft || 0, bossGT = G.gameTop || 0;
  const bossGR = G.gameRight || G.W, bossGB = G.gameBottom || G.H;

  if (b.erratic) {
    // ERRATIC BOSS: fast, jerky, unpredictable movement
    b.orbitAngle += dt * (1.2 + Math.sin(b.phase * 3.7) * 0.8);
    const chaosX = Math.sin(b.phase * 2.3) * gw * 0.3 + Math.cos(b.phase * 4.1) * gw * 0.1;
    const chaosY = Math.cos(b.phase * 1.7) * gh * 0.25 + Math.sin(b.phase * 3.3) * gh * 0.1;
    const orbitR = 100 + Math.sin(b.phase * 1.5) * 120;
    b.targetX = gcx + chaosX + Math.cos(b.orbitAngle) * orbitR;
    b.targetY = gcy + chaosY + Math.sin(b.orbitAngle) * orbitR;
    // Clamp to game area
    b.targetX = Math.max(bossGL + 40, Math.min(bossGR - 40, b.targetX));
    b.targetY = Math.max(bossGT + 40, Math.min(bossGB - 40, b.targetY));
    // Faster tracking (jerky)
    b.x = lerp(b.x, b.targetX, dt * 2.5);
    b.y = lerp(b.y, b.targetY, dt * 2.5);
    // Pulsing size distortion
    b.radius = 140 + Math.sin(b.phase * 4) * 20;
  } else if (b.type === 'nexus') {
    b.orbitAngle += dt * 0.3;
    const ncx = gcx + Math.sin(b.phase * 0.07) * gw * 0.15;
    const ncy = gcy + Math.cos(b.phase * 0.09) * gh * 0.1;
    const orbitR = 150 + Math.sin(b.phase * 0.2) * 80;
    b.targetX = ncx + Math.cos(b.orbitAngle) * orbitR;
    b.targetY = ncy + Math.sin(b.orbitAngle) * orbitR;
    b.x = lerp(b.x, b.targetX, dt * 0.8);
    b.y = lerp(b.y, b.targetY, dt * 0.8);
  } else {
    // Leviathan: slow drift + vertical bob
    b.orbitAngle += dt * 0.15;
    b.targetX = gcx + Math.sin(b.orbitAngle) * gw * 0.25;
    b.targetY = gcy + Math.sin(b.phase * 0.5) * 60;
    b.x = lerp(b.x, b.targetX, dt * 0.8);
    b.y = lerp(b.y, b.targetY, dt * 0.8);
  }

  // State machine — erratic boss cycles much faster with chaotic timing
  b.stateTimer -= dt;
  if (b.stateTimer <= 0) {
    if (b.erratic) {
      // Erratic: rapid random state changes
      const states = b.type === 'nexus'
        ? ['idle', 'absorbing', 'shielding', 'absorbing', 'idle']
        : ['idle', 'grabbing', 'pressure', 'grabbing', 'idle'];
      b.state = states[Math.floor(Math.random() * states.length)];
      b.stateTimer = 0.5 + Math.random() * 1.5; // very fast cycling
    } else {
      // Normal: predictable cycle
      if (b.state === 'idle') {
        b.state = b.type === 'nexus' ? 'absorbing' : 'grabbing';
        b.stateTimer = b.type === 'nexus' ? 2.0 : 2.5;
      } else if (b.state === 'absorbing' || b.state === 'grabbing') {
        b.state = b.type === 'nexus' ? 'shielding' : 'pressure';
        b.stateTimer = b.type === 'nexus' ? 3.0 : 1.5;
      } else {
        b.state = 'idle';
        b.stateTimer = 3 + Math.random() * 2;
      }
    }
  }

  // --- ERRATIC (PEAK) BOSS: CONTINUOUS HUNGER — eats balls in ALL states ---
  if (b.erratic && b.state !== 'dying') {
    const hungerRange = 280; // massive pull range
    const hungerStr = 160;
    const swallowDist = b.radius * 0.6;
    b.orbsEaten = b.orbsEaten || 0;
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive || c.queued) continue;
      const d = dist(b.x, b.y, c.x, c.y);
      if (d < hungerRange && d > 3) {
        const dx = b.x - c.x, dy = b.y - c.y;
        // Relentless pull — gets stronger as orbs get closer
        const pull = hungerStr * dt / Math.max(d, 10);
        c.vx += (dx / d) * pull;
        c.vy += (dy / d) * pull;
        // Devour orbs that touch — heals AND grows stronger
        if (d < swallowDist) {
          c.alive = false; c.popped = true;
          b.orbsEaten++;
          spawnPopParticles(c.x, c.y, '#ff2040');
          // Heal from eating
          b.hp = Math.min(b.maxHp, b.hp + 1);
          // Every 3 orbs eaten: gain +1 max HP (boss gets tougher)
          if (b.orbsEaten % 3 === 0) {
            b.maxHp++;
            b.hp = Math.min(b.maxHp, b.hp + 1);
            spawnFloatingText(b.x, b.y - b.radius - 25, 'BOSS GROWS', '#ff3050');
          }
          // Grow slightly bigger with each meal
          b.radius = Math.min(200, b.radius + 0.5);
          G.shakeAmount = Math.max(G.shakeAmount, 2);
        }
      }
    }
  }

  // --- Nexus behaviors ---
  if (b.type === 'nexus' && b.state === 'absorbing' && !b.erratic) {
    // Pull nearby orbs toward boss (gravity well) — normal nexus only
    const absorbRange = 120;
    const absorbStr = 60;
    for (let i = 0; i < G.circles.length; i++) {
      const c = G.circles[i];
      if (c.popped || !c.alive || c.queued) continue;
      const d = dist(b.x, b.y, c.x, c.y);
      if (d < absorbRange && d > 5) {
        const dx = b.x - c.x, dy = b.y - c.y;
        const pull = absorbStr * dt / Math.max(d, 15);
        c.vx += (dx / d) * pull;
        c.vy += (dy / d) * pull;
        // Swallow if very close
        if (d < b.radius * 0.5 && b.hp < b.maxHp) {
          c.alive = false; c.popped = true;
          b.hp = Math.min(b.maxHp, b.hp + 1);
          spawnPopParticles(c.x, c.y, c.color);
        }
      }
    }
  }

  // --- Leviathan behaviors ---
  if (b.type === 'leviathan') {
    // Update tentacles
    for (let t = 0; t < b.tentacles.length; t++) {
      const tent = b.tentacles[t];
      tent.phase += dt * 1.5;

      // Regrow severed tentacles
      if (tent.hp <= 0) {
        tent.regrowTimer += dt;
        if (tent.regrowTimer >= 5) {
          tent.hp = tent.maxHp;
          tent.regrowTimer = 0;
          tent.length = 1.0;
        }
        continue;
      }

      if (b.state === 'grabbing' || b.erratic) {
        // Extend toward nearest orb — erratic boss grabs in ALL states
        if (!tent.grabTarget) {
          let nearest = null, nearD = b.erratic ? 250 : 150;
          for (let i = 0; i < G.circles.length; i++) {
            const c = G.circles[i];
            if (c.popped || !c.alive || c.queued) continue;
            const d = dist(b.x, b.y, c.x, c.y);
            if (d < nearD) { nearD = d; nearest = c; }
          }
          if (nearest) {
            tent.grabTarget = nearest.id;
            tent.angle = Math.atan2(nearest.y - b.y, nearest.x - b.x);
          }
        }
        // Pull grabbed orb toward maw — erratic boss pulls harder
        if (tent.grabTarget) {
          const gc = findCircleById(tent.grabTarget);
          if (gc && gc.alive && !gc.popped) {
            const dx = b.x - gc.x, dy = b.y - gc.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            const grabPull = b.erratic ? 140 : 80;
            if (d > 5) {
              gc.vx += (dx / d) * grabPull * dt;
              gc.vy += (dy / d) * grabPull * dt;
            }
            // Swallow if close
            if (d < b.radius * 0.6) {
              gc.alive = false; gc.popped = true;
              b.hp = Math.min(b.maxHp, b.hp + 1);
              b.mawOpen = 1.0;
              spawnPopParticles(gc.x, gc.y, '#ff2040');
              tent.grabTarget = null;
              // Erratic boss grows from eating
              if (b.erratic) {
                b.orbsEaten = (b.orbsEaten || 0) + 1;
                if (b.orbsEaten % 3 === 0) {
                  b.maxHp++;
                  b.hp = Math.min(b.maxHp, b.hp + 1);
                  spawnFloatingText(b.x, b.y - b.radius - 25, 'BOSS GROWS', '#ff3050');
                }
                b.radius = Math.min(200, b.radius + 0.5);
              }
            }
          } else {
            tent.grabTarget = null;
          }
        }
      } else {
        tent.grabTarget = null;
      }
    }

    // Maw close animation
    if (b.mawOpen > 0) b.mawOpen = Math.max(0, b.mawOpen - dt * 2);

    // Pressure wave behavior
    if (b.state === 'pressure') {
      const waveT = (1.5 - b.stateTimer) / 1.5;
      const waveStr = Math.sin(waveT * Math.PI) * 120 * dt;
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (c.popped || !c.alive) continue;
        const dx = c.x - b.x, dy = c.y - b.y;
        const d = Math.sqrt(dx * dx + dy * dy) + 1;
        if (d < 200) {
          c.vx += (dx / d) * waveStr;
          c.vy += (dy / d) * waveStr;
        }
      }
    }
  }
}

// --- Boss Damage (called from popCircle) ---
function damageBoss(explosionX, explosionY, blastRadius, orbRadius) {
  if (!G.boss || G.boss.state === 'dying' || G.boss.hitCooldown > 0) return;
  const b = G.boss;
  const d = dist(explosionX, explosionY, b.x, b.y);
  if (d > blastRadius + b.radius) return;

  // Size-based damage: small orbs do less, big merged orbs do more
  const sizeRatio = (orbRadius || BASE_CIRCLE_RADIUS) / BASE_CIRCLE_RADIUS;
  let dmg = 1;
  if (sizeRatio < 0.5) dmg = 0; // tiny shrapnel does NO boss damage
  else if (sizeRatio < 0.8) dmg = 1; // small orbs = 1 HP
  else if (sizeRatio < 1.5) dmg = 1; // normal orbs = 1 HP
  else if (sizeRatio < 2.5) dmg = 2; // big merged = 2 HP
  else dmg = 3; // Big2 = 3 HP

  if (dmg <= 0) return; // too small to hurt boss

  b.hp -= dmg;
  b.hitCooldown = 0.15;
  b.hitFlash = 1.0;
  G.shakeAmount = Math.max(G.shakeAmount, dmg + 1);
  playBossHitSound();

  const hpText = Math.max(0, b.hp) + '/' + b.maxHp;
  const bName = b.type === 'nexus' ? 'NEXUS' : 'LEVIATHAN';
  const dmgText = dmg > 1 ? ' -' + dmg + 'HP' : '';
  spawnFloatingText(b.x, b.y - b.radius - 10, bName + ' ' + hpText + dmgText,
    b.type === 'nexus' ? '#d050ff' : '#00e5ff');

  // Check for tentacle damage (Leviathan)
  if (b.type === 'leviathan') {
    for (let t = 0; t < b.tentacles.length; t++) {
      const tent = b.tentacles[t];
      if (tent.hp <= 0) continue;
      const tentEndX = b.x + Math.cos(tent.angle) * b.radius * 2 * tent.length;
      const tentEndY = b.y + Math.sin(tent.angle) * b.radius * 2 * tent.length;
      const td = dist(explosionX, explosionY, tentEndX, tentEndY);
      if (td < blastRadius) {
        tent.hp--;
        if (tent.hp <= 0) {
          tent.length = 0.3;
          tent.grabTarget = null;
          // Drop a free orb
          if (G.circles.length < MAX_CIRCLES) {
            const fc = createCircle(tentEndX, tentEndY);
            fc.spawnAnim = 0;
            G.circles.push(fc);
          }
        }
      }
    }
  }

  if (b.hp <= 0) {
    b.state = 'dying';
    b.dyingTimer = 0;
  }
}

// --- Boss Rendering ---
function renderBoss(ctx) {
  if (!G.boss) return;
  const b = G.boss;
  const alpha = b.spawnAnim > 0 ? (1 - b.spawnAnim) : (b.state === 'dying' ? Math.max(0, 1 - b.dyingTimer / 1.5) : 1);
  if (alpha < 0.01) return;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Erratic visual distortion — jittery position, flicker, scale throb
  if (b.erratic && b.state !== 'dying') {
    const jitterX = (Math.random() - 0.5) * 6;
    const jitterY = (Math.random() - 0.5) * 6;
    ctx.translate(jitterX, jitterY);
    // Random alpha flicker
    ctx.globalAlpha = alpha * (0.7 + Math.random() * 0.3);
  }

  if (b.type === 'nexus') {
    renderNexusBoss(ctx, b);
  } else {
    renderLeviathanBoss(ctx, b);
  }

  // HP bar arc
  if (b.state !== 'dying' && b.hp > 0) {
    const hpFrac = b.hp / b.maxHp;
    ctx.globalAlpha = alpha * 0.6;
    // Background arc
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.radius - 12, b.radius * 0.7, Math.PI, 0);
    ctx.stroke();
    // HP fill arc
    ctx.strokeStyle = hpFrac > 0.5 ? '#00ff80' : hpFrac > 0.25 ? '#ffcc00' : '#ff4040';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.radius - 12, b.radius * 0.7, Math.PI, Math.PI + Math.PI * hpFrac);
    ctx.stroke();
  }

  ctx.restore();
}

function renderNexusBoss(ctx, b) {
  const r = b.radius;

  // Hit flash
  if (b.hitFlash > 0) {
    ctx.globalAlpha = (ctx.globalAlpha || 1) * (1 - b.hitFlash * 0.3);
  }

  // Layer 0: Ominous aura
  ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.15;
  const auraR = r * 2.5;
  const auraGrad = ctx.createRadialGradient(b.x, b.y, r * 0.5, b.x, b.y, auraR);
  auraGrad.addColorStop(0, '#6020a0');
  auraGrad.addColorStop(0.5, '#300060');
  auraGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(b.x, b.y, auraR, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = b.hitFlash > 0 ? (1 - b.hitFlash * 0.3) : 1;

  // Layer 1: Central mass — blobby polygon
  const bodyPts = 16;
  ctx.fillStyle = b.hitFlash > 0.5 ? '#ffffff' : '#1a0830';
  const bodyGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r);
  bodyGrad.addColorStop(0, b.hitFlash > 0.5 ? '#ffffff' : '#2a0840');
  bodyGrad.addColorStop(0.6, '#180030');
  bodyGrad.addColorStop(1, '#0a0015');
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  for (let p = 0; p <= bodyPts; p++) {
    const angle = (p / bodyPts) * Math.PI * 2;
    const wobble = Math.sin(angle * 3 + b.phase * 1.5) * 0.08 +
                   Math.sin(angle * 5 + b.phase * 0.7) * 0.05;
    const pr = r * (0.85 + wobble);
    const px = b.x + Math.cos(angle) * pr;
    const py = b.y + Math.sin(angle) * pr;
    if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 2: Eyes
  for (let e = 0; e < b.eyePhases.length; e++) {
    const eye = b.eyePhases[e];
    const eAngle = eye.angle + b.phase * 0.1;
    const ex = b.x + Math.cos(eAngle) * r * eye.dist;
    const ey = b.y + Math.sin(eAngle) * r * eye.dist;
    const eR = r * eye.size;

    // Blink
    const blink = Math.sin(b.phase * eye.blinkSpeed + eye.blinkPhase);
    if (blink < -0.85) continue; // fully closed

    const openness = blink < -0.5 ? (blink + 0.85) / 0.35 : 1;

    // Sclera
    ctx.fillStyle = '#e8ddd0';
    ctx.globalAlpha = (b.hitFlash > 0.5 ? 0.3 : 0.9) * openness;
    ctx.beginPath();
    ctx.ellipse(ex, ey, eR, eR * openness, 0, 0, Math.PI * 2);
    ctx.fill();

    // Iris — looks toward cursor
    const lookDx = G.cursorX - ex, lookDy = G.cursorY - ey;
    const lookD = Math.sqrt(lookDx * lookDx + lookDy * lookDy) + 1;
    const lookStr = eR * 0.3;
    const irisX = ex + (lookDx / lookD) * lookStr;
    const irisY = ey + (lookDy / lookD) * lookStr * openness;
    const irisR = eR * 0.5;
    ctx.fillStyle = '#8b6914';
    ctx.globalAlpha = 0.95 * openness;
    ctx.beginPath();
    ctx.arc(irisX, irisY, irisR, 0, Math.PI * 2);
    ctx.fill();

    // Pupil
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(irisX, irisY, irisR * 0.45, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function renderLeviathanBoss(ctx, b) {
  const r = b.radius;
  const pal = getCurrentPalette();
  const accent = pal.accent || '#00e5ff';

  // Hit flash
  if (b.hitFlash > 0) {
    ctx.globalAlpha = (ctx.globalAlpha || 1) * (1 - b.hitFlash * 0.3);
  }

  // Layer 0: Bioluminescent glow
  ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.2;
  const glowR = r * 3;
  const glowGrad = ctx.createRadialGradient(b.x, b.y, r * 0.3, b.x, b.y, glowR);
  glowGrad.addColorStop(0, accent);
  glowGrad.addColorStop(0.4, '#004060');
  glowGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = glowGrad;
  ctx.beginPath();
  ctx.arc(b.x, b.y, glowR, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = b.hitFlash > 0 ? (1 - b.hitFlash * 0.3) : 1;

  // Layer 2: Tentacles
  for (let t = 0; t < b.tentacles.length; t++) {
    const tent = b.tentacles[t];
    if (tent.hp <= 0 && tent.length < 0.35) {
      // Severed stub
      ctx.strokeStyle = '#401020';
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.5;
      const stubEnd = r * 0.4;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(tent.angle) * r * 0.4, b.y + Math.sin(tent.angle) * r * 0.4);
      ctx.lineTo(b.x + Math.cos(tent.angle) * stubEnd * 1.5, b.y + Math.sin(tent.angle) * stubEnd * 1.5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      continue;
    }

    const tentLen = r * 2 * tent.length;
    const segments = 6;
    const segLen = tentLen / segments;
    const isGrabbing = b.state === 'grabbing' && tent.grabTarget;

    // Build tentacle path
    ctx.strokeStyle = isGrabbing ? accent : '#104050';
    ctx.lineWidth = isGrabbing ? 5 : 3.5;
    ctx.lineCap = 'round';
    ctx.globalAlpha = 0.8;
    ctx.beginPath();

    let px = b.x + Math.cos(tent.angle) * r * 0.4;
    let py = b.y + Math.sin(tent.angle) * r * 0.4;
    ctx.moveTo(px, py);

    for (let s = 1; s <= segments; s++) {
      const sf = s / segments;
      const curl = Math.sin(tent.phase + s * 1.2 + b.phase * 1.5) * 0.6 * sf;
      const segAngle = tent.angle + curl;
      px += Math.cos(segAngle) * segLen;
      py += Math.sin(segAngle) * segLen;

      // Taper linewidth
      ctx.lineWidth = (isGrabbing ? 5 : 3.5) * (1 - sf * 0.6);
      ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Suction cups along tentacle
    ctx.fillStyle = '#206060';
    ctx.globalAlpha = 0.3;
    let cpx = b.x + Math.cos(tent.angle) * r * 0.4;
    let cpy = b.y + Math.sin(tent.angle) * r * 0.4;
    for (let s = 1; s <= segments; s += 2) {
      const sf = s / segments;
      const curl = Math.sin(tent.phase + s * 1.2 + b.phase * 1.5) * 0.6 * sf;
      const segAngle = tent.angle + curl;
      cpx += Math.cos(segAngle) * segLen * 2;
      cpy += Math.sin(segAngle) * segLen * 2;
      ctx.beginPath();
      ctx.arc(cpx, cpy, 2.5 * (1 - sf * 0.5), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Layer 1: Central mantle — dark bulbous body
  const mantlePts = 20;
  const mantleGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r);
  mantleGrad.addColorStop(0, b.hitFlash > 0.5 ? '#80ffff' : '#0a1828');
  mantleGrad.addColorStop(0.5, '#081420');
  mantleGrad.addColorStop(0.85, '#102030');
  mantleGrad.addColorStop(1, accent);
  ctx.fillStyle = mantleGrad;
  ctx.beginPath();
  for (let p = 0; p <= mantlePts; p++) {
    const angle = (p / mantlePts) * Math.PI * 2;
    const wobble = Math.sin(angle * 4 + b.phase * 0.8) * 0.06 +
                   Math.sin(angle * 7 + b.phase * 1.3) * 0.03;
    const pr = r * (0.8 + wobble);
    const px = b.x + Math.cos(angle) * pr;
    const py = b.y + Math.sin(angle) * pr;
    if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 3: Maw
  if (b.mawOpen > 0.05) {
    const mawAngle = b.tentacles.length > 0 ? b.tentacles[0].angle : 0;
    const mawX = b.x + Math.cos(mawAngle) * r * 0.3;
    const mawY = b.y + Math.sin(mawAngle) * r * 0.3;
    const mawR = r * 0.3 * b.mawOpen;
    ctx.fillStyle = '#000008';
    ctx.beginPath();
    ctx.arc(mawX, mawY, mawR, 0, Math.PI * 2);
    ctx.fill();
    // Teeth
    ctx.strokeStyle = '#c0d0e0';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5 * b.mawOpen;
    const teethCount = 8;
    for (let tt = 0; tt < teethCount; tt++) {
      const ta = (tt / teethCount) * Math.PI * 2;
      ctx.beginPath();
      ctx.arc(mawX + Math.cos(ta) * mawR * 0.7, mawY + Math.sin(ta) * mawR * 0.7, 2, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Layer 4: Eyes (2 large, vertical slit pupils)
  for (let e = 0; e < b.eyePhases.length; e++) {
    const eye = b.eyePhases[e];
    const eAngle = eye.angle + Math.sin(b.phase * 0.3) * 0.1;
    const ex = b.x + Math.cos(eAngle) * r * eye.dist;
    const ey = b.y + Math.sin(eAngle) * r * eye.dist;
    const eR = r * eye.size * 1.3;

    // Bioluminescent halo
    ctx.globalAlpha = 0.15;
    ctx.globalCompositeOperation = 'lighter';
    const haloGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, eR * 2);
    haloGrad.addColorStop(0, accent);
    haloGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = haloGrad;
    ctx.beginPath();
    ctx.arc(ex, ey, eR * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    // Sclera
    ctx.fillStyle = '#d0e8e0';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.ellipse(ex, ey, eR, eR * 0.7, eAngle, 0, Math.PI * 2);
    ctx.fill();

    // Vertical slit pupil
    const lookDx = G.cursorX - ex, lookDy = G.cursorY - ey;
    const lookD = Math.sqrt(lookDx * lookDx + lookDy * lookDy) + 1;
    const lookStr = eR * 0.2;
    const irisX = ex + (lookDx / lookD) * lookStr;
    const irisY = ey + (lookDy / lookD) * lookStr;
    ctx.fillStyle = '#00806080';
    ctx.beginPath();
    ctx.ellipse(irisX, irisY, eR * 0.35, eR * 0.55, eAngle, 0, Math.PI * 2);
    ctx.fill();
    // Vertical slit
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.ellipse(irisX, irisY, eR * 0.08, eR * 0.4, eAngle, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ==================================================
// SECTION 11: UPGRADE SYSTEM LOGIC
// ==================================================
function checkLevelUp() {
  if (G.xp >= G.xpToNext) {
    G.level++;
    G.xp -= G.xpToNext;
    G.xpToNext = Math.floor(G.xpToNext * XP_SCALE);

    // Update tap timer max for new level (more generous as you progress)
    G.tapTimerMax = getTapTimerMax();

    // Level-up reward: +2 bonus taps
    G.taps += 2;
    spawnFloatingText(G.W / 2, G.H * 0.25, '+2 TAPS', '#00ffa0');

    // Palette transition
    const newPaletteIdx = Math.min(Math.floor((G.level - 1) / PALETTE_LEVELS), PALETTES.length - 1);
    if (newPaletteIdx !== G.biomeIndex) {
      G.prevPalette = getCurrentPalette();
      G.prevBiomeIndex = G.biomeIndex;
      G.biomeIndex = newPaletteIdx;
      G.biomeTransition = 0;
    }

    showUpgradePanel();
  }
}

function showUpgradePanel() {
  const available = Object.keys(UPGRADE_DEFS).filter(k => G.upgrades[k] < UPGRADE_DEFS[k].maxLvl);
  if (available.length === 0) return;

  G.pendingLevelUp = true;
  const choices = shuffle(available).slice(0, Math.min(3, available.length));
  const container = document.getElementById('upgrade-choices');
  container.innerHTML = '';

  choices.forEach(key => {
    const def = UPGRADE_DEFS[key];
    const nextLvl = G.upgrades[key] + 1;
    const card = document.createElement('div');
    card.className = 'upgrade-card';
    card.innerHTML = `<div class="name">${def.name}</div><div class="level">Level ${G.upgrades[key]} → ${nextLvl}</div><div class="desc">${def.desc(nextLvl)}</div>`;
    card.addEventListener('click', (e) => { e.stopPropagation(); selectUpgrade(key); });
    card.addEventListener('touchend', (e) => { e.stopPropagation(); e.preventDefault(); selectUpgrade(key); });
    container.appendChild(card);
  });

  document.getElementById('upgrade-panel').style.display = 'flex';
}

function selectUpgrade(key) {
  // Guard against double-fire (touchend + click both trigger on mobile)
  if (!G.pendingLevelUp) return;

  G.upgrades[key]++;
  G.pendingLevelUp = false;
  document.getElementById('upgrade-panel').style.display = 'none';

  // Immediate effects
  if (key === 'density') {
    const toAdd = 6;
    for (let i = 0; i < toAdd; i++) {
      G.refillQueue.push(G.refillTimer + i * 0.06);
    }
  }

  // Excess XP carries over but only one level-up per level
  // (no recursive checkLevelUp — next level-up happens at end of next chain)

  // Re-check game over if taps ran out during chain before level-up
  if (!G.pendingLevelUp && G.taps <= 0) {
    G.state = 'game_over';
    showGameOver();
  }

  updateHUD();
}

// ==================================================
// SECTION 12: RENDERING PIPELINE
// ==================================================
function render() {
  const ctx = G.ctx;
  const W = G.W, H = G.H;

  ctx.save();

  // Layer 1: Background gradient (rendered at full canvas, before zoom)
  renderBackground(ctx, W, H);

  // Layer 1c: The Watcher — cosmic entity behind the field (madness-tied, full-canvas, before zoom)
  renderWatcher(ctx, W, H);

  // Zoom: scale around screen center (applies to all game content)
  if (G.zoomLevel !== 1) {
    const cx = W / 2, cy = H / 2;
    ctx.translate(cx, cy);
    ctx.scale(G.zoomLevel, G.zoomLevel);
    ctx.translate(-cx, -cy);
  }

  // Screen shake
  if (G.shakeAmount > 0.5) {
    const sx = (Math.random() - 0.5) * G.shakeAmount;
    const sy = (Math.random() - 0.5) * G.shakeAmount;
    ctx.translate(sx, sy);
  }

  // Layer 1b: Nebula clouds (ambient color blobs)
  renderNebulaClouds(ctx, W, H);

  // Layer 1b2: ABYSS-specific deep-sea background effects
  renderAbyssBackground(ctx, W, H);

  // Layer 2: Persistent paint splats (BLOOM)
  renderPaintSplats(ctx);

  // Layer 3: Orb bloom glow
  renderOrbBloom(ctx);

  // Layer 4: Aftershock zones
  renderAftershocks(ctx);

  // Layer 4b: Gravity wells
  renderGravityWells(ctx);

  // Layer 4c: Black hole
  renderBlackHole(ctx);

  // Layer 4d: Boss entity
  renderBoss(ctx);

  // Layer 5: Background particles
  renderParticleLayer(ctx, 'bg');

  // Layer 5b: Chain links
  renderChainLinks(ctx);

  // Layer 5c: Bombs
  renderBombs(ctx);

  // Layer 6: Circles
  renderCircles(ctx);

  // Layer 7: Explosions
  renderExplosions(ctx);

  // Layer 7b: Light rays from explosions
  renderLightRays(ctx, W, H);

  // Layer 7c: Chain energy field rings
  renderChainEnergyField(ctx, W, H);

  // Layer 8: Foreground particles
  renderParticleLayer(ctx, 'fg');

  // Layer 9: Floating texts
  renderFloatingTexts(ctx);

  // Layer 10: White-hot glow
  if (G.whiteGlow > 0.01) {
    renderWhiteGlow(ctx, W, H);
  }

  // Layer 10b: Delayed blast buildup
  if (G.delayedBlast && !G.delayedBlast.executed) {
    renderDelayedBlastBuildup(ctx, W, H);
  }

  ctx.restore();

  // Post-processing (no shake offset)
  // Layer 12: Vignette
  renderVignette(ctx, W, H);

  // Layer 13: Chromatic aberration
  if (G.chromaticAb > 0.3) {
    renderChromaticAb(ctx, W, H);
  }

  // Layer 14: Tap timer bar (top of screen, under HUD)
  if (G.state === 'playing' && G.taps > 0 && !G.chainActive && !G.pendingLevelUp) {
    const timerT = Math.max(0, G.tapTimer / G.tapTimerMax);
    ctx.save();
    // Background track
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, W, 2);
    // Fill — changes color as time runs low
    ctx.globalAlpha = 0.5 + (1 - timerT) * 0.5;
    if (timerT > 0.4) ctx.fillStyle = '#ffffff';
    else if (timerT > 0.15) ctx.fillStyle = '#ffd84d';
    else ctx.fillStyle = '#ff3c8e';
    ctx.fillRect(0, 0, W * timerT, 2);
    ctx.restore();
  }
}

// ==================================================
// THE WATCHER — cosmic entity looming behind the field
// Appears gradually after 90s, fully visible by 120s
// A silhouette of pure blackness: head, shoulders, one reaching hand
// Glowing white eyes that brighten during chains
// Surrounded by its own nebula haze
// ==================================================
// Watcher appearance is now tied to madness level (no fixed timer)

// Watcher images — tied to madness, gradually appear from the background
// Main biome: Watcher_test1.jpeg | ABYSS biome: Watchr_2.jpeg
const watcherMainImg = new Image();
watcherMainImg.src = 'images/Watcher_test1.jpeg';
let watcherMainLoaded = false;
watcherMainImg.onload = () => { watcherMainLoaded = true; };

const watcherAbyssImg = new Image();
watcherAbyssImg.src = 'images/Watchr_2.jpeg';
let watcherAbyssLoaded = false;
watcherAbyssImg.onload = () => { watcherAbyssLoaded = true; };

function updateWatcher(dt) {
  const w = G.watcher;
  w.breathPhase += dt * 0.6;

  // Opacity tied to madness — main biome 17%, ABYSS 12%
  const madness = getMadnessAmount();
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const maxOpacity = isAbyss ? 0.12 : 0.17; // main biome Watcher stronger
  const targetOpacity = madness * maxOpacity;
  // Fade in slowly, fade OUT quickly (especially when dev-toggling madness off)
  const fadeSpeed = w.opacity > targetOpacity ? 3.0 : 0.5;
  w.opacity += (targetOpacity - w.opacity) * dt * fadeSpeed;

  // Eye glow reacts to chains — subtle brightening
  const targetGlow = G.chainActive ? 0.3 + Math.min(0.4, G.chainCount * 0.015) : 0.1;
  w.eyeGlow += (targetGlow - w.eyeGlow) * dt * 3;

  // Reach reacts to black hole presence
  const targetReach = G.blackHole ? 0.5 + G.blackHole.mass * 0.04 : 0;
  w.reachAmount += (targetReach - w.reachAmount) * dt * 1.5;
}

function renderWatcher(ctx, W, H) {
  const w = G.watcher;
  if (w.opacity < 0.001) return;

  // Choose image based on biome
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const img = isAbyss ? watcherAbyssImg : watcherMainImg;
  const loaded = isAbyss ? watcherAbyssLoaded : watcherMainLoaded;
  if (!loaded) return;

  ctx.save();

  // Cover the full canvas, centered — very subtle breathing and drift
  const breathe = 1 + Math.sin(w.breathPhase) * 0.003;
  const imgW = img.width;
  const imgH = img.height;
  const coverScale = Math.max(W / imgW, H / imgH) * 1.03 * breathe;
  const drawW = imgW * coverScale;
  const drawH = imgH * coverScale;
  const drawX = (W - drawW) / 2 + Math.sin(w.breathPhase * 0.15) * 2;
  const drawY = (H - drawH) / 2 + Math.cos(w.breathPhase * 0.1) * 1.5;

  // Main draw — opacity capped at 12%, tied to madness
  ctx.globalAlpha = w.opacity;
  ctx.drawImage(img, drawX, drawY, drawW, drawH);

  // Very subtle glow overlay during chains (additive blend)
  if (w.eyeGlow > 0.15 && w.opacity > 0.005) {
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = w.opacity * (w.eyeGlow - 0.1) * 0.15;
    ctx.drawImage(img, drawX, drawY, drawW, drawH);
    ctx.globalCompositeOperation = 'source-over';
  }

  ctx.restore();
}

// Galaxy stars — persistent twinkle field
const galaxyStars = [];
for (let gs = 0; gs < 80; gs++) {
  galaxyStars.push({
    x: Math.random(),
    y: Math.random(),
    size: 0.3 + Math.random() * 1.2,
    phase: Math.random() * Math.PI * 2,
    twinkleSpeed: 0.5 + Math.random() * 2.0,
    bright: 0.3 + Math.random() * 0.7,
    colorTint: Math.floor(Math.random() * 3) // 0=white, 1=blueish, 2=warmish
  });
}
// Cosmic dust — slow-drifting particles
const cosmicDust = [];
for (let cd = 0; cd < 30; cd++) {
  cosmicDust.push({
    x: Math.random(),
    y: Math.random(),
    size: 0.5 + Math.random() * 2.0,
    speedX: (Math.random() - 0.5) * 0.002,
    speedY: (Math.random() - 0.5) * 0.001,
    phase: Math.random() * Math.PI * 2,
    alpha: 0.02 + Math.random() * 0.04,
    colorIdx: Math.floor(Math.random() * 3)
  });
}

// Living star field — huge particle cloud, moves gently, pulled by black holes
// Non-interactive but visually responsive; saturation tied to madness
const fieldStars = [];
const FIELD_STAR_COUNT = 200;
for (let fs = 0; fs < FIELD_STAR_COUNT; fs++) {
  fieldStars.push({
    x: Math.random(), y: Math.random(), // 0-1 normalized
    vx: (Math.random() - 0.5) * 0.003,
    vy: (Math.random() - 0.5) * 0.002,
    size: 0.3 + Math.random() * 1.0,
    bright: 0.2 + Math.random() * 0.8,
    phase: Math.random() * Math.PI * 2,
    colorIdx: Math.floor(Math.random() * 4) // 0=white, 1=blue, 2=gold, 3=violet
  });
}

function updateFieldStars(dt, W, H) {
  const hasBH = !!G.blackHole;
  for (let i = 0; i < fieldStars.length; i++) {
    const s = fieldStars[i];
    // Gentle drift
    s.x += s.vx * dt;
    s.y += s.vy * dt;

    // Black hole gravity pull (world coords)
    if (hasBH) {
      const bh = G.blackHole;
      const sx = s.x * W, sy = s.y * H;
      const dx = bh.x - sx, dy = bh.y - sy;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < bh.gravityRadius && d > 5) {
        const pull = 0.15 * dt / Math.max(d / bh.gravityRadius, 0.1);
        s.vx += (dx / d) * pull / W;
        s.vy += (dy / d) * pull / H;
        // Tangential spin
        s.vx += (-dy / d) * pull * 0.3 / W;
        s.vy += (dx / d) * pull * 0.3 / H;
      }
    }

    // Dampen velocity gently (stars shouldn't accumulate wild speed)
    s.vx *= (1 - dt * 0.3);
    s.vy *= (1 - dt * 0.3);
    // Minimum drift so they don't freeze
    if (Math.abs(s.vx) < 0.0005) s.vx = (Math.random() - 0.5) * 0.002;
    if (Math.abs(s.vy) < 0.0005) s.vy = (Math.random() - 0.5) * 0.001;

    // Wrap around
    if (s.x < -0.02) s.x = 1.02;
    if (s.x > 1.02) s.x = -0.02;
    if (s.y < -0.02) s.y = 1.02;
    if (s.y > 1.02) s.y = -0.02;
  }
}

function renderFieldStars(ctx, W, H) {
  const madness = getMadnessAmount();
  const p = getCurrentPalette();
  const starColors = ['#ffffff', '#aaccff', '#ffd080', '#c0a0ff'];

  ctx.save();
  for (let i = 0; i < fieldStars.length; i++) {
    const s = fieldStars[i];
    const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(G.time * 1.2 + s.phase));
    let color = starColors[s.colorIdx];
    // Desaturate with madness
    if (madness > 0) {
      color = horrorShift(color, madness * 0.7);
    }
    ctx.globalAlpha = 0.06 * s.bright * twinkle * (1 - madness * 0.3);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(s.x * W, s.y * H, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function renderBackground(ctx, W, H) {
  const p = getCurrentPalette();
  const madness = getMadnessAmount();

  // At low madness, brighten the palette colors slightly for a more colorful start
  const brightBoost = Math.max(0, 1 - madness * 2.5); // 1.0 at 0, 0 at 0.4+ madness
  let topColor = p.bgTop;
  let botColor = p.bgBot;

  if (G.biomeTransition < 1) {
    const prev = G.prevPalette || PALETTES[G.prevBiomeIndex] || PALETTES[0];
    topColor = lerpColor(prev.bgTop, p.bgTop, G.biomeTransition);
    botColor = lerpColor(prev.bgBot, p.bgBot, G.biomeTransition);
  }

  // Brighten at low madness — make background more colorful
  if (brightBoost > 0) {
    topColor = lerpColor(topColor, p.accent || '#3a1860', brightBoost * 0.15);
    botColor = lerpColor(botColor, p.colors ? p.colors[0] : '#2a0848', brightBoost * 0.1);
  }

  // Horror: background drains toward deep black with sickly tint
  if (madness > 0) {
    const darkenExtra = madness * 0.4; // additional darkening on top of horrorShift
    topColor = horrorShift(topColor, madness);
    botColor = horrorShift(botColor, madness);
    topColor = lerpColor(topColor, '#020004', darkenExtra);
    botColor = lerpColor(botColor, '#010002', darkenExtra);
  }

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, topColor);
  grad.addColorStop(1, botColor);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Galaxy stars — visible at all times, fade slightly with high madness
  const starAlpha = 0.08 + brightBoost * 0.12 - madness * 0.03;
  if (starAlpha > 0.01) {
    const starTints = ['#ffffff', '#aaccff', '#ffd8a0'];
    for (let i = 0; i < galaxyStars.length; i++) {
      const s = galaxyStars[i];
      const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(G.time * s.twinkleSpeed + s.phase));
      ctx.globalAlpha = starAlpha * s.bright * twinkle;
      ctx.fillStyle = starTints[s.colorTint];
      ctx.beginPath();
      ctx.arc(s.x * W, s.y * H, s.size, 0, Math.PI * 2);
      ctx.fill();
      // Larger stars get a tiny cross glint
      if (s.size > 1.0 && twinkle > 0.8) {
        ctx.globalAlpha *= 0.3;
        ctx.strokeStyle = starTints[s.colorTint];
        ctx.lineWidth = 0.5;
        const sx = s.x * W, sy = s.y * H;
        ctx.beginPath();
        ctx.moveTo(sx - s.size * 2, sy);
        ctx.lineTo(sx + s.size * 2, sy);
        ctx.moveTo(sx, sy - s.size * 2);
        ctx.lineTo(sx, sy + s.size * 2);
        ctx.stroke();
      }
    }
  }

  // Living star field — huge particle cloud, pulled by black holes
  renderFieldStars(ctx, W, H);

  // Cosmic dust — drifting colored wisps, stronger at low madness
  const dustAlpha = brightBoost * 0.8 + 0.2;
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < cosmicDust.length; i++) {
    const d = cosmicDust[i];
    d.x += d.speedX * (G.dt || 0.016);
    d.y += d.speedY * (G.dt || 0.016);
    if (d.x < -0.05) d.x = 1.05;
    if (d.x > 1.05) d.x = -0.05;
    if (d.y < -0.05) d.y = 1.05;
    if (d.y > 1.05) d.y = -0.05;
    const pulse = 0.5 + 0.5 * Math.sin(G.time * 0.4 + d.phase);
    ctx.globalAlpha = d.alpha * dustAlpha * pulse;
    const dColor = madness > 0 ? horrorShift(p.colors[d.colorIdx], madness * 0.5) : p.colors[d.colorIdx];
    ctx.fillStyle = dColor;
    ctx.beginPath();
    ctx.arc(d.x * W, d.y * H, d.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';

  // Madness particles — more floating spacey dust as madness rises
  if (madness > 0.1) {
    const madDustCount = Math.floor(madness * 60); // 0 at 10%, up to 60 at full madness
    ctx.globalCompositeOperation = 'lighter';
    for (let md = 0; md < madDustCount; md++) {
      // Deterministic position that slowly drifts using time + index
      const mHash = ((md * 173 + 91) & 0xffff) / 65535;
      const mHash2 = ((md * 257 + 43) & 0xffff) / 65535;
      const mHash3 = ((md * 311 + 67) & 0xffff) / 65535;
      const mx = ((mHash + G.time * (0.001 + mHash3 * 0.003)) % 1.1) - 0.05;
      const my = ((mHash2 + G.time * (0.0005 + mHash * 0.002)) % 1.1) - 0.05;
      const mSize = 0.3 + mHash3 * 1.5;
      const pulse = 0.4 + 0.6 * Math.sin(G.time * (0.3 + mHash * 0.5) + md * 2.1);
      const mAlpha = madness * 0.03 * pulse;
      // Desaturated with madness — sickly grey-green tones
      const madColors = ['#556655', '#445566', '#665544', '#554455', '#334455'];
      ctx.globalAlpha = mAlpha;
      ctx.fillStyle = madColors[md % madColors.length];
      ctx.beginPath();
      ctx.arc(mx * W, my * H, mSize, 0, Math.PI * 2);
      ctx.fill();
      // Some get wispy tails
      if (mSize > 1.0 && mHash > 0.6) {
        ctx.globalAlpha = mAlpha * 0.4;
        ctx.strokeStyle = madColors[md % madColors.length];
        ctx.lineWidth = 0.4;
        const tailA = G.time * 0.2 + md;
        ctx.beginPath();
        ctx.moveTo(mx * W, my * H);
        ctx.lineTo(mx * W + Math.cos(tailA) * mSize * 4, my * H + Math.sin(tailA) * mSize * 4);
        ctx.stroke();
      }
    }
    ctx.globalCompositeOperation = 'source-over';
  }

  ctx.globalAlpha = 1;
}

function renderGrid(ctx, W, H) {
  const biome = getCurrentBiome();
  ctx.strokeStyle = biome.gridTint;
  ctx.lineWidth = 1;

  const horizon = H * 0.35;
  const vanishX = W * 0.5;
  const gridLines = 15;
  const spacing = (H - horizon) / gridLines;
  const scrollOffset = (G.time * 30) % spacing;

  // Horizontal lines — closer spacing near horizon, wider at bottom
  for (let i = 0; i <= gridLines; i++) {
    const t = i / gridLines;
    const y = horizon + (H - horizon) * (t * t) + scrollOffset * t;
    if (y > H || y < horizon) continue;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }

  // Vertical converging lines
  const vertLines = 20;
  for (let i = -vertLines/2; i <= vertLines/2; i++) {
    const bottomX = vanishX + i * (W / vertLines) * 1.5;
    ctx.beginPath();
    ctx.moveTo(vanishX, horizon);
    ctx.lineTo(bottomX, H);
    ctx.stroke();
  }
}

function renderPaintSplats(ctx) {
  const splatMadness = getMadnessAmount();
  for (let i = 0; i < G.paintSplats.length; i++) {
    const s = G.paintSplats[i];
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = splatMadness > 0 ? horrorShift(s.color, splatMadness * 0.7) : s.color;
    for (let j = 0; j < 5; j++) {
      const angle = (s.seed + j * 73) % (Math.PI * 2);
      const d = s.size * 0.3 * (((s.seed + j * 37) % 10) / 10);
      const r = s.size * (0.3 + 0.5 * (((s.seed + j * 51) % 10) / 10));
      ctx.beginPath();
      ctx.arc(s.x + Math.cos(angle)*d, s.y + Math.sin(angle)*d, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

function renderAftershocks(ctx) {
  for (let i = 0; i < G.aftershocks.length; i++) {
    const as = G.aftershocks[i];
    const t = as.life / as.maxLife;
    ctx.globalAlpha = t * 0.15;
    const grad = ctx.createRadialGradient(as.x, as.y, 0, as.x, as.y, as.radius);
    grad.addColorStop(0, as.color);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(as.x, as.y, as.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function renderGravityWells(ctx) {
  for (let i = 0; i < G.gravityWells.length; i++) {
    const gw = G.gravityWells[i];
    const t = gw.life / gw.maxLife;
    const progress = 1 - t;
    ctx.save();
    // Contracting ring
    ctx.globalAlpha = t * 0.35;
    ctx.strokeStyle = gw.color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(gw.x, gw.y, gw.radius * (1 - progress * 0.7), 0, Math.PI * 2);
    ctx.stroke();
    // Inner dashed ring
    ctx.globalAlpha = t * 0.2;
    ctx.setLineDash([4, 6]);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(gw.x, gw.y, gw.radius * 0.4 * (1 - progress * 0.5), 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }
}

function renderChainLinks(ctx) {
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  const linkMadness = getMadnessAmount();

  for (let i = 0; i < G.chainLinks.length; i++) {
    const link = G.chainLinks[i];
    const target = findCircleById(link.targetId);
    if (!target || target.popped) continue;
    const progress = Math.min(link.timer / link.duration, 1);

    // Bezier control point — gentle organic curve
    const mx = (link.srcX + target.x) / 2;
    const my = (link.srcY + target.y) / 2;
    const dx = target.x - link.srcX;
    const dy = target.y - link.srcY;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    const nx = -dy / len;
    const ny = dx / len;

    if (isAbyss) {
      // === TENTACLE-STYLE CONNECTORS — sinuous, segmented, organic ===
      const wave1 = Math.sin(link.timer * 4 + i * 2.3) * (20 + len * 0.15);
      const wave2 = Math.sin(link.timer * 6 + i * 1.7 + 1.5) * (10 + len * 0.08);
      const cpx1 = mx * 0.6 + link.srcX * 0.4 + nx * wave1;
      const cpy1 = my * 0.6 + link.srcY * 0.4 + ny * wave1;
      const cpx2 = mx * 0.4 + target.x * 0.6 + nx * wave2;
      const cpy2 = my * 0.4 + target.y * 0.6 + ny * wave2;

      ctx.save();
      const p = getCurrentPalette();

      // Main tentacle stroke — thick, tapered
      ctx.globalAlpha = 0.3 + progress * 0.5;
      ctx.strokeStyle = linkMadness > 0 ? horrorShift(p.colors[i % 3], linkMadness * 0.5) : p.colors[i % 3];
      ctx.lineWidth = (2 + progress * 4) * Math.min(1, len / 30);
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(link.srcX, link.srcY);
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, target.x, target.y);
      ctx.stroke();

      // Inner glow line — brighter, thinner
      ctx.globalAlpha = (0.2 + progress * 0.4);
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = (1 + progress * 2) * Math.min(1, len / 30);
      ctx.beginPath();
      ctx.moveTo(link.srcX, link.srcY);
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, target.x, target.y);
      ctx.stroke();

      // Suction cup dots along the tentacle
      ctx.globalAlpha = 0.15 + progress * 0.2;
      ctx.fillStyle = '#001520';
      const suckerCount = Math.floor(len / 18);
      for (let s = 1; s < suckerCount; s++) {
        const t = s / suckerCount;
        const inv = 1 - t;
        // Cubic bezier sample
        const bx = inv*inv*inv*link.srcX + 3*inv*inv*t*cpx1 + 3*inv*t*t*cpx2 + t*t*t*target.x;
        const by = inv*inv*inv*link.srcY + 3*inv*inv*t*cpy1 + 3*inv*t*t*cpy2 + t*t*t*target.y;
        const suckerR = (1 + progress * 1.5) * (0.5 + 0.5 * Math.sin(t * Math.PI));
        ctx.beginPath();
        ctx.arc(bx, by, suckerR, 0, Math.PI * 2);
        ctx.fill();
      }

      // Bioluminescent pulse traveling along
      const pulseT = (link.timer * 2.5) % 1;
      const pt = pulseT, inv = 1 - pt;
      const px = inv*inv*inv*link.srcX + 3*inv*inv*pt*cpx1 + 3*inv*pt*pt*cpx2 + pt*pt*pt*target.x;
      const py = inv*inv*inv*link.srcY + 3*inv*inv*pt*cpy1 + 3*inv*pt*pt*cpy2 + pt*pt*pt*target.y;
      ctx.globalAlpha = (0.3 + progress * 0.5);
      ctx.globalCompositeOperation = 'lighter';
      const pulseGrad = ctx.createRadialGradient(px, py, 0, px, py, 6 + progress * 4);
      pulseGrad.addColorStop(0, p.accent);
      pulseGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = pulseGrad;
      ctx.beginPath();
      ctx.arc(px, py, 6 + progress * 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.restore();
    } else {
      // === METABALL-STYLE BLOB CONNECTOR — original style ===
      const wave = Math.sin(link.timer * 5 + i * 2.3) * (15 + len * 0.1);
      const cpx = mx + nx * wave;
      const cpy = my + ny * wave;

      ctx.save();
      ctx.globalAlpha = 0.25 + progress * 0.55;
      ctx.fillStyle = linkMadness > 0 ? horrorShift(link.color, linkMadness * 0.5) : link.color;

      const srcR = (8 + progress * 6) * Math.min(1, len / 40);
      const tgtR = (7 + progress * 7) * Math.min(1, len / 40);

      const steps = 24;
      const leftPts = [], rightPts = [];
      for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const inv = 1 - t;
        const bx = inv * inv * link.srcX + 2 * inv * t * cpx + t * t * target.x;
        const by = inv * inv * link.srcY + 2 * inv * t * cpy + t * t * target.y;
        const tx2 = 2 * (inv * (cpx - link.srcX) + t * (target.x - cpx));
        const ty2 = 2 * (inv * (cpy - link.srcY) + t * (target.y - cpy));
        const tl = Math.sqrt(tx2 * tx2 + ty2 * ty2) || 1;
        const tnx = -ty2 / tl;
        const tny = tx2 / tl;
        const fromSrc = t;
        const fromTgt = 1 - t;
        const srcBlob = Math.exp(-fromSrc * fromSrc * 12) * srcR;
        const tgtBlob = Math.exp(-fromTgt * fromTgt * 12) * tgtR;
        const neckW = (1.5 + progress * 2.5) * (0.6 + 0.4 * Math.sin(t * Math.PI));
        const w = Math.max(srcBlob, tgtBlob, neckW) * 0.5;
        const wobble = Math.sin(link.timer * 6 + t * 12 + i) * 0.8 * progress;
        leftPts.push([bx + tnx * (w + wobble), by + tny * (w + wobble)]);
        rightPts.push([bx - tnx * (w + wobble), by - tny * (w + wobble)]);
      }

      ctx.beginPath();
      ctx.moveTo(leftPts[0][0], leftPts[0][1]);
      for (let s = 1; s <= steps; s++) {
        if (s < steps) {
          const cx2 = (leftPts[s][0] + leftPts[s+1 > steps ? s : s+1][0]) / 2;
          const cy2 = (leftPts[s][1] + leftPts[s+1 > steps ? s : s+1][1]) / 2;
          ctx.quadraticCurveTo(leftPts[s][0], leftPts[s][1], cx2, cy2);
        } else {
          ctx.lineTo(leftPts[s][0], leftPts[s][1]);
        }
      }
      for (let s = steps; s >= 0; s--) {
        if (s > 0) {
          const cx2 = (rightPts[s][0] + rightPts[s-1][0]) / 2;
          const cy2 = (rightPts[s][1] + rightPts[s-1][1]) / 2;
          ctx.quadraticCurveTo(rightPts[s][0], rightPts[s][1], cx2, cy2);
        } else {
          ctx.lineTo(rightPts[s][0], rightPts[s][1]);
        }
      }
      ctx.closePath();
      ctx.fill();

      // Small blob pulse traveling along
      const pulseT = (link.timer * 2) % 1;
      const pt = pulseT;
      const invPt = 1 - pt;
      const px = invPt * invPt * link.srcX + 2 * invPt * pt * cpx + pt * pt * target.x;
      const py = invPt * invPt * link.srcY + 2 * invPt * pt * cpy + pt * pt * target.y;
      ctx.globalAlpha = (0.4 + progress * 0.4) * ctx.globalAlpha;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(px, py, 1.5 + progress * 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }
}

// === DEFAULT SC: Amorphous eye-cluster entity — NOT an angel ===
// Pulsating organic mass covered in blinking eyes, trailing pseudopods
function renderDefaultSC(ctx, c, drawR) {
  const scAlpha = c.scFade !== undefined ? c.scFade : 1;
  const arms = c.spikeCount;
  const idSeed = c.id * 3.17;
  const phase = c.pulsePhase;

  // Layer 0: Eerie radiance
  ctx.globalAlpha = scAlpha * 0.06;
  const glowR = drawR * 2.2;
  const glowGrad = ctx.createRadialGradient(c.x, c.y, drawR * 0.2, c.x, c.y, glowR);
  glowGrad.addColorStop(0, '#ffe0a0');
  glowGrad.addColorStop(0.5, '#a06030');
  glowGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = glowGrad;
  ctx.beginPath();
  ctx.arc(c.x, c.y, glowR, 0, Math.PI * 2);
  ctx.fill();

  // Layer 1: Pulsating organic pseudopods — irregular limbs reaching outward
  const podCount = arms + 2;
  for (let p = 0; p < podCount; p++) {
    const pSeed = p * 5.71 + idSeed;
    const baseAngle = (p / podCount) * Math.PI * 2 + Math.sin(pSeed) * 0.5;
    const waveAngle = baseAngle + Math.sin(phase * (1.5 + p * 0.3) + pSeed) * 0.25;
    const podLen = drawR * (0.6 + 0.5 * Math.sin(phase * 1.2 + pSeed * 2));
    const podW = drawR * (0.12 + 0.06 * Math.sin(pSeed * 3));

    // Organic tapered limb
    ctx.globalAlpha = scAlpha * 0.45;
    ctx.fillStyle = c.color;
    const startR = drawR * 0.35;
    const sx = c.x + Math.cos(waveAngle) * startR;
    const sy = c.y + Math.sin(waveAngle) * startR;
    const ex = c.x + Math.cos(waveAngle) * podLen;
    const ey = c.y + Math.sin(waveAngle) * podLen;
    const cpOff = Math.sin(phase * 2 + pSeed) * drawR * 0.15;
    const perpX = -Math.sin(waveAngle);
    const perpY = Math.cos(waveAngle);

    ctx.beginPath();
    ctx.moveTo(sx + perpX * podW, sy + perpY * podW);
    ctx.quadraticCurveTo(
      (sx + ex) / 2 + perpX * (podW * 0.6 + cpOff),
      (sy + ey) / 2 + perpY * (podW * 0.6 + cpOff),
      ex, ey
    );
    ctx.quadraticCurveTo(
      (sx + ex) / 2 - perpX * (podW * 0.6 - cpOff),
      (sy + ey) / 2 - perpY * (podW * 0.6 - cpOff),
      sx - perpX * podW, sy - perpY * podW
    );
    ctx.closePath();
    ctx.fill();
  }

  // Layer 2: Central body — blobby mass
  ctx.globalAlpha = scAlpha * 0.7;
  const bodyGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR * 0.55);
  bodyGrad.addColorStop(0, '#e8d0b8');
  bodyGrad.addColorStop(0.6, c.color);
  bodyGrad.addColorStop(1, 'rgba(0,0,0,0.3)');
  ctx.fillStyle = bodyGrad;
  // Wobbly outline
  ctx.beginPath();
  const bodyPts = 24;
  for (let b = 0; b <= bodyPts; b++) {
    const t = (b / bodyPts) * Math.PI * 2;
    const wobble = 1 + 0.08 * Math.sin(t * 5 + phase * 3 + idSeed) + 0.05 * Math.sin(t * 3 + phase * 2);
    const bR = drawR * 0.45 * wobble;
    const bx = c.x + Math.cos(t) * bR;
    const by = c.y + Math.sin(t) * bR;
    if (b === 0) ctx.moveTo(bx, by);
    else ctx.lineTo(bx, by);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 3: Multiple eyes scattered across the body and pseudopods
  const eyeCount = 4 + Math.floor(arms * 0.8);
  for (let e = 0; e < eyeCount; e++) {
    const eSeed = e * 7.13 + idSeed;
    const eAngle = (e / eyeCount) * Math.PI * 2 + Math.sin(eSeed) * 0.8;
    const eDist = drawR * (0.1 + (e / eyeCount) * 0.45 + Math.sin(eSeed * 2) * 0.1);
    const ex = c.x + Math.cos(eAngle + Math.sin(phase * 0.8 + eSeed) * 0.15) * eDist;
    const ey = c.y + Math.sin(eAngle + Math.sin(phase * 0.8 + eSeed) * 0.15) * eDist;

    // Blink cycle
    const blink = Math.max(0, Math.sin(phase * 1.3 + eSeed * 2.7));
    if (blink < 0.1) continue;

    const eyeR = (drawR * 0.07 + 1.5) * blink;

    // Fleshy surround
    ctx.globalAlpha = scAlpha * 0.4 * blink;
    ctx.fillStyle = '#c8a890';
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR * 1.4, 0, Math.PI * 2);
    ctx.fill();

    // Sclera
    ctx.globalAlpha = scAlpha * 0.85 * blink;
    ctx.fillStyle = '#f0e8d8';
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR, 0, Math.PI * 2);
    ctx.fill();

    // Iris — looks toward cursor
    const lookStr = eyeR * 0.25;
    const ldx = G.cursorX - ex, ldy = G.cursorY - ey;
    const lDist = Math.sqrt(ldx * ldx + ldy * ldy) + 1;
    const iOx = (ldx / lDist) * lookStr;
    const iOy = (ldy / lDist) * lookStr;
    const irisGrad = ctx.createRadialGradient(ex + iOx, ey + iOy, eyeR * 0.08, ex + iOx, ey + iOy, eyeR * 0.6);
    irisGrad.addColorStop(0, '#c89540');
    irisGrad.addColorStop(0.5, '#8b6028');
    irisGrad.addColorStop(1, '#5a3818');
    ctx.fillStyle = irisGrad;
    ctx.beginPath();
    ctx.arc(ex + iOx, ey + iOy, eyeR * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Pupil
    ctx.fillStyle = '#0a0505';
    ctx.beginPath();
    ctx.arc(ex + iOx, ey + iOy, eyeR * 0.25, 0, Math.PI * 2);
    ctx.fill();

    // Specular
    ctx.globalAlpha = scAlpha * 0.6 * blink;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(ex + iOx - eyeR * 0.15, ey + iOy - eyeR * 0.15, eyeR * 0.12, 0, Math.PI * 2);
    ctx.fill();
  }

  // Layer 4: Orbiting motes — eerie energy
  ctx.globalAlpha = scAlpha * 0.3;
  const moteCount = 4 + arms;
  for (let s = 0; s < moteCount; s++) {
    const sSeed = s * 3.91 + idSeed;
    const sAngle = (s / moteCount) * Math.PI * 2 + phase * 2.5;
    const sR = drawR * (0.55 + 0.25 * Math.sin(sSeed + phase * 1.5));
    const sx = c.x + Math.cos(sAngle) * sR;
    const sy = c.y + Math.sin(sAngle) * sR;
    ctx.fillStyle = Math.sin(sSeed) > 0 ? '#ffe880' : c.color;
    ctx.beginPath();
    ctx.arc(sx, sy, 0.6 + Math.sin(sSeed * 5 + phase * 3) * 0.3, 0, Math.PI * 2);
    ctx.fill();
  }
}

// === ABYSS SC: Deep sea horror — writhing tentacle mass with bioluminescent eyes ===
function renderAbyssSC(ctx, c, drawR) {
  const scAlpha = c.scFade !== undefined ? c.scFade : 1;
  const arms = c.spikeCount;
  const idSeed = c.id * 3.17;
  const phase = c.pulsePhase;
  const p = getCurrentPalette();

  // Layer 0: Bioluminescent glow
  ctx.globalAlpha = scAlpha * 0.1;
  const glowR = drawR * 2.5;
  const bioGrad = ctx.createRadialGradient(c.x, c.y, drawR * 0.1, c.x, c.y, glowR);
  bioGrad.addColorStop(0, p.accent);
  bioGrad.addColorStop(0.4, p.colors[0]);
  bioGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = bioGrad;
  ctx.beginPath();
  ctx.arc(c.x, c.y, glowR, 0, Math.PI * 2);
  ctx.fill();

  // Layer 1: Tentacles — long, sinuous, curling appendages
  const tentCount = arms + 3;
  for (let t = 0; t < tentCount; t++) {
    const tSeed = t * 4.31 + idSeed;
    const baseAngle = (t / tentCount) * Math.PI * 2 + Math.sin(tSeed) * 0.3;
    const tentLen = drawR * (0.8 + 0.6 * Math.sin(phase * 0.8 + tSeed));

    ctx.globalAlpha = scAlpha * 0.5;
    ctx.strokeStyle = p.colors[t % 3];
    ctx.lineWidth = (3 + Math.sin(tSeed) * 1.5) * (drawR / 30);
    ctx.lineCap = 'round';

    // Multi-segment tentacle with increasing curl
    const segments = 6;
    ctx.beginPath();
    let tx = c.x, ty = c.y;
    let tAngle = baseAngle;
    ctx.moveTo(tx, ty);
    for (let s = 0; s < segments; s++) {
      const segLen = tentLen / segments;
      const curl = Math.sin(phase * (2 + t * 0.3) + s * 1.2 + tSeed) * (0.3 + s * 0.15);
      tAngle += curl;
      const nx = tx + Math.cos(tAngle) * segLen;
      const ny = ty + Math.sin(tAngle) * segLen;
      ctx.lineTo(nx, ny);
      tx = nx; ty = ny;
    }
    ctx.stroke();

    // Suction cups along tentacle
    ctx.globalAlpha = scAlpha * 0.2;
    ctx.fillStyle = '#001820';
    let sx2 = c.x, sy2 = c.y;
    let sAngle = baseAngle;
    for (let s = 1; s < segments; s++) {
      const segLen = tentLen / segments;
      const curl = Math.sin(phase * (2 + t * 0.3) + s * 1.2 + tSeed) * (0.3 + s * 0.15);
      sAngle += curl;
      sx2 += Math.cos(sAngle) * segLen;
      sy2 += Math.sin(sAngle) * segLen;
      if (s % 2 === 0) {
        ctx.beginPath();
        ctx.arc(sx2, sy2, 1.5 * (drawR / 30), 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Layer 2: Central mantle — dark, bulbous
  ctx.globalAlpha = scAlpha * 0.7;
  const mantleGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR * 0.5);
  mantleGrad.addColorStop(0, '#002030');
  mantleGrad.addColorStop(0.5, '#001520');
  mantleGrad.addColorStop(1, p.colors[0]);
  ctx.fillStyle = mantleGrad;
  ctx.beginPath();
  const mPts = 20;
  for (let m = 0; m <= mPts; m++) {
    const mA = (m / mPts) * Math.PI * 2;
    const wobble = 1 + 0.1 * Math.sin(mA * 4 + phase * 2 + idSeed);
    const mR = drawR * 0.4 * wobble;
    const mx = c.x + Math.cos(mA) * mR;
    const my = c.y + Math.sin(mA) * mR;
    if (m === 0) ctx.moveTo(mx, my);
    else ctx.lineTo(mx, my);
  }
  ctx.closePath();
  ctx.fill();

  // Layer 3: Bioluminescent eyes — glowing, alien
  const eyeCount = 3 + Math.floor(arms * 0.6);
  for (let e = 0; e < eyeCount; e++) {
    const eSeed = e * 9.17 + idSeed;
    const eAngle = (e / eyeCount) * Math.PI * 2 + Math.sin(eSeed) * 0.4;
    const eDist = drawR * (0.08 + (e / eyeCount) * 0.35);
    const ex = c.x + Math.cos(eAngle) * eDist;
    const ey = c.y + Math.sin(eAngle) * eDist;

    const blink = Math.max(0, Math.sin(phase * 1.1 + eSeed * 3.1));
    if (blink < 0.15) continue;

    const eyeR = (drawR * 0.06 + 1.5) * blink;

    // Glowing sclera
    ctx.globalAlpha = scAlpha * 0.7 * blink;
    ctx.fillStyle = p.accent;
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR * 1.3, 0, Math.PI * 2);
    ctx.fill();

    // Dark pupil slit (vertical)
    ctx.globalAlpha = scAlpha * 0.9 * blink;
    ctx.fillStyle = '#000508';
    ctx.beginPath();
    ctx.ellipse(ex, ey, eyeR * 0.15, eyeR * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Glow halo
    ctx.globalAlpha = scAlpha * 0.15 * blink;
    ctx.globalCompositeOperation = 'lighter';
    const eyeGlow = ctx.createRadialGradient(ex, ey, 0, ex, ey, eyeR * 3);
    eyeGlow.addColorStop(0, p.accent);
    eyeGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = eyeGlow;
    ctx.beginPath();
    ctx.arc(ex, ey, eyeR * 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
}

function renderCircles(ctx) {
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;

    let pulse = 1 + Math.sin(c.pulsePhase) * (c.superCell ? 0.15 : 0.08);
    // 100 BPM beat pulse — subtle spike on selected orbs at high madness
    if (G.beatPulseOrbs.length > 0 && G.beatPulseOrbs.indexOf(c.id) !== -1) {
      const beatT = G.beatPhase; // 0-1 per beat
      const beatPulse = beatT < 0.12 ? Math.sin(beatT / 0.12 * Math.PI) * 0.10 : 0;
      pulse += beatPulse;
    }
    const r = c.radius * pulse;
    const spawnScale = c.spawnAnim > 0 ? (1 - c.spawnAnim) : 1;
    const drawR = r * spawnScale;
    if (drawR < 1) continue;

    ctx.save();

    // Merge animation: being absorbed into another orb — stretch + gooey bridge + fade
    if (c.mergeTarget !== null && c.mergeTarget !== undefined) {
      const mProgress = Math.min(1, c.mergeAnimProgress);
      const target = findCircleById(c.mergeTarget);
      const mColor = target ? lerpColor(c.color, target.color, mProgress) : c.color;
      ctx.globalAlpha = Math.max(0.05, 1 - mProgress * 0.85);

      if (target && target.alive) {
        const dx = target.x - c.x;
        const dy = target.y - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        // Gooey bridge — tapered bezier connecting absorbed orb to target
        if (dist > 2 && drawR > 1) {
          const bridgeAlpha = (1 - mProgress) * 0.6;
          ctx.globalAlpha = bridgeAlpha;
          const bridgeColor = lerpColor(c.color, target.color, 0.5);
          ctx.fillStyle = bridgeColor;
          ctx.beginPath();
          // Tapered shape: wide at absorbed orb, narrow at target
          const srcW = drawR * 0.7 * (1 - mProgress * 0.5);
          const dstW = drawR * 0.2 * (1 - mProgress * 0.5);
          const perpX = -Math.sin(angle);
          const perpY = Math.cos(angle);
          ctx.moveTo(c.x + perpX * srcW, c.y + perpY * srcW);
          // Bezier control point — bulges outward slightly
          const cpx = (c.x + target.x) * 0.5 + perpX * srcW * 0.3;
          const cpy = (c.y + target.y) * 0.5 + perpY * srcW * 0.3;
          ctx.quadraticCurveTo(cpx, cpy, target.x + perpX * dstW, target.y + perpY * dstW);
          ctx.lineTo(target.x - perpX * dstW, target.y - perpY * dstW);
          const cpx2 = (c.x + target.x) * 0.5 - perpX * srcW * 0.3;
          const cpy2 = (c.y + target.y) * 0.5 - perpY * srcW * 0.3;
          ctx.quadraticCurveTo(cpx2, cpy2, c.x - perpX * srcW, c.y - perpY * srcW);
          ctx.closePath();
          ctx.fill();
        }

        // Stretched ellipse — absorbed orb elongates toward target
        ctx.globalAlpha = Math.max(0.05, 1 - mProgress * 0.85);
        ctx.fillStyle = mColor;
        const stretch = 1 + (c.mergeStretch || 0) * 1.5; // up to 2.5× elongation
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(angle);
        ctx.scale(stretch, 1 / Math.sqrt(stretch)); // stretch along axis, compress perpendicular
        ctx.beginPath();
        ctx.arc(0, 0, drawR, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else {
        // No target — simple circle fallback
        ctx.fillStyle = mColor;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      continue;
    }

    // Fade-in alpha for orbs materializing from darkness
    if (c.fadeIn > 0) {
      const fadeAlpha = (1 - c.fadeIn);
      ctx.globalAlpha = fadeAlpha * fadeAlpha;
    }

    // Depth-of-field: at high madness, smaller/later-gen orbs appear further away
    // They get slightly more transparent and have a softer appearance
    const madnessDoF = getMadnessAmount();
    if (madnessDoF > 0.2 && c.generation > 0) {
      const depthFade = (c.generation / 3) * (madnessDoF - 0.2) * 0.6;
      ctx.globalAlpha = Math.max(0.2, (ctx.globalAlpha || 1) * (1 - depthFade));
    }

    // Motion blur trail — pronounced ghost copies + wide connecting streak
    if (c.trail && c.trail.length > 1) {
      const baseAlpha = ctx.globalAlpha || 1;
      const trailAlpha = baseAlpha * 0.4;
      // Connecting streak line from oldest trail to current position
      ctx.globalAlpha = trailAlpha * 0.5;
      ctx.strokeStyle = c.color;
      ctx.lineWidth = drawR * 0.7;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(c.trail[0].x, c.trail[0].y);
      for (let t = 1; t < c.trail.length; t++) {
        ctx.lineTo(c.trail[t].x, c.trail[t].y);
      }
      ctx.lineTo(c.x, c.y);
      ctx.stroke();
      // Ghost copies along trail — bigger and more visible
      for (let t = 0; t < c.trail.length; t++) {
        const tp = c.trail[t];
        const tFade = (t + 1) / c.trail.length;
        ctx.globalAlpha = trailAlpha * tFade;
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(tp.x, tp.y, drawR * (0.5 + tFade * 0.45), 0, Math.PI * 2);
        ctx.fill();
      }
      // Restore alpha
      if (c.fadeIn > 0) {
        const fadeAlpha = (1 - c.fadeIn);
        ctx.globalAlpha = fadeAlpha * fadeAlpha;
      } else {
        ctx.globalAlpha = 1;
      }
    }

    if (c.superCell) {
      const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';

      if (isAbyss) {
        // === ABYSS SC: TENTACLE HORROR — writhing mass with eyes ===
        renderAbyssSC(ctx, c, drawR);
      } else {
        // === DEFAULT SC: AMORPHOUS EYE-CLUSTER ENTITY ===
        renderDefaultSC(ctx, c, drawR);
      }
    } else {
      // Check if ABYSS biome — render horrifying deep-sea shapes
      const isAbyssOrb = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';

      if (isAbyssOrb && drawR > 2) {
        // === ABYSS ORB: Abstract twisted geometry — warped, undulating forms ===
        // Not recognizable creatures, just unsettling geometric distortions
        const abyssPal = getCurrentPalette();
        const savedAlpha = ctx.globalAlpha || 1;
        const seed = c.id * 7.31; // deterministic randomness per orb

        // Each orb is a warped polygon with animated vertex distortion
        // The number of sides, warp frequency, and rotation vary per orb
        const sides = 5 + (c.id % 4); // 5 to 8 sides — pentagons to octagons
        const warpFreq = 1.5 + (c.id % 7) * 0.4; // how fast it writhes
        const warpAmt = 0.12 + ((c.id * 3) % 11) * 0.015; // distortion amount
        const baseRot = G.time * (0.15 + (c.id % 5) * 0.06) * ((c.id % 2) ? 1 : -1); // slow spin

        // Draw the main twisted body — brighter, more colorful
        ctx.globalAlpha = savedAlpha * 0.85;
        const bodyGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR);
        bodyGrad.addColorStop(0, '#ffffff');
        bodyGrad.addColorStop(0.25, c.color);
        bodyGrad.addColorStop(0.7, c.color);
        bodyGrad.addColorStop(1, '#0a1520');
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        const pts = sides * 3; // smooth polygon
        for (let p = 0; p <= pts; p++) {
          const baseAngle = (p / pts) * Math.PI * 2 + baseRot;
          // Multiple sine waves distort the radius — creates organic warping
          const warp1 = Math.sin(baseAngle * sides * 0.5 + G.time * warpFreq + seed) * warpAmt;
          const warp2 = Math.sin(baseAngle * (sides + 1) + G.time * warpFreq * 0.7 + seed * 2.1) * warpAmt * 0.6;
          const warp3 = Math.sin(G.time * 1.2 + seed * 0.5) * 0.04; // breathing
          const r = drawR * (0.8 + warp1 + warp2 + warp3);
          const ax = c.x + Math.cos(baseAngle) * r;
          const ay = c.y + Math.sin(baseAngle) * r;
          if (p === 0) ctx.moveTo(ax, ay); else ctx.lineTo(ax, ay);
        }
        ctx.closePath();
        ctx.fill();

        // Inner void — subtler dark center (less oppressively dark)
        ctx.globalAlpha = savedAlpha * 0.3;
        const voidR = drawR * (0.2 + Math.sin(G.time * 1.5 + seed) * 0.06);
        const voidGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, voidR);
        voidGrad.addColorStop(0, '#081018');
        voidGrad.addColorStop(0.7, '#0c1828');
        voidGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = voidGrad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, voidR, 0, Math.PI * 2);
        ctx.fill();

        // Bioluminescent edge glow — brighter accent color along the warped perimeter
        ctx.globalAlpha = savedAlpha * 0.4;
        ctx.globalCompositeOperation = 'lighter';
        const edgeGrad = ctx.createRadialGradient(c.x, c.y, drawR * 0.5, c.x, c.y, drawR * 1.1);
        edgeGrad.addColorStop(0, 'transparent');
        edgeGrad.addColorStop(0.7, abyssPal.accent);
        edgeGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = edgeGrad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR * 1.05, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';

        // Subtle geometric stress lines — internal fractures that shift
        if (drawR > 6) {
          ctx.globalAlpha = savedAlpha * 0.15;
          ctx.strokeStyle = abyssPal.accent;
          ctx.lineWidth = 0.5;
          const lineCount = 2 + (c.id % 3);
          for (let li = 0; li < lineCount; li++) {
            const la = baseRot + (li / lineCount) * Math.PI * 2 + seed * 0.3;
            const innerR = drawR * (0.15 + Math.sin(G.time * 0.8 + li * 2.1 + seed) * 0.1);
            const outerR = drawR * (0.55 + Math.sin(G.time * 1.1 + li * 1.7 + seed) * 0.15);
            ctx.beginPath();
            ctx.moveTo(c.x + Math.cos(la) * innerR, c.y + Math.sin(la) * innerR);
            // Slight curve to the line
            const cpAngle = la + Math.sin(G.time * 0.6 + seed + li) * 0.3;
            const cpR = (innerR + outerR) * 0.5;
            ctx.quadraticCurveTo(
              c.x + Math.cos(cpAngle) * cpR,
              c.y + Math.sin(cpAngle) * cpR,
              c.x + Math.cos(la + Math.sin(G.time * 0.4 + li) * 0.15) * outerR,
              c.y + Math.sin(la + Math.sin(G.time * 0.4 + li) * 0.15) * outerR
            );
            ctx.stroke();
          }
        }

        // === WRITHING TENTACLES — horrifying organic protrusions ===
        if (drawR > 4) {
          const tentCount = 3 + (c.id % 4); // 3-6 tentacles per orb
          const tentSeed = c.id * 13.37;
          ctx.globalCompositeOperation = 'source-over';

          for (let ti = 0; ti < tentCount; ti++) {
            const tentAngle = (ti / tentCount) * Math.PI * 2 + baseRot * 0.3 + tentSeed * 0.1;
            // Vary thickness: some thick/muscular, some thin/wispy
            const isThick = ((c.id + ti) % 3) === 0;
            const baseWidth = isThick ? drawR * 0.28 : drawR * 0.10;
            const tentLen = drawR * (isThick ? (1.1 + ((ti * 7 + c.id) % 5) * 0.15) : (1.4 + ((ti * 11 + c.id) % 7) * 0.12));

            // Writhing animation — multiple sine waves for organic motion
            const writhe1 = Math.sin(G.time * (1.8 + ti * 0.4) + tentSeed + ti * 2.3) * 0.35;
            const writhe2 = Math.sin(G.time * (2.7 + ti * 0.3) + tentSeed * 1.7 + ti) * 0.2;
            const writhe3 = Math.sin(G.time * (0.9 + ti * 0.15) + tentSeed * 0.5) * 0.15;

            // Build tentacle as segmented curve
            const segments = isThick ? 8 : 6;
            const tentPts = [];
            for (let si = 0; si <= segments; si++) {
              const t = si / segments; // 0 at base, 1 at tip
              // Progressive wrinkling — more distortion toward tip
              const wrinkle = t * t * (writhe1 + writhe2 * t + writhe3 * (1 - t));
              const perpAngle = tentAngle + Math.PI * 0.5;
              const segAngle = tentAngle + wrinkle;
              const dist = drawR * 0.7 + tentLen * t;
              const sx = c.x + Math.cos(segAngle) * dist + Math.cos(perpAngle) * wrinkle * drawR * 0.2;
              const sy = c.y + Math.sin(segAngle) * dist + Math.sin(perpAngle) * wrinkle * drawR * 0.2;
              tentPts.push({ x: sx, y: sy, t: t });
            }

            // Draw tentacle body — tapered width
            ctx.globalAlpha = savedAlpha * (isThick ? 0.7 : 0.5);
            const tentGrad = ctx.createLinearGradient(
              c.x + Math.cos(tentAngle) * drawR * 0.7,
              c.y + Math.sin(tentAngle) * drawR * 0.7,
              tentPts[segments].x, tentPts[segments].y
            );
            tentGrad.addColorStop(0, c.color);
            tentGrad.addColorStop(0.4, abyssPal.accent);
            tentGrad.addColorStop(1, '#0a0a18');
            ctx.strokeStyle = tentGrad;
            ctx.lineCap = 'round';

            // Draw main tentacle stroke with taper
            for (let si = 0; si < segments; si++) {
              const t = si / segments;
              const taper = baseWidth * (1 - t * 0.85); // taper to thin tip
              // Add wrinkling bumps along the tentacle
              const wrinkleBump = isThick ? Math.sin(G.time * 3.5 + si * 1.8 + tentSeed) * taper * 0.3 : 0;
              ctx.lineWidth = Math.max(0.5, taper + wrinkleBump);
              ctx.globalAlpha = savedAlpha * (isThick ? 0.7 : 0.45) * (1 - t * 0.4);
              ctx.beginPath();
              ctx.moveTo(tentPts[si].x, tentPts[si].y);
              // Smooth curve through control point
              if (si + 2 <= segments) {
                const cpx = (tentPts[si].x + tentPts[si + 1].x) * 0.5 +
                  Math.sin(G.time * 2.1 + si * 3.1 + tentSeed) * drawR * 0.06;
                const cpy = (tentPts[si].y + tentPts[si + 1].y) * 0.5 +
                  Math.cos(G.time * 1.9 + si * 2.7 + tentSeed) * drawR * 0.06;
                ctx.quadraticCurveTo(cpx, cpy, tentPts[si + 1].x, tentPts[si + 1].y);
              } else {
                ctx.lineTo(tentPts[si + 1].x, tentPts[si + 1].y);
              }
              ctx.stroke();
            }

            // Thick tentacles get wrinkling texture ridges
            if (isThick && drawR > 8) {
              ctx.globalAlpha = savedAlpha * 0.25;
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 0.5;
              for (let ri = 1; ri < segments - 1; ri += 2) {
                const ridgeT = ri / segments;
                const ridgeW = baseWidth * (1 - ridgeT * 0.85) * 0.6;
                const perpA = tentAngle + Math.PI * 0.5 + (writhe1 + writhe2) * ridgeT;
                const rx = tentPts[ri].x;
                const ry = tentPts[ri].y;
                ctx.beginPath();
                ctx.moveTo(rx - Math.cos(perpA) * ridgeW, ry - Math.sin(perpA) * ridgeW);
                ctx.lineTo(rx + Math.cos(perpA) * ridgeW, ry + Math.sin(perpA) * ridgeW);
                ctx.stroke();
              }
            }

            // Thin tentacles get wispy curling tip
            if (!isThick && drawR > 6) {
              const tipPt = tentPts[segments];
              const tipAngle = tentAngle + writhe1 * 1.5 + writhe2;
              const curlLen = drawR * 0.3;
              ctx.globalAlpha = savedAlpha * 0.3;
              ctx.strokeStyle = abyssPal.accent;
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(tipPt.x, tipPt.y);
              ctx.quadraticCurveTo(
                tipPt.x + Math.cos(tipAngle + 0.8) * curlLen,
                tipPt.y + Math.sin(tipAngle + 0.8) * curlLen,
                tipPt.x + Math.cos(tipAngle + 1.5) * curlLen * 0.6,
                tipPt.y + Math.sin(tipAngle + 1.5) * curlLen * 0.6
              );
              ctx.stroke();
            }
          }
        }

        ctx.globalAlpha = savedAlpha;
      } else if (isAbyssOrb) {
        // Tiny ABYSS orbs — warped dot with brighter glow
        ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.8;
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();
      }

      if (!isAbyssOrb) {
      // Eyeball intensity driven by madness (0-100% scale)
      // Progressive phases:
      //   0-10% madness: nothing
      //   10-25%: Phase 1 — just a dark spot/hole in center
      //   25-50%: Phase 2 — sclera, rim, first veins
      //   50-75%: Phase 3 — iris visible, tracking cursor
      //   75-100%: Phase 4 — full detailed eye, branching veins, specular highlights
      const madnessEye = getMadnessAmount();
      const eyeIntensity = madnessEye < 0.1 ? 0 : Math.min(1, (madnessEye - 0.1) / 0.9);

      if (eyeIntensity > 0 && drawR > 5) {
        // EYEBALL rendering — progressive horror from dark hole to fleshy eye
        const savedAlpha = ctx.globalAlpha || 1;
        const ei = eyeIntensity; // shorthand

        // ALWAYS: draw the base colored orb first
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();

        // === PHASE 1: Dark void/hole in center (ei 0 to 0.2) ===
        // Just a dark smudge — user thinks it's shading, not an eye
        const holeSize = drawR * (0.2 + Math.min(ei, 0.4) * 0.5); // grows from 20% to 40% of orb
        const holeAlpha = Math.min(ei * 3, 0.7); // fades in gently, caps at 0.7
        const holeGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, holeSize);
        holeGrad.addColorStop(0, `rgba(5,2,2,${holeAlpha})`);
        holeGrad.addColorStop(0.5, `rgba(15,8,8,${holeAlpha * 0.6})`);
        holeGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = holeGrad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, holeSize, 0, Math.PI * 2);
        ctx.fill();

        // === PHASE 2: Sclera + rim emerge (ei > 0.25) ===
        if (ei > 0.25) {
          const scleraT = Math.min(1, (ei - 0.25) / 0.35); // 0 at ei=0.25, 1 at ei=0.6

          // Overlay fleshy sclera — creamy with pinkish rim
          const scleraGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR);
          scleraGrad.addColorStop(0, `rgba(245,235,220,${scleraT * 0.8})`);
          scleraGrad.addColorStop(0.5, `rgba(240,228,210,${scleraT * 0.7})`);
          scleraGrad.addColorStop(0.75, `rgba(220,195,180,${scleraT * 0.5})`);
          scleraGrad.addColorStop(0.9, `rgba(180,140,130,${scleraT * 0.3})`);
          scleraGrad.addColorStop(1, 'transparent');
          ctx.fillStyle = scleraGrad;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
          ctx.fill();

          // Fleshy rim / eyelid shadow — dark ring at edge
          if (scleraT > 0.3) {
            ctx.globalAlpha = savedAlpha * (scleraT - 0.3) * 0.5;
            ctx.strokeStyle = '#8b6050';
            ctx.lineWidth = drawR * 0.12;
            ctx.beginPath();
            ctx.arc(c.x, c.y, drawR * 0.88, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        // === PHASE 3: Veins appear (ei > 0.35) ===
        if (ei > 0.35) {
          const veinT = Math.min(1, (ei - 0.35) / 0.35); // 0 at 0.35, 1 at 0.7
          const veinAlpha = veinT * savedAlpha * 0.5;
          const veinCount = 4 + Math.floor(veinT * 8); // fewer veins at start
          for (let v = 0; v < veinCount; v++) {
            const vSeed = c.id * 3.7 + v * 5.13;
            const vAngle = (v / veinCount) * Math.PI * 2 + Math.sin(vSeed) * 0.4;
            const startR = drawR * 0.5;
            const endR = drawR * (0.75 + 0.2 * Math.sin(vSeed * 2.3));
            const vsx = c.x + Math.cos(vAngle) * startR;
            const vsy = c.y + Math.sin(vAngle) * startR;
            const vex = c.x + Math.cos(vAngle + Math.sin(vSeed) * 0.2) * endR;
            const vey = c.y + Math.sin(vAngle + Math.sin(vSeed) * 0.2) * endR;
            ctx.globalAlpha = veinAlpha;
            ctx.strokeStyle = '#993322';
            ctx.lineWidth = 0.6 + veinT * 0.5;
            ctx.beginPath();
            ctx.moveTo(vsx, vsy);
            const cpx = (vsx + vex) / 2 + Math.cos(vSeed * 4) * drawR * 0.08;
            const cpy = (vsy + vey) / 2 + Math.sin(vSeed * 4) * drawR * 0.08;
            ctx.quadraticCurveTo(cpx, cpy, vex, vey);
            ctx.stroke();
            // Branches only at high intensity
            if (veinT > 0.6 && v % 2 === 0) {
              ctx.globalAlpha = veinAlpha * 0.5;
              ctx.lineWidth = 0.4;
              const brAngle = vAngle + (Math.sin(vSeed * 3) > 0 ? 0.4 : -0.4);
              const brx = c.x + Math.cos(brAngle) * endR * 0.95;
              const bry = c.y + Math.sin(brAngle) * endR * 0.95;
              ctx.beginPath();
              ctx.moveTo(cpx, cpy);
              ctx.lineTo(brx, bry);
              ctx.stroke();
            }
          }
        }

        // === PHASE 4: Iris + pupil form (ei > 0.3) ===
        // Before 0.3: the dark hole IS the proto-pupil — seamless transition
        if (ei > 0.3) {
          const irisT = Math.min(1, (ei - 0.3) / 0.4); // 0 at 0.3, 1 at 0.7

          // Look direction — subtle at first, stronger later
          const lookStr = irisT * drawR * 0.15;
          const lookDx = G.cursorX - c.x;
          const lookDy = G.cursorY - c.y;
          const lookDist = Math.sqrt(lookDx * lookDx + lookDy * lookDy) + 1;
          const irisOffX = (lookDx / lookDist) * lookStr;
          const irisOffY = (lookDy / lookDist) * lookStr;
          const irisCx = c.x + irisOffX;
          const irisCy = c.y + irisOffY;
          const irisR = drawR * (0.28 + irisT * 0.18); // starts small, grows

          // Outer iris ring — dark amber border, fades in
          ctx.globalAlpha = savedAlpha * irisT * 0.8;
          ctx.fillStyle = '#6b4420';
          ctx.beginPath();
          ctx.arc(irisCx, irisCy, irisR, 0, Math.PI * 2);
          ctx.fill();

          // Mid iris — warm golden brown
          if (irisT > 0.3) {
            const midIrisGrad = ctx.createRadialGradient(irisCx, irisCy, irisR * 0.15, irisCx, irisCy, irisR * 0.85);
            midIrisGrad.addColorStop(0, '#c89540');
            midIrisGrad.addColorStop(0.4, '#a87830');
            midIrisGrad.addColorStop(0.7, '#8b6028');
            midIrisGrad.addColorStop(1, '#5a3818');
            ctx.globalAlpha = savedAlpha * (irisT - 0.3) * 1.4;
            ctx.fillStyle = midIrisGrad;
            ctx.beginPath();
            ctx.arc(irisCx, irisCy, irisR * 0.85, 0, Math.PI * 2);
            ctx.fill();
          }

          // Iris fiber lines — only at high intensity
          if (irisT > 0.6) {
            ctx.globalAlpha = savedAlpha * (irisT - 0.6) * 0.8;
            ctx.strokeStyle = '#d4a850';
            ctx.lineWidth = 0.4;
            const fiberCount = 12;
            for (let fb = 0; fb < fiberCount; fb++) {
              const fbAngle = (fb / fiberCount) * Math.PI * 2 + c.id * 0.5;
              const innerR = irisR * 0.3;
              const outerR = irisR * (0.65 + 0.15 * Math.sin(fb * 3.7 + c.id));
              ctx.beginPath();
              ctx.moveTo(irisCx + Math.cos(fbAngle) * innerR, irisCy + Math.sin(fbAngle) * innerR);
              ctx.lineTo(irisCx + Math.cos(fbAngle) * outerR, irisCy + Math.sin(fbAngle) * outerR);
              ctx.stroke();
            }
          }

          // Pupil — deep black, replaces/overlaps the initial dark hole
          ctx.globalAlpha = savedAlpha * (0.5 + irisT * 0.5);
          const pupilDilate = G.chainActive ? 1.3 : 1;
          const pupilR = irisR * 0.4 * pupilDilate * (0.7 + irisT * 0.3);
          ctx.fillStyle = '#0a0505';
          ctx.beginPath();
          ctx.arc(irisCx, irisCy, pupilR, 0, Math.PI * 2);
          ctx.fill();

          // Wet specular highlight — only when eye is well-formed
          if (irisT > 0.5) {
            ctx.globalAlpha = savedAlpha * (irisT - 0.5) * 1.5;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(irisCx - irisR * 0.22, irisCy - irisR * 0.22,
              pupilR * 0.35 + 0.6, pupilR * 0.25 + 0.4, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Secondary smaller highlight
            if (irisT > 0.8) {
              ctx.globalAlpha = savedAlpha * (irisT - 0.8) * 1.5;
              ctx.beginPath();
              ctx.arc(irisCx + irisR * 0.15, irisCy + irisR * 0.2, pupilR * 0.15 + 0.3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        ctx.globalAlpha = savedAlpha;
      } else {
        // Normal circle with subtle inner shading
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
        ctx.fill();

        // Subtle highlight on top half for depth
        if (drawR > 4) {
          ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.2;
          const hlGrad = ctx.createRadialGradient(c.x, c.y - drawR * 0.3, drawR * 0.1, c.x, c.y, drawR);
          hlGrad.addColorStop(0, '#ffffff');
          hlGrad.addColorStop(1, 'transparent');
          ctx.fillStyle = hlGrad;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // === VOID CRACK ORB OVERLAY — purple void energy ===
      if (c.armored && c.armorHP > 0 && drawR > 3) {
        const armorAlpha = (ctx.globalAlpha || 1);
        // Swirling void tendrils radiating from center
        ctx.globalAlpha = armorAlpha * 0.45;
        const facetCount = 5 + (c.id % 3);
        for (let f = 0; f < facetCount; f++) {
          const fAngle = (f / facetCount) * Math.PI * 2 + c.id * 0.7 + G.time * (c.armorHP === 1 ? 2.5 : 0.8);
          const innerR = drawR * 0.1;
          const outerR = drawR * (c.armorHP === 1 ? 1.15 : 0.85);
          // Wavy tendrils
          const midAngle = fAngle + Math.sin(G.time * 3 + f * 1.5) * 0.3;
          const midR = (innerR + outerR) * 0.5;
          ctx.strokeStyle = c.armorHP === 2 ? '#9060ff' : '#ff60ff';
          ctx.lineWidth = c.armorHP === 1 ? 2 : 1.5;
          ctx.beginPath();
          ctx.moveTo(c.x + Math.cos(fAngle) * innerR, c.y + Math.sin(fAngle) * innerR);
          ctx.quadraticCurveTo(
            c.x + Math.cos(midAngle) * midR,
            c.y + Math.sin(midAngle) * midR,
            c.x + Math.cos(fAngle) * outerR,
            c.y + Math.sin(fAngle) * outerR
          );
          ctx.stroke();
        }
        // Void ring — pulsing purple/magenta
        const ringPulse = 0.3 + Math.sin(G.time * 4) * 0.15;
        ctx.globalAlpha = armorAlpha * ringPulse;
        ctx.strokeStyle = c.armorHP === 2 ? '#8040ff' : '#ff40c0';
        ctx.lineWidth = c.armorHP === 1 ? 3 : 2;
        ctx.beginPath();
        ctx.arc(c.x, c.y, drawR * 0.95, 0, Math.PI * 2);
        ctx.stroke();
        // Inner void glow
        if (c.armorHP === 1) {
          ctx.globalAlpha = armorAlpha * 0.2;
          const voidGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR);
          voidGrad.addColorStop(0, '#d060ff');
          voidGrad.addColorStop(0.5, '#8030ff');
          voidGrad.addColorStop(1, 'transparent');
          ctx.fillStyle = voidGrad;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR * 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = armorAlpha;
      }

      // === COMBO-BUBBLE RINGS — merged orb indicator ===
      if (c.mergeCount > 1 && drawR > 4) {
        const mergeAlpha = (ctx.globalAlpha || 1) * 0.3;
        ctx.lineWidth = 1.5;
        const ringCount = Math.min(c.mergeCount - 1, 3);
        for (let ri = 0; ri < ringCount; ri++) {
          ctx.globalAlpha = mergeAlpha * (1 - ri * 0.2);
          ctx.strokeStyle = c.color;
          ctx.beginPath();
          ctx.arc(c.x, c.y, drawR * (0.65 + ri * 0.12), 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      } // close else if (!isAbyssOrb)

      // Fade-in glow: void emergence effect
      if (c.fadeIn > 0) {
        const fadeT = 1 - c.fadeIn;
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = (1 - fadeT) * 0.3;
        const glowR = c.baseRadius * 3 * (1 - fadeT * fadeT);
        if (glowR > 2) {
          const glowGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, glowR);
          glowGrad.addColorStop(0, '#ffffff');
          glowGrad.addColorStop(0.4, c.color);
          glowGrad.addColorStop(1, 'transparent');
          ctx.fillStyle = glowGrad;
          ctx.beginPath();
          ctx.arc(c.x, c.y, glowR, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
      }

      // Merge glow: flash on orb that just absorbed another + expanding ring
      if (c.mergeGlow > 0) {
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = c.mergeGlow * 0.35;
        const mgR = drawR * (1.3 + c.mergeGlow * 0.5);
        const mgGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, mgR);
        mgGrad.addColorStop(0, '#ffffff');
        mgGrad.addColorStop(0.3, c.color);
        mgGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = mgGrad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, mgR, 0, Math.PI * 2);
        ctx.fill();
        // Expanding ring
        ctx.globalAlpha = c.mergeGlow * 0.5;
        ctx.strokeStyle = c.color;
        ctx.lineWidth = 2;
        const ringR = drawR * (1 + (1 - c.mergeGlow) * 0.6);
        ctx.beginPath();
        ctx.arc(c.x, c.y, ringR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      }
    }

    ctx.restore();
  }
}

function renderExplosions(ctx) {
  const madness = getMadnessAmount();
  for (let i = 0; i < G.explosions.length; i++) {
    const e = G.explosions[i];
    ctx.save();

    // Desaturate explosion color with madness (same rate as orb eyes)
    const eColor = madness > 0 ? horrorShift(e.color, madness) : e.color;

    // Layer 1: Bright core flash (decays fast)
    if (e.flashAlpha > 0.05 && !e.isEcho) {
      ctx.globalAlpha = e.flashAlpha * 0.4;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Layer 2: Inner glow fill (white core → color → transparent)
    if (e.life > 0.4) {
      ctx.globalAlpha = (e.life - 0.4) * 0.2;
      const ig = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius);
      ig.addColorStop(0, '#ffffff');
      ig.addColorStop(0.2, eColor);
      ig.addColorStop(1, 'transparent');
      ctx.fillStyle = ig;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Layer 3: Primary expanding ring (thick when fresh, thins out)
    ctx.globalAlpha = e.life * 0.7;
    ctx.strokeStyle = eColor;
    ctx.lineWidth = e.isEcho ? 1.5 : (3 + e.life * 3);
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    ctx.stroke();

    // Layer 4: Secondary shockwave ring (trailing, thinner)
    if (!e.isEcho && e.life > 0.3) {
      ctx.globalAlpha = (e.life - 0.3) * 0.3;
      ctx.strokeStyle = madness > 0 ? horrorShift('#ffffff', madness * 0.5) : '#ffffff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius * 0.85, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Layer 5: Distortion rays (subtle radial pressure lines)
    if (!e.isEcho && e.life > 0.5) {
      ctx.globalAlpha = (e.life - 0.5) * 0.15;
      ctx.strokeStyle = eColor;
      ctx.lineWidth = 0.5;
      const rayCount = 12;
      for (let r = 0; r < rayCount; r++) {
        const angle = (r / rayCount) * Math.PI * 2 + e.radius * 0.02;
        const innerR = e.radius * 0.7;
        const outerR = e.radius * 1.1;
        ctx.beginPath();
        ctx.moveTo(e.x + Math.cos(angle) * innerR, e.y + Math.sin(angle) * innerR);
        ctx.lineTo(e.x + Math.cos(angle) * outerR, e.y + Math.sin(angle) * outerR);
        ctx.stroke();
      }
    }

    // Layer 6: Shockwave distortion — warp nearby orbs positionally (Geometry Wars style)
    if (!e.isEcho && e.life > 0.3) {
      const shockMadPhys = getMadnessPhysicsScale();
      const warpStr = e.life * 4 * shockMadPhys;
      const warpR = e.radius * 1.3 * shockMadPhys;
      for (let ci = 0; ci < G.circles.length; ci++) {
        const c = G.circles[ci];
        if (c.popped || !c.alive) continue;
        const d = dist(e.x, e.y, c.x, c.y);
        if (d < warpR && d > 5) {
          // Push orbs slightly away from blast center (visual-only wobble)
          const dx = c.x - e.x, dy = c.y - e.y;
          const falloff = (1 - d / warpR) * warpStr;
          c.x += (dx / d) * falloff * 0.3;
          c.y += (dy / d) * falloff * 0.3;
        }
      }
    }

    // Wobble ring — distorted shockwave perimeter (sine-warped radius)
    if (!e.isEcho && e.life > 0.2 && e.life < 0.8) {
      ctx.globalAlpha = (e.life - 0.2) * 0.25;
      ctx.strokeStyle = eColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      const wobbleSegs = 64;
      for (let w = 0; w <= wobbleSegs; w++) {
        const wAngle = (w / wobbleSegs) * Math.PI * 2;
        const wobble = Math.sin(wAngle * 6 + e.radius * 0.1) * e.radius * 0.04 * e.life;
        const wr = e.radius * 1.05 + wobble;
        const wx = e.x + Math.cos(wAngle) * wr;
        const wy = e.y + Math.sin(wAngle) * wr;
        if (w === 0) ctx.moveTo(wx, wy); else ctx.lineTo(wx, wy);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Layer 7: Cosmic dust cloud — space-bending debris field
    if (!e.isEcho && e.life > 0.1) {
      ctx.globalCompositeOperation = 'lighter';
      const dustCount = 16;
      const dustSeed = (e.x * 7.1 + e.y * 13.3) | 0;
      for (let di = 0; di < dustCount; di++) {
        // Deterministic pseudo-random per dust mote
        const hash = ((dustSeed + di * 97 + di * di * 31) & 0xffff) / 65535;
        const hash2 = ((dustSeed + di * 53 + di * 17) & 0xffff) / 65535;
        const hash3 = ((dustSeed + di * 137 + di * 41) & 0xffff) / 65535;
        const dAngle = (di / dustCount) * Math.PI * 2 + hash * 0.8;
        // Dust expands outward, then curves — space distortion
        const expandT = 1 - e.life;
        const dDist = e.radius * (0.5 + expandT * 0.7) * (0.6 + hash2 * 0.6);
        // Spiral distortion — dust curves as if space is bending
        const spiralAngle = dAngle + expandT * (hash - 0.5) * 2.5;
        const dx = e.x + Math.cos(spiralAngle) * dDist;
        const dy = e.y + Math.sin(spiralAngle) * dDist;
        // Size pulsates
        const dSize = (1.5 + hash3 * 3.0) * (0.5 + e.life * 0.5);
        // Colors: mix of whites, blues, golds, violets
        const dustColors = ['#ffffff', '#aaccff', '#ffd080', '#c090ff', '#80ffcc'];
        const dColor = dustColors[di % dustColors.length];
        ctx.globalAlpha = e.life * (0.12 + hash3 * 0.1);
        ctx.fillStyle = madness > 0 ? horrorShift(dColor, madness * 0.6) : dColor;
        ctx.beginPath();
        ctx.arc(dx, dy, dSize, 0, Math.PI * 2);
        ctx.fill();
        // Some motes get a streaky tail (bent light)
        if (dSize > 2 && e.life > 0.3) {
          ctx.globalAlpha = e.life * 0.06;
          ctx.strokeStyle = dColor;
          ctx.lineWidth = 0.8;
          const tailAngle = spiralAngle + Math.PI + (hash - 0.5) * 0.5;
          const tailLen = dSize * 3 * e.life;
          ctx.beginPath();
          ctx.moveTo(dx, dy);
          ctx.quadraticCurveTo(
            dx + Math.cos(tailAngle + 0.3) * tailLen * 0.6,
            dy + Math.sin(tailAngle + 0.3) * tailLen * 0.6,
            dx + Math.cos(tailAngle) * tailLen,
            dy + Math.sin(tailAngle) * tailLen
          );
          ctx.stroke();
        }
      }
      ctx.globalCompositeOperation = 'source-over';
    }

    // Layer 8: Space warp ripple — gravitational lens distortion ring
    if (!e.isEcho && e.life > 0.15 && e.life < 0.7) {
      const warpT = (e.life - 0.15) / 0.55;
      ctx.globalAlpha = warpT * 0.08;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = e.radius * 0.06 * warpT;
      ctx.beginPath();
      const lensSegs = 48;
      for (let li = 0; li <= lensSegs; li++) {
        const la = (li / lensSegs) * Math.PI * 2;
        // Double-frequency wobble simulates gravitational lensing
        const lensWarp = Math.sin(la * 3 + e.radius * 0.05) * e.radius * 0.06 * warpT
          + Math.sin(la * 7 - e.radius * 0.03) * e.radius * 0.03 * warpT;
        const lr = e.radius * (1.15 + 0.1 * warpT) + lensWarp;
        const lx = e.x + Math.cos(la) * lr;
        const ly = e.y + Math.sin(la) * lr;
        if (li === 0) ctx.moveTo(lx, ly); else ctx.lineTo(lx, ly);
      }
      ctx.closePath();
      ctx.stroke();
    }

    ctx.restore();
  }
}

function renderParticleLayer(ctx, layer) {
  const particleMadness = getMadnessAmount();
  for (let i = 0; i < particlePool.length; i++) {
    const p = particlePool[i];
    if (!p.active || p.layer !== layer) continue;

    ctx.save();
    ctx.globalAlpha = Math.max(0, p.alpha);

    // Apply madness desaturation to particle colors
    const pColor = particleMadness > 0 ? horrorShift(p.color, particleMadness * 0.6) : p.color;

    switch(p.type) {
      case 'spark':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'ripple':
        ctx.strokeStyle = pColor;
        ctx.lineWidth = 2 * p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
        break;

      case 'ember':
        const eg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
        eg.addColorStop(0, pColor);
        eg.addColorStop(1, 'transparent');
        ctx.fillStyle = eg;
        ctx.fillRect(p.x - p.size*2, p.y - p.size*2, p.size*4, p.size*4);
        break;

      case 'ribbon':
        if (p.trail && p.trail.length > 1) {
          ctx.strokeStyle = pColor;
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let j = 1; j < p.trail.length; j++) {
            ctx.lineTo(p.trail[j].x, p.trail[j].y);
          }
          ctx.stroke();
        }
        break;

      case 'hex':
        ctx.strokeStyle = pColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let s = 0; s < 6; s++) {
          const a = (Math.PI / 3) * s + p.rotation;
          const hx = p.x + p.size * Math.cos(a);
          const hy = p.y + p.size * Math.sin(a);
          if (s === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
        }
        ctx.closePath();
        ctx.stroke();
        break;

      case 'glitch':
        ctx.fillStyle = pColor;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        break;

      case 'splat':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'star':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        const spikes = 4;
        for (let s = 0; s < spikes * 2; s++) {
          const a = (Math.PI / spikes) * s + p.rotation;
          const sr = s % 2 === 0 ? p.size : p.size * 0.3;
          const sx = p.x + Math.cos(a) * sr;
          const sy = p.y + Math.sin(a) * sr;
          if (s === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        ctx.fill();
        break;

      case 'mote':
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        break;
    }

    ctx.restore();
  }
}

function renderFloatingTexts(ctx) {
  const madness = getMadnessAmount();
  // Gameplay text corruption starts at 20% madness, numbers preserved
  const gameTextCorrupt = madness < 0.2 ? 0 : Math.min(1, (madness - 0.2) / 0.6);

  for (let i = 0; i < G.floatingTexts.length; i++) {
    const ft = G.floatingTexts[i];
    const t = ft.life / ft.maxLife;
    const scale = 0.8 + t * 0.7;
    ctx.save();
    ctx.globalAlpha = Math.min(1, t * 2);
    ctx.font = `bold ${Math.round(24 * scale)}px 'Orbitron', 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = madness > 0 ? horrorShift(ft.color, madness * 0.5) : ft.color;
    // Apply Enochian corruption to gameplay text (preserve numbers)
    const displayText = gameTextCorrupt > 0 ? corruptTextPreserveNumbers(ft.text, gameTextCorrupt) : ft.text;
    ctx.fillText(displayText, ft.x, ft.y);
    ctx.restore();
  }
}

function renderWhiteGlow(ctx, W, H) {
  ctx.save();
  ctx.globalAlpha = G.whiteGlow;
  const grad = ctx.createRadialGradient(G.chainOriginX, G.chainOriginY, 0, G.chainOriginX, G.chainOriginY, Math.max(W, H) * 0.6);
  grad.addColorStop(0, '#ffffff');
  grad.addColorStop(1, 'transparent');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
}

function renderDelayedBlastBuildup(ctx, W, H) {
  const db = G.delayedBlast;
  if (!db) return;
  const progress = Math.min(db.timer / db.duration, 1);
  ctx.save();

  // Darkening overlay
  ctx.globalAlpha = db.darkness || 0;
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, W, H);

  // Convergence glow at center — pulses and grows
  const glowSize = 30 + progress * (db.tier === 3 ? 180 : db.tier === 2 ? 120 : 60);
  const pulse = 1 + Math.sin(db.timer * 12) * 0.2;
  ctx.globalAlpha = 0.3 + progress * 0.6;
  const grad = ctx.createRadialGradient(db.centerX, db.centerY, 0, db.centerX, db.centerY, glowSize * pulse);
  const p = getCurrentPalette();
  grad.addColorStop(0, '#ffffff');
  grad.addColorStop(0.3, p.accent);
  grad.addColorStop(1, 'transparent');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(db.centerX, db.centerY, glowSize * pulse, 0, Math.PI * 2);
  ctx.fill();

  // Converging ring lines
  if (db.tier >= 2) {
    const rings = db.tier === 3 ? 3 : 2;
    for (let r = 0; r < rings; r++) {
      const ringProgress = ((db.timer * 2 + r * 0.4) % 1);
      const ringRadius = (1 - ringProgress) * 300;
      ctx.globalAlpha = ringProgress * 0.4;
      ctx.strokeStyle = p.accent;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(db.centerX, db.centerY, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ==================================================
// SECTION 13: POST-PROCESSING EFFECTS
// ==================================================
function createScanlinePattern() {
  const sc = document.createElement('canvas');
  sc.width = 4;
  sc.height = 6;
  const sctx = sc.getContext('2d');
  sctx.fillStyle = 'rgba(0,0,0,0.04)';
  sctx.fillRect(0, 0, 4, 2);
  G.scanlinePattern = G.ctx.createPattern(sc, 'repeat');
}

// Nebula clouds — slow-drifting ambient color blobs
const nebulaClouds = [];
for (let i = 0; i < 6; i++) {
  nebulaClouds.push({
    x: Math.random(), y: Math.random(), // 0-1 normalized
    size: 0.15 + Math.random() * 0.2,
    speedX: (Math.random() - 0.5) * 0.003,
    speedY: (Math.random() - 0.5) * 0.002,
    phase: Math.random() * Math.PI * 2,
    colorIdx: Math.floor(Math.random() * 3)
  });
}

function renderNebulaClouds(ctx, W, H) {
  const p = getCurrentPalette();
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < nebulaClouds.length; i++) {
    const nc = nebulaClouds[i];
    // Drift
    nc.x += nc.speedX * G.dt;
    nc.y += nc.speedY * G.dt;
    // Wrap
    if (nc.x < -0.2) nc.x = 1.2;
    if (nc.x > 1.2) nc.x = -0.2;
    if (nc.y < -0.2) nc.y = 1.2;
    if (nc.y > 1.2) nc.y = -0.2;

    const cx = nc.x * W;
    const cy = nc.y * H;
    const breathe = 1 + Math.sin(G.time * 0.3 + nc.phase) * 0.15;
    const r = nc.size * Math.min(W, H) * breathe;
    // Brighter during chains
    const chainGlow = G.chainActive ? 0.03 + G.chainCount * 0.001 : 0;
    ctx.globalAlpha = 0.025 + chainGlow;
    const horror = getHorrorAmount();
    const nc1 = horror > 0 ? horrorShift(p.colors[nc.colorIdx], horror) : p.colors[nc.colorIdx];
    const nc2 = horror > 0 ? horrorShift(p.colors[(nc.colorIdx + 1) % 3], horror) : p.colors[(nc.colorIdx + 1) % 3];
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    grad.addColorStop(0, nc1);
    grad.addColorStop(0.5, nc2);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

// ABYSS-specific background: deep-sea particles, bioluminescent haze, caustics, marine snow
const abyssParticles = [];
for (let i = 0; i < 25; i++) {
  abyssParticles.push({
    x: Math.random(), y: Math.random(),
    size: 0.5 + Math.random() * 1.5,
    speedY: -(0.002 + Math.random() * 0.005), // slowly rising
    speedX: (Math.random() - 0.5) * 0.002,
    phase: Math.random() * Math.PI * 2,
    bright: Math.random()
  });
}
// Marine snow — tiny sinking particles
const abyssSnow = [];
for (let i = 0; i < 15; i++) {
  abyssSnow.push({
    x: Math.random(), y: Math.random(),
    size: 0.3 + Math.random() * 0.8,
    speedY: 0.003 + Math.random() * 0.004,   // sinking down
    speedX: (Math.random() - 0.5) * 0.001,
    phase: Math.random() * Math.PI * 2,
    bright: 0.3 + Math.random() * 0.7
  });
}

function renderAbyssBackground(ctx, W, H) {
  const isAbyss = G.biomeOverride >= 0 && SPECIAL_BIOMES[G.biomeOverride] && SPECIAL_BIOMES[G.biomeOverride].name === 'ABYSS';
  if (!isAbyss) return;

  ctx.save();
  const p = getCurrentPalette();

  // Bioluminescent haze blobs — soft glowing patches
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < 5; i++) {
    const hx = W * (0.15 + i * 0.18) + Math.sin(G.time * 0.08 + i * 2) * W * 0.08;
    const hy = H * (0.25 + i * 0.12) + Math.cos(G.time * 0.06 + i * 3) * H * 0.07;
    const hr = Math.min(W, H) * (0.18 + 0.07 * Math.sin(G.time * 0.12 + i));
    const breathe = 0.6 + 0.4 * Math.sin(G.time * 0.2 + i * 1.5);
    ctx.globalAlpha = 0.025 * breathe;
    const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, hr);
    hGrad.addColorStop(0, p.colors[i % 3]);
    hGrad.addColorStop(0.4, p.accent);
    hGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = hGrad;
    ctx.beginPath();
    ctx.arc(hx, hy, hr, 0, Math.PI * 2);
    ctx.fill();
  }

  // Volumetric light shafts — wide, blurred beams from surface
  ctx.globalCompositeOperation = 'lighter';
  // Soft glow pass — wide diffuse light cones
  for (let i = 0; i < 6; i++) {
    const cx = W * (0.1 + i * 0.15) + Math.sin(G.time * 0.2 + i * 1.7) * W * 0.1;
    const botY = H * (0.55 + Math.sin(G.time * 0.15 + i * 2.3) * 0.12);
    const beamW = 50 + Math.sin(G.time * 0.3 + i * 3.1) * 25;
    const shimmer = 0.5 + 0.5 * Math.sin(G.time * 0.6 + i * 2.1);
    // Outer soft glow cone
    ctx.globalAlpha = 0.025 * shimmer;
    const glowGrad = ctx.createLinearGradient(cx, 0, cx + beamW * 0.2, botY);
    glowGrad.addColorStop(0, p.accent);
    glowGrad.addColorStop(0.2, p.colors[0]);
    glowGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.moveTo(cx - beamW * 1.5, 0);
    ctx.lineTo(cx + beamW * 1.5, 0);
    ctx.lineTo(cx + beamW * 0.4, botY);
    ctx.lineTo(cx - beamW * 0.4, botY);
    ctx.closePath();
    ctx.fill();
    // Inner bright core beam
    ctx.globalAlpha = 0.04 * shimmer;
    const coreGrad = ctx.createLinearGradient(cx, 0, cx + beamW * 0.1, botY * 0.8);
    coreGrad.addColorStop(0, '#ffffff');
    coreGrad.addColorStop(0.15, p.accent);
    coreGrad.addColorStop(0.5, p.colors[0]);
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.moveTo(cx - beamW * 0.6, 0);
    ctx.lineTo(cx + beamW * 0.6, 0);
    ctx.lineTo(cx + beamW * 0.15, botY * 0.8);
    ctx.lineTo(cx - beamW * 0.15, botY * 0.8);
    ctx.closePath();
    ctx.fill();
  }

  // Drifting deep-sea particles — tiny rising motes (bioluminescence)
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < abyssParticles.length; i++) {
    const ap = abyssParticles[i];
    ap.x += ap.speedX * G.dt;
    ap.y += ap.speedY * G.dt;
    if (ap.y < -0.05) { ap.y = 1.05; ap.x = Math.random(); }
    if (ap.x < -0.05) ap.x = 1.05;
    if (ap.x > 1.05) ap.x = -0.05;

    const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(G.time * 0.5 + ap.phase));
    ctx.globalAlpha = 0.08 * twinkle * ap.bright;
    ctx.fillStyle = p.accent;
    ctx.beginPath();
    ctx.arc(ap.x * W, ap.y * H, ap.size, 0, Math.PI * 2);
    ctx.fill();
  }

  // Marine snow — tiny white particles sinking downward
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < abyssSnow.length; i++) {
    const ms = abyssSnow[i];
    ms.x += ms.speedX * G.dt;
    ms.y += ms.speedY * G.dt;
    if (ms.y > 1.05) { ms.y = -0.05; ms.x = Math.random(); }
    if (ms.x < -0.05) ms.x = 1.05;
    if (ms.x > 1.05) ms.x = -0.05;

    const drift = Math.sin(G.time * 0.3 + ms.phase) * 0.5 + 0.5;
    ctx.globalAlpha = 0.06 * drift * ms.bright;
    ctx.fillStyle = '#aaccdd';
    ctx.beginPath();
    ctx.arc(ms.x * W, ms.y * H, ms.size, 0, Math.PI * 2);
    ctx.fill();
  }

  // Depth fog — darkness gradient at bottom (deep pressure)
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 0.15;
  const depthGrad = ctx.createLinearGradient(0, H * 0.5, 0, H);
  depthGrad.addColorStop(0, 'transparent');
  depthGrad.addColorStop(1, '#000408');
  ctx.fillStyle = depthGrad;
  ctx.fillRect(0, 0, W, H);

  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// Bloom glow behind orbs — soft radial gradient halo
function renderOrbBloom(ctx) {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (c.popped || !c.alive) continue;
    if (c.fadeIn > 0.5) continue; // don't bloom while barely visible

    const pulse = 1 + Math.sin(c.pulsePhase) * 0.12;
    const r = c.radius * pulse * 2.5;
    const spawnScale = c.spawnAnim > 0 ? (1 - c.spawnAnim) : 1;
    const drawR = r * spawnScale;
    if (drawR < 3) continue;

    // Volatile orbs glow brighter
    const bloomAlpha = c.volatile ? 0.12 : (c.superCell ? 0.1 : 0.04);
    ctx.globalAlpha = bloomAlpha;
    const grad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, drawR);
    grad.addColorStop(0, c.color);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(c.x, c.y, drawR, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

// Light rays emanating from active explosions
function renderLightRays(ctx, W, H) {
  if (G.explosions.length === 0) return;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < G.explosions.length; i++) {
    const e = G.explosions[i];
    if (e.life < 0.3) continue; // only fresh explosions emit rays

    const rayCount = 8;
    const rayLen = e.maxRadius * 1.5 * e.life;
    ctx.globalAlpha = e.life * 0.06;
    ctx.strokeStyle = e.color;
    ctx.lineWidth = 1 + e.life * 2;
    for (let r = 0; r < rayCount; r++) {
      const angle = (r / rayCount) * Math.PI * 2 + G.time * 0.5 + i * 1.7;
      const endX = e.x + Math.cos(angle) * rayLen;
      const endY = e.y + Math.sin(angle) * rayLen;
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    }
  }
  ctx.restore();
}

// Energy distortion pulse rings during active chain
function renderChainEnergyField(ctx, W, H) {
  if (!G.chainActive || G.chainCount < 3) return;
  ctx.save();
  const cx = G.chainOriginX;
  const cy = G.chainOriginY;
  const intensity = Math.min(1, G.chainCount / 30);

  // Pulsing distortion rings
  const ringCount = Math.min(4, Math.floor(G.chainCount / 6));
  for (let r = 0; r < ringCount; r++) {
    const phase = (G.time * 3 + r * 1.5) % 3;
    const radius = phase * 120;
    const alpha = Math.max(0, (1 - phase / 3)) * intensity * 0.12;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = getCurrentPalette().accent;
    ctx.lineWidth = 1.5 - phase * 0.3;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.stroke();
  }
  ctx.restore();
}

function renderVignette(ctx, W, H) {
  const grad = ctx.createRadialGradient(W/2, H/2, W*0.25, W/2, H/2, W*0.8);
  grad.addColorStop(0, 'transparent');
  grad.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function renderChromaticAb(ctx, W, H) {
  const offset = G.chromaticAb * 1.5;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 0.08;
  ctx.drawImage(G.canvas, -offset, 0);
  ctx.drawImage(G.canvas, offset, 0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// ==================================================
// SECTION 14: INPUT HANDLING
// ==================================================

// Convert screen coordinates to game world coordinates (accounting for zoom)
function screenToWorld(sx, sy) {
  const cx = G.W / 2, cy = G.H / 2;
  return {
    x: (sx - cx) / G.zoomLevel + cx,
    y: (sy - cy) / G.zoomLevel + cy
  };
}

function handleTap(x, y) {
  initAudio();

  if (G.state === 'title') {
    resetGame();
    return;
  }

  if (G.state === 'game_over') {
    resetGame();
    return;
  }

  if (G.state !== 'playing') return;
  if (G.taps <= 0) return;
  if (G.pendingLevelUp) return;

  // Reset tap timer on every click
  G.tapTimer = G.tapTimerMax;

  // Black hole tap: triggers collapse for free (doesn't cost a tap)
  if (tryTapBlackHole(x, y)) return;

  // Normal tap — startChain (mines now launched via long press)
  G.bombsPlacedThisRound = 0;
  startChain(x, y);
}

function handleLongPress(x, y) {
  // Long press places mine if charges available
  if (G.state !== 'playing') return;
  const charges = G.upgrades.bombCharges;
  if (charges <= 0) return;
  if (G.bombsPlacedThisRound >= charges) return;

  placeBomb(x, y);
  G.bombsPlacedThisRound++;
  updateHUD();
  // Visual feedback
  spawnFloatingText(x, y - 20, 'MINE PLACED', '#ff8800');
}

function setupInput() {
  const c = G.canvas;
  const LONG_PRESS_MS = 350; // 350ms hold = long press → mine
  let pressTimer = null;
  let pressPos = null;
  let didLongPress = false;

  function startPress(wx, wy) {
    pressPos = { x: wx, y: wy };
    didLongPress = false;
    clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      didLongPress = true;
      handleLongPress(pressPos.x, pressPos.y);
    }, LONG_PRESS_MS);
  }

  function endPress(wx, wy) {
    clearTimeout(pressTimer);
    if (!didLongPress) {
      // Short tap — normal action
      handleTap(wx, wy);
    }
    pressTimer = null;
    pressPos = null;
    didLongPress = false;
  }

  function cancelPress() {
    clearTimeout(pressTimer);
    pressTimer = null;
    pressPos = null;
    didLongPress = false;
  }

  c.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = c.getBoundingClientRect();
    const sx = touch.clientX - rect.left;
    const sy = touch.clientY - rect.top;
    const w = screenToWorld(sx, sy);
    G.cursorX = w.x; G.cursorY = w.y;
    initAudio();
    startPress(w.x, w.y);
  }, { passive: false });

  c.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (pressPos) {
      endPress(pressPos.x, pressPos.y);
    }
  }, { passive: false });

  c.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
      const rect = c.getBoundingClientRect();
      const w = screenToWorld(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      G.cursorX = w.x; G.cursorY = w.y;
      // Update press position if dragging during long press
      if (pressPos) {
        pressPos.x = w.x;
        pressPos.y = w.y;
      }
    }
  }, { passive: false });

  c.addEventListener('mousedown', (e) => {
    const rect = c.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const w = screenToWorld(sx, sy);
    G.cursorX = w.x; G.cursorY = w.y;
    initAudio();
    startPress(w.x, w.y);
  });

  c.addEventListener('mouseup', (e) => {
    const rect = c.getBoundingClientRect();
    const w = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
    if (pressPos) {
      endPress(w.x, w.y);
    }
  });

  c.addEventListener('mousemove', (e) => {
    const rect = c.getBoundingClientRect();
    const w = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
    G.cursorX = w.x; G.cursorY = w.y;
  });

  c.addEventListener('mouseleave', () => {
    G.cursorX = -1000; G.cursorY = -1000;
    cancelPress();
  });

  // Keyboard: B toggles biome
  document.addEventListener('keydown', (e) => {
    if (e.key === 'b' || e.key === 'B') {
      toggleBiome();
    }
  });

  // Biome button
  document.getElementById('biome-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleBiome();
  });

  // Dev: Madness toggle button
  document.getElementById('madness-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    if (devMadnessOverride >= 0) {
      devMadnessOverride = -1; // off — restore normal
      document.getElementById('madness-btn').classList.remove('active');
      // Restore score-based zoom
      G.zoomTarget = Math.max(0.5, 2.0 - G.score * (1.5 / 200000));
      // Snap watcher opacity to 0 immediately
      G.watcher.opacity = 0;
    } else {
      devMadnessOverride = 1.0; // full madness
      document.getElementById('madness-btn').classList.add('active');
    }
  });

  // Prevent default behaviors
  document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
}

function toggleBiome() {
  // Snapshot current palette before switching
  G.prevPalette = getCurrentPalette();
  if (G.biomeOverride >= 0) {
    G.biomeOverride = -1;
    document.getElementById('biome-btn').classList.remove('active');
  } else {
    G.biomeOverride = 0;
    document.getElementById('biome-btn').classList.add('active');
  }
  // Trigger smooth palette transition
  G.biomeTransition = 0;
  // Re-color all existing orbs
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.popped && c.alive) {
      c.color = getClusterColor(c.x, c.y);
      c.colorEdge = c.color;
    }
  }
  // Show biome lore text
  const togglePalette = getCurrentPalette();
  const toggleLoreArr = BIOME_LORE[togglePalette.name] || [];
  const toggleLore = toggleLoreArr.length ? toggleLoreArr[Math.floor(Math.random() * toggleLoreArr.length)] : '';
  if (toggleLore) {
    const lx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const ly = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.3;
    setTimeout(() => spawnFloatingText(lx, ly, toggleLore, togglePalette.accent, 3.0), 800);
  }
}

// Advance to the next biome (called when field is cleared)
function advanceBiome() {
  G.prevPalette = getCurrentPalette();
  if (G.biomeOverride >= 0) {
    // Currently in a special biome — cycle back to level-based
    G.biomeOverride = -1;
    document.getElementById('biome-btn').classList.remove('active');
  } else {
    // Level-based: force advance to next palette index
    const curIdx = Math.min(Math.floor((G.level - 1) / PALETTE_LEVELS), PALETTES.length - 1);
    const nextIdx = (curIdx + 1) % PALETTES.length;
    // Bump level to match the next palette
    G.level = nextIdx * PALETTE_LEVELS + 1;
    G.xpToNext = XP_BASE * Math.pow(XP_SCALE, G.level - 1);
  }
  G.biomeTransition = 0;
  // Re-color existing orbs
  for (let i = 0; i < G.circles.length; i++) {
    const c = G.circles[i];
    if (!c.popped && c.alive) {
      c.color = getClusterColor(c.x, c.y);
      c.colorEdge = c.color;
    }
  }
  // Show biome lore text
  const advPalette = getCurrentPalette();
  const advLoreArr = BIOME_LORE[advPalette.name] || [];
  const advLore = advLoreArr.length ? advLoreArr[Math.floor(Math.random() * advLoreArr.length)] : '';
  if (advLore) {
    const lx = ((G.gameLeft || 0) + (G.gameRight || G.W)) * 0.5;
    const ly = ((G.gameTop || 0) + (G.gameBottom || G.H)) * 0.3;
    setTimeout(() => spawnFloatingText(lx, ly, advLore, advPalette.accent, 3.0), 800);
  }
}

// ==================================================
// SECTION 15: UI / HUD & FLOATING TEXT
// ==================================================
function spawnFloatingText(x, y, text, color, duration) {
  if (G.floatingTexts.length >= MAX_FLOATING_TEXTS) G.floatingTexts.shift();
  const life = duration || 1.2; // 25% faster default (was 1.5)
  G.floatingTexts.push({ x, y, text, color, life: life, maxLife: life, vy: -70 });
}

function updateFloatingTexts(dt) {
  for (let i = G.floatingTexts.length - 1; i >= 0; i--) {
    const ft = G.floatingTexts[i];
    ft.y += ft.vy * dt;
    ft.life -= dt;
    if (ft.life <= 0) G.floatingTexts.splice(i, 1);
  }
}

// Enochian / occult glyphs — arcane symbols for text corruption
// Mix of Runic (Elder Futhark), Baybayin, Ethiopic, and other esoteric Unicode blocks
const ENOCHIAN_CHARS = 'ᚠᚢᚦᚨᚱᚲᚷᚹᚺᚻᚾᛁᛃᛇᛈᛉᛊᛏᛒᛖᛗᛚᛝᛞᛟᜀᜁᜂᜃᜄᜅᜆᜇᜈᜉᜊᜋᜌᜍᜎᜏ';

// Deterministic corruption: each character position has a fixed "corruption threshold"
// based on its position hash. When madness exceeds that threshold, it flips permanently.
// This creates the "one letter at a time" effect — no flickering, just steady creep.
function corruptText(text, madness) {
  if (madness <= 0) return text;
  let result = '';
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    // Preserve spacing/punctuation
    if (ch === ' ' || ch === ':' || ch === '—' || ch === '\n') {
      result += ch;
      continue;
    }
    // Each position has a deterministic threshold based on char code + position
    // Using a simple hash so the same text always corrupts the same way
    const hash = ((ch.charCodeAt(0) * 31 + i * 137 + text.length * 7) % 997) / 997;
    // The threshold determines when THIS specific letter corrupts
    // Letters with low hashes corrupt first (at low madness), high hashes last
    if (madness > hash) {
      // This letter is corrupted — pick a deterministic Enochian replacement
      const glyphIdx = (ch.charCodeAt(0) * 13 + i * 47) % ENOCHIAN_CHARS.length;
      result += ENOCHIAN_CHARS[glyphIdx];
    } else {
      result += ch;
    }
  }
  return result;
}

// Like corruptText but preserves digits, +, -, spaces, punctuation
function corruptTextPreserveNumbers(text, madness) {
  if (madness <= 0) return text;
  let result = '';
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (/[\d+\-\s:!.,]/.test(ch)) { result += ch; continue; }
    const hash = ((ch.charCodeAt(0) * 31 + i * 137 + text.length * 7) % 997) / 997;
    if (madness > hash) {
      const glyphIdx = (ch.charCodeAt(0) * 13 + i * 47) % ENOCHIAN_CHARS.length;
      result += ENOCHIAN_CHARS[glyphIdx];
    } else {
      result += ch;
    }
  }
  return result;
}

function updateHUD() {
  // Show mine charges remaining if mine layer is active
  const charges = G.upgrades.bombCharges;
  const minesLeft = charges > 0 ? charges - G.bombsPlacedThisRound : 0;
  const tapsDisplay = minesLeft > 0 ? `${G.taps} (${minesLeft}m)` : `${G.taps}`;

  const madness = getMadnessAmount();

  // Numbers always readable — only labels corrupt with madness
  const labelCorrupt = madness < 0.4 ? 0 : Math.min(1, (madness - 0.4) / 0.6);

  document.getElementById('hud-taps').textContent = tapsDisplay;
  document.getElementById('hud-level').textContent = `${G.level}`;
  document.getElementById('hud-score').textContent = `${G.score}`;

  // Corrupt labels at higher madness
  if (labelCorrupt > 0) {
    const hudEl = document.getElementById('hud');
    if (hudEl) {
      const labels = hudEl.querySelectorAll('div');
      const origLabels = ['Taps', 'Level', 'Score'];
      labels.forEach((el, idx) => {
        if (idx < origLabels.length) {
          const textNode = el.childNodes[0];
          if (textNode && textNode.nodeType === 3) {
            textNode.textContent = corruptText(origLabels[idx], labelCorrupt);
          }
        }
      });
    }
  }

  const pct = Math.min(100, (G.xp / G.xpToNext) * 100);
  document.getElementById('xp-bar-fill').style.width = pct + '%';
}

function showGameOver() {
  document.getElementById('hud').style.display = 'none';
  document.getElementById('xp-bar-wrap').style.display = 'none';
  document.getElementById('go-score').textContent = `Score: ${G.score}`;
  document.getElementById('go-level').textContent = `Level: ${G.level}`;
  document.getElementById('go-chain').textContent = `Best Chain: ${G.bestChain}`;
  document.getElementById('gameover-screen').style.display = 'flex';
}

// ==================================================
// SECTION 16: GAME LOOP & LIFECYCLE
// ==================================================
function update(dt) {
  // Cursor velocity — track mouse/touch speed for brush force
  if (G.cursorX > 0 && G.prevCursorX > 0) {
    G.cursorVx = (G.cursorX - G.prevCursorX) / Math.max(dt, 0.001);
    G.cursorVy = (G.cursorY - G.prevCursorY) / Math.max(dt, 0.001);
  } else {
    G.cursorVx = 0; G.cursorVy = 0;
  }
  G.prevCursorX = G.cursorX;
  G.prevCursorY = G.cursorY;

  // Biome transition
  if (G.biomeTransition < 1) {
    G.biomeTransition = Math.min(1, G.biomeTransition + dt * 0.5);
  }

  // Dev madness override affects zoom — full madness = fully zoomed out
  if (devMadnessOverride >= 0) {
    // Lerp zoom toward madness-scaled target: 0.5 at full madness
    G.zoomTarget = Math.max(0.5, 2.0 - devMadnessOverride * 1.5);
  }

  // Smooth zoom transition
  if (Math.abs(G.zoomLevel - G.zoomTarget) > 0.001) {
    G.zoomLevel = lerp(G.zoomLevel, G.zoomTarget, dt * 2);
  }

  // Update visible game boundaries based on zoom (centered on screen)
  const halfW = G.W / (2 * G.zoomLevel);
  const halfH = G.H / (2 * G.zoomLevel);
  const cx = G.W / 2, cy = G.H / 2;
  G.gameLeft = cx - halfW;
  G.gameTop = cy - halfH;
  G.gameRight = cx + halfW;
  G.gameBottom = cy + halfH;
  G.gameW = G.gameRight - G.gameLeft;
  G.gameH = G.gameBottom - G.gameTop;

  if (G.state === 'title' || G.state === 'game_over') {
    updateParticles(dt);
    return;
  }

  if (G.state !== 'playing') return;

  // MAIN BIOME: Whirlwind — periodic swirl toward center
  updateWhirlwind(dt);
  // ABYSS MECHANIC: Pressure Waves — periodic crushing force pushes orbs inward
  updateAbyssalPressure(dt);

  updateChainReaction(dt);
  updateCircles(dt);
  updateInterOrbGravity(dt);
  updateColorSynthesis(dt);
  updateOrbMerging(dt);
  updateMergeAnimations(dt);
  updateExplosions(dt);
  updateParticles(dt);
  updateAmbientParticles(dt);
  updateFieldStars(dt, G.W, G.H);
  updateFloatingTexts(dt);
  updateAftershocks(dt);
  updateGravityWells(dt);
  updateBlackHole(dt);
  updateBoss(dt);
  updateWatcher(dt);
  updateBombs(dt);
  updateRefillQueue(dt);

  // 100 BPM beat pulse system — random orbs pulse on beat at 50%+ madness
  const beatMadness = getMadnessAmount();
  if (beatMadness >= 0.5) {
    const bpm120Period = 0.6; // 100 BPM = 0.6s per beat
    const prevPhase = G.beatPhase;
    G.beatPhase += dt / bpm120Period;
    // On each beat crossing (phase wraps past 1.0)
    if (Math.floor(G.beatPhase) > Math.floor(prevPhase)) {
      G.beatPhase -= Math.floor(G.beatPhase);
      // Select random 15-40% of living orbs to pulse
      G.beatPulseOrbs = [];
      const selectChance = 0.15 + Math.random() * 0.25;
      for (let i = 0; i < G.circles.length; i++) {
        const c = G.circles[i];
        if (!c.popped && c.alive && Math.random() < selectChance) {
          G.beatPulseOrbs.push(c.id);
        }
      }
    }
  } else {
    G.beatPhase = 0;
    G.beatPulseOrbs = [];
  }

  // Tap timer countdown (uses raw dt so slo-mo doesn't save you)
  if (G.taps > 0 && !G.pendingLevelUp && !G.chainActive) {
    G.tapTimer -= G.rawDt;
    if (G.tapTimer <= 0) {
      G.taps--;
      G.tapTimer = G.tapTimerMax;
      if (G.taps <= 0) {
        G.state = 'game_over';
        showGameOver();
      }
      updateHUD();
    }
  }

  // Decay effects
  if (G.shakeAmount > 0) G.shakeAmount = Math.max(0, G.shakeAmount - dt * 15);
  if (G.chromaticAb > 0) G.chromaticAb = Math.max(0, G.chromaticAb - dt * 8);
  if (G.whiteGlow > 0) G.whiteGlow = Math.max(0, G.whiteGlow - dt * 1.5);

  // Recover time scale
  if (G.timeScale < 1.0) {
    G.timeScale = Math.min(1.0, G.timeScale + G.rawDt * 0.3);
  }
}

function gameLoop(timestamp) {
  requestAnimationFrame(gameLoop);

  const rawDt = Math.min((timestamp - G.lastTime) / 1000, 0.05);
  G.lastTime = timestamp;
  G.rawDt = rawDt;
  G.dt = rawDt * G.timeScale;
  G.time += G.dt;

  update(G.dt);
  render();
}

// ==================================================
// SECTION 17: INITIALIZATION & BOOT
// ==================================================
function resizeCanvas() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  G.dpr = dpr;
  G.W = window.innerWidth;
  G.H = window.innerHeight;
  G.canvas.width = G.W * dpr;
  G.canvas.height = G.H * dpr;
  G.canvas.style.width = G.W + 'px';
  G.canvas.style.height = G.H + 'px';
  G.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  createScanlinePattern();
}

function init() {
  G.canvas = document.getElementById('c');
  G.ctx = G.canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  setupInput();

  // Spawn some ambient circles for title screen
  spawnInitialCircles();

  G.lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
